---
layout: post
title: 操作系统
categories: 计算机组成
---

### 1. 简介

<div align=center>
<img 
src="/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90-0004-1.png" 
width = "600" />
<p></P>
</div>


操作系统提供一个易于使用的物理资源的抽象。

context switch:

为了实现多个任务的并行运行，操作系统会控制某一程序使用 CPU 的时间，并且在时间到后切换到另一个程序。程序切换时，程序的运行状态必须保存，该过程通过操作系统来控制。context switch 即指从一个执行的程序切换到另一个程序的过程。该过程如下：

1. OS 中断当前的进程，控制 CPU
2. 保存当前进程的状态
3. 加载下一个进程的状态
4. 将 CPU 移交给下个进程

通过 context switch，不同进程可以在共享的硬件上运行，并且不同进程之间是孤立的。

硬件通常提供两种运行模式，为内核模式和用户模式。在用户模式下，特定的操作被禁止，用户模式下的程序需要通过系统调用来运行一些功能，例如创建删除文件、访问外部设备等。

### 2. 中断和异常

中断：
* 由当前运行程序之外的事件引发
* 不需要立即处理，但是应该尽快处理

异常：
* 在执行当前程序时遇到的事件引发
* 必须立即处理

中断和异常通过 trap handler 来处理。陷阱处理程序的流程：

1. 保存当前程序的状态
2. 决定造成异常或者中断的原因
3. 处理中断或者异常，处理后要么继续运行程序，要么中断程序

### 3. 内核

内核是操作系统的核心，可以对资源进行管理，例如程序调度、内存管理、I/O 管理。

电脑启动的流程：
1. BIOS 运行
     * 执行 POST
     * BIOS 找到并且执行 bootloader
2. bootloader 加载 OS
3. OS 初始化服务
4. 运行进程

### 4. 虚拟内存

直接使用物理内存所遇到的问题：
1. 没有足够的空间
2. 可能存在空间的浪费
3. 无法提供进程之间的隔离

这些问题通过虚拟内存来解决，虚拟内存把程序的地址映射到内存地址。

<div align=center>
<img 
src="/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90-0004-2.png" 
width = "600" />
<p></p>
</div>

如果没有虚拟内存，程序可以直接访问内存地址空间，对程序的内存访问无法进行任何管理。虚拟内存把程序的地址空间和内存地址空间隔离开来，程序地址需要通过映射过程，映射到实际的内存地址，同时有一部分程序地址会映射到磁盘中。

解决的问题：
1. 映射一部分地址到磁盘中，解决空间不够的问题
2. 由于增加了映射过程，程序看见的地址空间是连续的，但映射到内存中，可以分段放在内存中任意位置。
3. 程序 a 和程序 b的地址映射到不同的内存地址，程序之间无法访问对方的地址空间。如果需要共享数据，例如库，那么虚拟内存可以把两个程序的地址映射到同一块内存地址，方便实现共享。

虚拟内存把地址分成：
* 虚拟地址 (Virtual Address, VA)，这是程序看见的地址
* 物理地址 (Physical Address, PA)，对应的是 RAM 中实际地址

地址翻译过程：
1. 程序指定一个虚拟地址，假设执行的是读取指令
2. 计算机把该虚拟地址转换成对应的物理地址
3. 如果物理地址不在内存中，OS 从磁盘中加载数据
4. 计算机读取物理地址中的数据，把数据返回给程序

记录 VA 和 PA 对应关系的为页表 (page table)。但是如果页表中保存每一个虚拟地址的映射，那么页表会非常大，因此，页表中是对内存块 (chunks) 进行映射。页表中把虚拟地址中的一块映射到物理地址中的一块。目前，块大小通常是 4KB。

### 5. IO

内存中的一部分专门用于与 I/O 设备通信，该区域中的地址对应不同的 I/O 设备。当 CPU 想要给某个设备发送信息，在对应位置“写入”数据，硬件会中断写入过程，把数据发送到对应的设备。

CPU 会周期性的检查状态寄存器，看是否有任何需要接收的数据，该过程叫做轮询。通常发生在上下文交换的过程中，每几毫秒就会切换进程，每次切换时，OS 会检查 I/O 设备。


