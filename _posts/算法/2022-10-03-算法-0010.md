---
layout: post
title: 加权最短路径
categories: 算法
---

### 1. 加权图

review:
* 单源最短路径：BFS， O(\|V\| + \|E\|)
* 单源可达性：BFS 或者 DFS，O(\|E\|) (因为只返回可以到达的顶点)
* 连通性：Full-BFS 或者 Full-DFS, O(\|V\| + \|E\|)
* 拓扑排序：Full-DFS, O(\|V\| + \|E\|)

之前最短路径按照 distance = number of edges in path 来算，现在考虑加权图中的最短路径。

加权图：
* 带有权重函数 w 的图，例如给图中的每条边 e = (u, v) 分配一个整数权重 w(e) = w(u, v)
* 加权图的应用：
    - 道路交通中的距离
    - 网络连接中的延迟
    - 社交网络中的关系好坏程度
* 表示权重的两种方式：
    - 直接在邻接表中存储权重
    - 或者存储一个 set 数据结构，把边映射到权重

加权路径：
* 一条路径的权重 w(π) 是路径中所有边的权重之和
* 在加权图中，从 s 到 t 的加权最短路径是权重最小的路径

加权最短路径算法：

<div align=center>
<img 
src="/image/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95-0010-1.png" 
width = "600" />
<p></p>
</div>

### 2. 计算最短路径树
* 对于 BFS，在搜索时一直记录 parent。但是，也可以从每个顶点的最短距离计算出来。
* 如果知道所有顶点 v 的 δ(s, v)， 可以用 `O(|V|+|E|)` 的时间创建出最短路径树

使用 δ(s, v) 计算最短路径树，步骤如下：
* 初始化 P，设置 P(s) = None
* 对于每个顶点 u，δ(s, u) 是有限的：
    - 对于 u 的 outgoing neighbor v:
    - 如果 P(v) 没有被分配，并且 δ(s, v) = δ(s, u) + w(u, v)
    - 那么在 (u, v) 之间存在最短路径，设置 P(v) = u
* 父指针可能会遍历零权重的环路，标记在环中的所有顶点
* 对于所有未标记的顶点 u
    - 对于 u 的邻接点 v，且 v 已经被标记，并且 δ(s, v) = δ(s, u) + w(u, v)
    - 从 v 开始遍历父指针，取消标记该环中的顶点
    - 设置 P(v) = u, 打破环

该算法可以在线性时间内计算出最短路径树结点中的父指针。

### 3. DAG Relaxation

relaxation: 对于一个优化问题，要得到最优解， 可以从一个非最优解开始然后逐渐迭代来改进解，直到达到问题的最优解。

* 记录距离估计 d(s, v)，初始化为无穷大。该距离估计一定是真实距离 δ(s, v) 的上界，接下来需要逐步减少距离，直到 d(s, v) = δ(s, v)
* 什么时候降低 d(s, v)？在边违反**三角不等式**的时候

* 三角不等式：从 u 到 v 的最短路径权重不能大于从 u 经另一个顶点 x 到 v 的最短路径权重，即 δ(u, v) ≤ δ(u, x)+ δ(x, v) for all u, v, x ∈ V
* 如果 d(s, v) > d(s, u) + w(u, v)，违反了三角不等式
* fix 方法：降低 d(s, v) 为 d(s, u) + w(u, v)。

可以证明最短路径估计 d(s, v) 永远不会小于真实的最短路径权重 δ(s, v)
* Safety Lemma: 在 relax 过程中，d(s, v) 会一直大于等于 δ(s, v)
* 证明：证明更强的声明，对于所有的 v，d(s, v) 在迭代时要么是无穷大，要么是 s 到 v 的**某一条路径**的权重，即 d(s, v) 会一直大于等于 δ(s, v)。
    - 在初始的时候正确，d(s, v) 为无穷大
    - 假设在某一时刻声明为正确，relax 边 (u, v)。relax 边会让 d(s, v) 减少到 d(s, u) + w(u, v)，即 d(s, v) 变为从 s 出发，经过 u 到 v 路径的权重。


在 DAG 中，不存在环路，relaxation 最后一定会结束。按照拓扑顺序依次放松出边，可以正确的计算出最短路径。该算法叫做 DAG Relaxation。

步骤：
* 设置 d(s, v) = ∞, d(s, s) = 0
* 对于图 G 中的所有顶点，按照拓扑顺序处理每一个顶点 u
    - 对于 u 的 outgoing neighbor v ∈ Adj<sup>+</sup>(u)
    - 如果 d(s, v) > d(s, u) + w(u, v)
    - 设置 d(s, v) = d(s, u) + w(u, v)

运行时间：
* `O(|V| + |E|)`