---
layout: post
title: Hashing
categories: 算法
---

### 1. 比较模型

<div align=center>
<img 
src="/image/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95-0003-1.png" 
width = "500" />
<p></p>
</div>

在序列接口常用的操作中，普通的 Array 实现，时间复杂度都为 O(n)，这些操作都需要遍历整个数组。而 Sorted Array 由于在内部保持元素的有序性，在 find 操作上占优势。那么，可以实现更快的查找和动态操作吗，可以让 find 操作时间复杂度小于 O(log n)吗？

**比较模型：**
* 在该模型中，算法仅能通过比较来区分不同的元素
* 可比较的项相当于一个黑盒，只能支持两个项之间的比较操作
* 比较操作有：<, <=, >, >=, ==, != 
* **目标**：在 n 个可比较项的集合上，实现 find(k) 操作
* 比较的次数决定了运行时间的下界，因此，评估时间复杂度，要数比较操作的次数。


**决策树：**
* 任何比较模型的 find 算法可以看作执行比较操作的决策树(decision tree)
* 内部结点表示两个元素的比较，分支代表结果为 True 或 False
* 叶子结点代表算法结束，产生算法的输出
* 由根结点到叶子结点的路径表示在特定输出时算法所执行的操作
* 对于每个算法的输出，都需要一个叶子结点，因此决策树最少有 n+1 个叶子结点。这 n+1 个叶子结点分别对应数组内的 n 个元素，以及数组内不包含要查找元素这个特殊情况。

**注意：**这里的目的是实现 find 操作，决策树也是对应的 find 操作，与算法导论第 8 章中的排序决策树有差别。

通过比较操作来查找某一元素的时间复杂度：
* 可以对比较操作进行计数，来确定时间复杂度的下界
* 由于最少有 n+1 个叶子结点，因此，二叉树的最小高度为 Ω(log n)，运行时间的下界为 Ω(log n)

如何实现更快的 find 操作？

### 2. Hashing

通过比较操作来查找元素，下界为 Ω(log n)，假如要实现更快的 find 操作，可以通过直接访问的方法。这有点类似于内存访问。

### 2.1 直接访问数组 (Direct Access Arrays)

假如要存储 n 个项，给每个项分配一个在 [0, u-1] 范围内的独特整数值，那么可以直接把这 n 个项存储在长度为 u 的直接访问数组中。数组中索引为 i 个位置存储的是分配到整数 i 的项。如果要查找该项，只要访问数组中索引 i 位置即可。

直接访问数组的 order 操作时间复杂度会高，因为项并不是依次分配整数值，在数组中一个位置可能不存在项，但之后的位置可能存在项。要查找下一个元素，必须依次往后面找。

直接访问数组的 find 操作时间复杂度取决于 n 和 u 的关系。当 u >> n，不会发生冲突，但是数组中存在空间的浪费。当 u < n 时，这也是常见的情况，必须要处理项之间冲突的问题。

```
class DirectAccressArray:
    def __init__(self, u):   self.A  =[None] * u   # 初始化空间为 u 的数组
    def find(self, k):       return self.A[k]      # 查找索引为 k 的项
    def insert(self, x):     self.A[x.key] = x     # 按 key 存入项
    def delete(self, k):     self.A[k] = None      # 删除索引为 k 的项
    def find_next(self, k):
        for i in range(k, len(self.A)):   # 从索引 k 开始依次往后找
            if A[i] is not None:
                return A[i]
    def find_max(self):                   # 从后往前找
        for i in range(len(self.A)-1, -1, -1):
            if A[i] is not None:
                return A[i]
    def delete_max(self):
        for i in range(len(self.A)-1, -1, -1):
            x = A[i]
            if x is not None:
                A[i] = None
                return x
```

### 2.2 hashing

直接访问数组可以 O(1) 时间复杂度实现 find，insert，delete操作，但是前提是 u >> n。当 n << u 时，如何用 O(n) 空间来实现直接访问数组呢？

可以把 n 项存储在一个小空间的数组中，数组的尺寸不为 u，而是 m = O(n)。给项分配整数值后也不能直接存入数组，得通过映射过程，把 [0, u-1] 范围内的值映射到 [0, m-1]。这样的映射函数叫做 hash 函数。

* 通过 hash 函数，把项映射到数组中特定的位置
* hash 函数：h(k) : {0, . . . , u − 1} → {0, . . . , m − 1}
    - u 是所有项可能的取值，m 是数组的尺寸
* 长度比项所有可能取值 u 更小的直接访问数组，叫做 hash 表，空间为 m。
* 如果两个元素a，b，h(a) = h(b)，那么发生了冲突。
    - 要么通过开放寻址来解决，存储在数组中的其他位置
    - 要么通过链接来解决，把具有相同的 hash 值元素存储在一块，然后链接到索引位置。


### 2.3 hash 函数

最简单的 hash 函数： h(k) = (k mod m)
* 当所有的 key 是均匀分布时，可以有好的效果
* m 一般选大的质数

通用 hash 函数： hab(k) = (((ak + b) mod p) mod m) 
* a, b ∈ {0, . . . , p − 1} and a 不为 0
* 在多个 hash 函数中，随机选择 a，b，确定一个 hash 函数
* 可以达到更短的链长度，即冲突少。m = Ω(n) 时，在每个索引位置的链长度期望值为 O(1)

<div align=center>
<img 
src="/image/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95-0003-2.png" 
width = "600" />
</div>