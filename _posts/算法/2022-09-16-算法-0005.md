---
layout: post
title: 二叉树 I
categories: 算法
---

### 1. 二叉树

序列结构介绍了数组、链表、动态数组，操作的时间复杂度见上表。集合数据结构介绍了数组、有序数组、直接访问数组、hash 表。但是这些数据结构在某一项或者两项操作的时间复杂度占优势，无法兼顾全部操作的时间复杂度。而通过二叉树可以实现 “Goal” 一栏的时间复杂度。

二叉树是基于指针的数据结构，每个结点包含三个指针，分别为 node.parent, node.left, node.right。

**术语**：
* 根：在树中如果某一结点没有父结点，那么该结点叫做树的根
* 叶结点：没有孩子结点
* 结点 x 的深度：从根结点到该结点的路径长度
* 结点 x 的高度：以 x 为根的子树的最大深度

为什么要使用树结构？

树结构也是也指针为基础的，每个结点包含三个指针。但是与链表不同，在链表中每访问一个结点都得从前往后开始遍历，时间复杂度为 O(n)。二叉树通过每个结点的 2 个分支，将树的高度最低可以降到 O(logn)。

因此，二叉树所有算法的基本 idea 为：对于树高为 h 的树，设计算法，使得操作的时间复杂度为 O(h), 并且尽可能维持 h = O(logn)，使得最后算法的时间复杂度为 O(h)=O(logn)

二叉树的遍历，如果按照中序遍历：
* 结点 x 左子树的结点在 x 之前
* 结点 x 右子树的结点在 x 之后
* 从根结点开始递归遍历

### 2. 树的遍历

以下全部按中序遍历，介绍了遍历中结点出现的顺序。

以结点 x 为根的子树中**第一个结点**：
* 如果 x 有左孩子，递归返回左子树的第一个结点
* 否则，x 是第一个结点，返回 x
* 运行时间为 O(h)

以结点 x 为根的子树中**最后一个结点**：
* 如果 x 有右孩子，递归返回右子树的最后一个结点
* 否则，x 是最后一个结点，返回 x


结点 x 的**后继结点**：
* 如果 x 有右子树，返回右子树第一个结点
* 否则，返回 x 的最低祖先结点，且 x 要在该祖先结点的左子树中
* 运行时间为 O(h)

结点 x 的**前驱结点**：
* 如果 x 有左子树，返回左子树最后一个结点
* 否则，返回 x 的最低祖先结点，x 要在该祖先结点的右子树中

### 3. 动态操作

在 x 结点之后**插入**新结点 y：
* 如果 x 没有右子树，把 y 放入 x 的右孩子结点
* 否则，把 y 放入 x 后继结点 s 的左孩子结点中。s 一定没有左孩子，因为 s 是 x 右子树第一个结点。y 相当于放在 s 的前面。

**删除**结点 x：
* 如果 x 是叶子结点，直接删除
* 否则，x 有孩子结点。此时不能直接删除 x，得与其他结点交换，让 x 变到叶子结点。
    - 如果 x 有左孩子，让 x 与其**前驱结点**交换，递归删除 x 结点
    - 否则，让 x 与其**后继结点**交换，递归删除 x 结点
* 运行时间为 O(h)

### 4. 应用

#### 4.1 Set

* idea：集合中重要的是 **find** 操作，为了用树实现比较，常用的是二叉搜索树 (Binary Search Tree / BST)。
    - 中序遍历得到的结果是按键排列好的
    - 等价的 BST 属性：对于每个结点，左子树中的值小于结点的值，右子树中的值大于结点的值。
* 在树中查找键值 k
    - 如果 k 小于结点 x 的值，在左子树中递归查找
    - 如果 k 大于结点 x 的值，在右子树中递归查找
    - 否则，返回 x

#### 4.2 Sequence

* idea：使得中序遍历得到的顺序是按序列顺序排列的
* 查找 i 结点的操作，调用 subtree_at(i)。但是需要从头开始进行中序遍历，时间复杂度为 O(n)。
* 但是，如果可以用 O(1) 的时间复杂度得到**子树的大小** (size)，访问 i 结点的操作时间复杂度可以降到 O(h)。子树大小指子树中结点的总个数。
    - 首先检查**左子树**的大小 n<sub>L</sub>，并且与 i 比较
    - 如果 i < n<sub>L</sub>，说明第 i 个结点在左子树，递归查找
    - 如果 i > n<sub>L</sub>，在右子树上递归查找，且 i' = i - n<sub>L</sub> - 1
    - 否则，i = n<sub>L</sub>，则根结点索引值为 i，返回根结点
* 通过扩增 (augmentation) 来记录每个结点子树的尺寸
    - 在 node 中加入属性 node.size
    - 当加入一个新的叶子结点，对于该结点的所有祖先结点，size 都加 1
    - 当删除一个叶子结点，对于该结点的所有祖先结点，size 减少 1
* subtree augmentation：
    - 每个结点存储 O(1) 额外的属性
    - subtree 的属性可以从其左子树和右子树的属性用 O(1) 时间计算出来
    - 无论对树进行什么修改操作，都得更新结点的属性
    - 可能的 subtree properties：sum，product，min，max，height
    - 不能作为 subtree properties：index，depth

时间复杂度：
<div align=center>
<img 
src="/image/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95-0005-1.png" 
width = "500" />
<p></p>
</div>






