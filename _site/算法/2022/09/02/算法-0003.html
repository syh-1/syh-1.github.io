<!DOCTYPE html>
<html lang="zh-cn"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Hashing | syh 的博客</title>
<meta name="generator" content="Jekyll v4.2.2" />
<meta property="og:title" content="Hashing" />
<meta name="author" content="syh" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="1. 比较模型" />
<meta property="og:description" content="1. 比较模型" />
<link rel="canonical" href="http://localhost:4000/%E7%AE%97%E6%B3%95/2022/09/02/%E7%AE%97%E6%B3%95-0003.html" />
<meta property="og:url" content="http://localhost:4000/%E7%AE%97%E6%B3%95/2022/09/02/%E7%AE%97%E6%B3%95-0003.html" />
<meta property="og:site_name" content="syh 的博客" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2022-09-02T00:00:00+08:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Hashing" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"syh"},"dateModified":"2022-09-02T00:00:00+08:00","datePublished":"2022-09-02T00:00:00+08:00","description":"1. 比较模型","headline":"Hashing","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/%E7%AE%97%E6%B3%95/2022/09/02/%E7%AE%97%E6%B3%95-0003.html"},"url":"http://localhost:4000/%E7%AE%97%E6%B3%95/2022/09/02/%E7%AE%97%E6%B3%95-0003.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/css/style.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="syh 的博客" />

<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/site.webmanifest">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
<meta name="msapplication-TileColor" content="#da532c">
<meta name="theme-color" content="#ffffff"></head>
<body><header class="site-header">

  <div class="wrapper"><a class="site-title" rel="author" href="/">syh 的博客</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/%E7%AE%97%E6%B3%95.html">算法</a><a class="page-link" href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90.html">计算机组成</a><a class="page-link" href="/about/">关于我</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Hashing</h1>
    <p class="post-meta"><time class="dt-published" datetime="2022-09-02T00:00:00+08:00" itemprop="datePublished">
        Sep 2, 2022
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <h3 id="1-比较模型">1. 比较模型</h3>

<div align="center">
<img src="/image/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95-0003-1.png" width="500" />
<p></p>
</div>

<p>在序列接口常用的操作中，普通的 Array 实现，时间复杂度都为 O(n)，这些操作都需要遍历整个数组。而 Sorted Array 由于在内部保持元素的有序性，在 find 操作上占优势。那么，可以实现更快的查找和动态操作吗，可以让 find 操作时间复杂度小于 O(log n)吗？</p>

<p><strong>比较模型：</strong></p>
<ul>
  <li>在该模型中，算法仅能通过比较来区分不同的元素</li>
  <li>可比较的项相当于一个黑盒，只能支持两个项之间的比较操作</li>
  <li>比较操作有：&lt;, &lt;=, &gt;, &gt;=, ==, !=</li>
  <li><strong>目标</strong>：在 n 个可比较项的集合上，实现 find(k) 操作</li>
  <li>比较的次数决定了运行时间的下界，因此，评估时间复杂度，要数比较操作的次数。</li>
</ul>

<p><strong>决策树：</strong></p>
<ul>
  <li>任何比较模型的 find 算法可以看作执行比较操作的决策树(decision tree)</li>
  <li>内部结点表示两个元素的比较，分支代表结果为 True 或 False</li>
  <li>叶子结点代表算法结束，产生算法的输出</li>
  <li>由根结点到叶子结点的路径表示在特定输出时算法所执行的操作</li>
  <li>对于每个算法的输出，都需要一个叶子结点，因此决策树最少有 n+1 个叶子结点。这 n+1 个叶子结点分别对应数组内的 n 个元素，以及数组内不包含要查找元素这个特殊情况。</li>
</ul>

<p><strong>注意：</strong>这里的目的是实现 find 操作，决策树也是对应的 find 操作，与算法导论第 8 章中的排序决策树有差别。</p>

<p>通过比较操作来查找某一元素的时间复杂度：</p>
<ul>
  <li>可以对比较操作进行计数，来确定时间复杂度的下界</li>
  <li>由于最少有 n+1 个叶子结点，因此，二叉树的最小高度为 Ω(log n)，运行时间的下界为 Ω(log n)</li>
</ul>

<p>如何实现更快的 find 操作？</p>

<h3 id="2-hashing">2. Hashing</h3>

<p>通过比较操作来查找元素，下界为 Ω(log n)，假如要实现更快的 find 操作，可以通过直接访问的方法。这有点类似于内存访问。</p>

<h3 id="21-直接访问数组-direct-access-arrays">2.1 直接访问数组 (Direct Access Arrays)</h3>

<p>假如要存储 n 个项，给每个项分配一个在 [0, u-1] 范围内的独特整数值，那么可以直接把这 n 个项存储在长度为 u 的直接访问数组中。数组中索引为 i 个位置存储的是分配到整数 i 的项。如果要查找该项，只要访问数组中索引 i 位置即可。</p>

<p>直接访问数组的 order 操作时间复杂度会高，因为项并不是依次分配整数值，在数组中一个位置可能不存在项，但之后的位置可能存在项。要查找下一个元素，必须依次往后面找。</p>

<p>直接访问数组的 find 操作时间复杂度取决于 n 和 u 的关系。当 u » n，不会发生冲突，但是数组中存在空间的浪费。当 u &lt; n 时，这也是常见的情况，必须要处理项之间冲突的问题。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class DirectAccressArray:
    def __init__(self, u):   self.A  =[None] * u   # 初始化空间为 u 的数组
    def find(self, k):       return self.A[k]      # 查找索引为 k 的项
    def insert(self, x):     self.A[x.key] = x     # 按 key 存入项
    def delete(self, k):     self.A[k] = None      # 删除索引为 k 的项
    def find_next(self, k):
        for i in range(k, len(self.A)):   # 从索引 k 开始依次往后找
            if A[i] is not None:
                return A[i]
    def find_max(self):                   # 从后往前找
        for i in range(len(self.A)-1, -1, -1):
            if A[i] is not None:
                return A[i]
    def delete_max(self):
        for i in range(len(self.A)-1, -1, -1):
            x = A[i]
            if x is not None:
                A[i] = None
                return x
</code></pre></div></div>

<h3 id="22-hashing">2.2 hashing</h3>

<p>直接访问数组可以 O(1) 时间复杂度实现 find，insert，delete操作，但是前提是 u » n。当 n « u 时，如何用 O(n) 空间来实现直接访问数组呢？</p>

<p>可以把 n 项存储在一个小空间的数组中，数组的尺寸不为 u，而是 m = O(n)。给项分配整数值后也不能直接存入数组，得通过映射过程，把 [0, u-1] 范围内的值映射到 [0, m-1]。这样的映射函数叫做 hash 函数。</p>

<ul>
  <li>通过 hash 函数，把项映射到数组中特定的位置</li>
  <li>hash 函数：h(k) : {0, . . . , u − 1} → {0, . . . , m − 1}
    <ul>
      <li>u 是所有项可能的取值，m 是数组的尺寸</li>
    </ul>
  </li>
  <li>长度比项所有可能取值 u 更小的直接访问数组，叫做 hash 表，空间为 m。</li>
  <li>如果两个元素a，b，h(a) = h(b)，那么发生了冲突。
    <ul>
      <li>要么通过开放寻址来解决，存储在数组中的其他位置</li>
      <li>要么通过链接来解决，把具有相同的 hash 值元素存储在一块，然后链接到索引位置。</li>
    </ul>
  </li>
</ul>

<h3 id="23-hash-函数">2.3 hash 函数</h3>

<p>最简单的 hash 函数： h(k) = (k mod m)</p>
<ul>
  <li>当所有的 key 是均匀分布时，可以有好的效果</li>
  <li>m 一般选大的质数</li>
</ul>

<p>通用 hash 函数： hab(k) = (((ak + b) mod p) mod m)</p>
<ul>
  <li>a, b ∈ {0, . . . , p − 1} and a 不为 0</li>
  <li>在多个 hash 函数中，随机选择 a，b，确定一个 hash 函数</li>
  <li>可以达到更短的链长度，即冲突少。m = Ω(n) 时，在每个索引位置的链长度期望值为 O(1)</li>
</ul>

<div align="center">
<img src="/image/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95-0003-2.png" width="600" />
</div>

  </div><a class="u-url" href="/%E7%AE%97%E6%B3%95/2022/09/02/%E7%AE%97%E6%B3%95-0003.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col">
        <ul class="contact-list">
          <li class="p-name">syh</li>
          <li><a class="u-email" href="mailto:songibicf@gmail.com">songibicf@gmail.com</a></li>
        </ul>
      </div>
      <div class="footer-col">
        <p>记录计算机专业相关内容，Mens et Manus
</p>
      </div>
    </div>

    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span id="busuanzi_container_site_pv">总访问量 <span id="busuanzi_value_site_pv"></span> 次</span>

    <div class="social-links"><ul class="social-media-list"><li><a rel="me" href="https://github.com/syh-1" target="_blank" title="syh-1"><svg class="svg-icon grey"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg></a></li></ul>
</div>

    

  </div>

</footer>
</body>

</html>
