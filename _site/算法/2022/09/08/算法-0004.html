<!DOCTYPE html>
<html lang="zh-cn"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>线性排序 | syh 的博客</title>
<meta name="generator" content="Jekyll v4.2.2" />
<meta property="og:title" content="线性排序" />
<meta name="author" content="syh" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="1. 比较排序的时间复杂度下界" />
<meta property="og:description" content="1. 比较排序的时间复杂度下界" />
<link rel="canonical" href="http://localhost:4000/%E7%AE%97%E6%B3%95/2022/09/08/%E7%AE%97%E6%B3%95-0004.html" />
<meta property="og:url" content="http://localhost:4000/%E7%AE%97%E6%B3%95/2022/09/08/%E7%AE%97%E6%B3%95-0004.html" />
<meta property="og:site_name" content="syh 的博客" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2022-09-08T00:00:00+08:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="线性排序" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"syh"},"dateModified":"2022-09-08T00:00:00+08:00","datePublished":"2022-09-08T00:00:00+08:00","description":"1. 比较排序的时间复杂度下界","headline":"线性排序","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/%E7%AE%97%E6%B3%95/2022/09/08/%E7%AE%97%E6%B3%95-0004.html"},"url":"http://localhost:4000/%E7%AE%97%E6%B3%95/2022/09/08/%E7%AE%97%E6%B3%95-0004.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/css/style.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="syh 的博客" />

<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/site.webmanifest">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
<meta name="msapplication-TileColor" content="#da532c">
<meta name="theme-color" content="#ffffff"></head>
<body><header class="site-header">

  <div class="wrapper"><a class="site-title" rel="author" href="/">syh 的博客</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/%E7%AE%97%E6%B3%95.html">算法</a><a class="page-link" href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90.html">计算机组成</a><a class="page-link" href="/about/">关于我</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">线性排序</h1>
    <p class="post-meta"><time class="dt-published" datetime="2022-09-08T00:00:00+08:00" itemprop="datePublished">
        Sep 8, 2022
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <h3 id="1-比较排序的时间复杂度下界">1. 比较排序的时间复杂度下界</h3>

<p>之前通过 hash，可以用  Θ(n) 的空间，实现时间复杂度为 O(1) 的 find 操作。目前从前往后依次介绍了 Array、Sorted Array、Direct Access Array、Hash Table，那么能够实现快速的排序吗？</p>

<p><strong>决策树模型：</strong></p>

<ul>
  <li>决策树是二叉树，每个结点代表一次比较后的结果，叶子结点代表最终结果</li>
  <li>决策树的叶子节点数 L &gt;= 可能的输出结果数, 由于对长度为 n 的数组排序，输出结果数为 n!，因此 L &gt;= n!</li>
  <li>树高度下界可根据 L 得出，为 Ω(log L)，替换 L 为 n!，log(n!) = Ω(n log n)。因此树高度下界为  Ω(nlogn)，即所需比较次数最少为 Ω(nlogn)。</li>
</ul>

<p>时间复杂度为 O(nlogn) 的<strong>归并排序</strong>在比较模型中已经是最优的排序算法，如果需要更快的排序算法，就不能采用比较的方法。</p>

<h3 id="2-直接访问数组排序">2. 直接访问数组排序</h3>

<ul>
  <li>假设所有的键为独特的非负整数，范围为 {0,…,u-1}，且 n &lt;= u</li>
  <li>把每个项插入到直接访问数组中，时间复杂度为 Θ(n)</li>
  <li>按顺序读取数组中的值，时间复杂度为 Θ(u)</li>
  <li>直接访问数组排序的时间复杂度为 Θ(u)</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def direct_access_sort(A):
    "Sort A assuming items have distinct non-negative keys"
    u = 1 + max([x.key for x in A])
    D = [None] * u
    for x in A:
        D[x.key] = x
    i = 0
    for key in range(u):
        if D[key] is not None:
            A[i] = D[key]
            i += 1
</code></pre></div></div>

<p>直接访问数组排序的时间复杂度与 u 有关。如果 u = Θ(n)，那么排序的时间复杂度为 Θ(n)。如果 u = Ω(n^2)，排序的时间复杂度很高。而且，直接访问数组无法处理存在重复键的情况。</p>

<h4 id="21-u--ωn2-的情况">2.1 u = Ω(n^2) 的情况</h4>

<p>当 u 比 n 大很多时，为了降低排序的时间复杂度，可以采用如下方法：</p>
<ul>
  <li>对于每一个项的键 k 来说，用元组 (a, b) 来表示，k = an + b</li>
  <li>相当于 a = k // n，b = k % n</li>
  <li>接下来对元组进行排序</li>
</ul>

<p><strong>元组排序 (Tuple Sort)</strong></p>
<ul>
  <li>项的键为元组，例如 x.key = (x.k1, x.k2, x.k3, …)，k1 是最高有效位</li>
  <li>排序时对元组中的每个有效位依次排序，先排序最低有效位，最后排序最高有效位</li>
  <li>例如：[32, 03, 44, 42, 22] =&gt; [42, 22, 32, 03, 44] =&gt; [03, 22, 32, 42, 44]</li>
</ul>

<p>按上面的方法，对元组可以有效的排序，但是当存在相同元组项时，如何进行排序呢？</p>

<h4 id="22-计数排序-counting-sort">2.2. 计数排序 (Counting Sort)</h4>

<p>为了存储有重复键的项，可以采取一下方法：</p>

<ul>
  <li>在数组每个索引位置，不仅仅是存储一个元素，而是存储一个 chain，保持具有多个相同索引值的项</li>
  <li>为了排序稳定性，chain 中必须记录项的插入顺序，可以使用序列来维持插入顺序</li>
  <li>排序时，按顺序读出所有的 chains</li>
  <li>算法总的时间复杂度为 O(n+u)，当 u = O(n) 时，时间复杂度为 O(n)</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def counting_sort(A):
    "Sort A assuming items have non-negative keys"
    u = 1 + max([x.key for x in A])
    D = [[] for i in range(u)]
    for x in A:
        D[x.key].append(x)
    i = 0
    for chain in D:
        for x in chain:
            A[i] = x
            i += 1
</code></pre></div></div>

<h3 id="3-基数排序-radix-sort">3. 基数排序 (Radix Sort)</h3>

<p>现在把元组排序和计数排序组合起来，得到基数排序，得到比直接访问数组排序更好的排序方法。</p>

<ul>
  <li>如果 u &lt; n^2，使用计数排序来排序元组 (a, b)</li>
  <li>先对最低有效位 b 进行排序，接着对 a 进行排序</li>
  <li>对元组一个有效位排序时间复杂度为 O(n)，总时间复杂度为 O(2n) = O(n)</li>
</ul>

<p>如果 key &lt; n^c, 每个 key 最多可以分成长度为 c 的元组。接着对元组进行元组排序，时间复杂度为 O(cn) = O(n)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def radix_sort(A):
    "Sort A assuming items have non-negative keys"
    n = len(A)
    u = 1 + max([x.key for x in A])
    c = 1 + (u.bit_length() // n.bit_length())
    class Obj: pass
    D = [Obj() for a in A]
    for i in range(n):
        D[i].digits = []
        D[i].item = A[i]
        high = A[i].key
        for j in range(c):
            high, low  = divmod(high, n)
            D[i].digits.append(low)
    for i in range(c):
        for j in range(n):
            D[j].key = D[j].digits[i]
        counting_sort(D)
    for i in range(n):
        A[i] = D[i].item
</code></pre></div></div>

<p>排序算法的时间复杂度：</p>

<div align="center">
<img src="/image/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95-0004-1.png" width="500" />
<p></p>
</div>

  </div><a class="u-url" href="/%E7%AE%97%E6%B3%95/2022/09/08/%E7%AE%97%E6%B3%95-0004.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col">
        <ul class="contact-list">
          <li class="p-name">syh</li>
          <li><a class="u-email" href="mailto:songibicf@gmail.com">songibicf@gmail.com</a></li>
        </ul>
      </div>
      <div class="footer-col">
        <p>记录计算机专业相关内容，Mens et Manus
</p>
      </div>
    </div>

    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span id="busuanzi_container_site_pv">总访问量 <span id="busuanzi_value_site_pv"></span> 次</span>

    <div class="social-links"><ul class="social-media-list"><li><a rel="me" href="https://github.com/syh-1" target="_blank" title="syh-1"><svg class="svg-icon grey"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg></a></li></ul>
</div>

    

  </div>

</footer>
</body>

</html>
