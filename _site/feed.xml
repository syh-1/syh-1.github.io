<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2022-10-13T22:09:39+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">syh 的博客</title><subtitle>记录计算机专业相关内容，Mens et Manus
</subtitle><author><name>syh</name><email>songibicf@gmail.com</email></author><entry><title type="html">APSP 算法</title><link href="http://localhost:4000/%E7%AE%97%E6%B3%95/2022/10/13/%E7%AE%97%E6%B3%95-0013.html" rel="alternate" type="text/html" title="APSP 算法" /><published>2022-10-13T00:00:00+08:00</published><updated>2022-10-13T00:00:00+08:00</updated><id>http://localhost:4000/%E7%AE%97%E6%B3%95/2022/10/13/%E7%AE%97%E6%B3%95-0013</id><content type="html" xml:base="http://localhost:4000/%E7%AE%97%E6%B3%95/2022/10/13/%E7%AE%97%E6%B3%95-0013.html"><![CDATA[<h3 id="1-apsp">1. APSP</h3>

<p>APSP (All-Pairs Shortest Paths) 问题：</p>
<ul>
  <li>输入: 有向图 G = (V, E)，带有权重函数 w</li>
  <li>输出：输出所有的 δ(u, v)，如果 G 包含负权重环路，记录该顶点</li>
</ul>

<p>可以简单的运行 SSSP 算法 |V| 次。但是在包含负权重的图中，Johnson 算法可以把复杂度降低为 <code class="language-plaintext highlighter-rouge">|V|·O(|V|log|V|+|E|)</code></p>

<p>方法：</p>
<ul>
  <li>Idea：在保留最短路径的前提下，让所有边的权重变为非负。例如，让 G 变为 G’，且 G’ 中没有负权重，在这个过程中，G 中的最短路径和 G’ 中的最短路径要保持一致。如果图中没有负权重，那么可以使用 Dijkstra 算法运行 |V| 次来解决 APSP。</li>
  <li>Claim：可以从 G’ 中的距离计算出 G 中的距离，且时间复杂度为 <code class="language-plaintext highlighter-rouge">O(|V|(|V|+|E|))</code>
    <ul>
      <li>对于 V’ 中的每个顶点 s，从距离中可以计算出最短路径树，时间复杂度为 <code class="language-plaintext highlighter-rouge">O(|V| + |E|)</code></li>
      <li>这也是 G 中的最短路径树，所以用 DFS 遍历树，可以计算出 G 中的距离</li>
      <li>总共花费 <code class="language-plaintext highlighter-rouge">O(|V|(|V|+|E|))</code>时间</li>
    </ul>
  </li>
  <li>Claim：如果 G 中包含负权重环路，无法把 G 转变为非负权重图 G’</li>
  <li>Proof：如果一个图为非负权重，那么其最短路径是简单路径。但是在有负权重环路的图中，最短路径不一定是简单路径。无法做到 G 和 G’ 中的最短路径保持不变。</li>
</ul>

<h3 id="2-权重变为非负">2. 权重变为非负</h3>

<p>如果图 G 有负权重，但是没有负权重环路，如何把权重变为非负：</p>
<ul>
  <li>Idea：在每条的权重上，增加最小权重的负值，那么得到的所有权重都是非负的</li>
  <li>上述 idea 不可行，因为，没有保留最短路径不变， G’ 中最短路径偏向于选择更少边的路径。</li>
  <li>Idea：给定顶点 v，在所有的出边上加 h，在所有的入边上减少 h</li>
  <li>Claim：在上述的重新赋权重后，最短路径得到了保留</li>
  <li>Proof：
    <ul>
      <li>v 开始的每条路径权重改变了 h</li>
      <li>以 v 结束的每条路径权重改变了 -h</li>
      <li>经过 v 的路径权重局部不改变</li>
    </ul>
  </li>
</ul>

<p><strong>potential function h：</strong>把 V 映射到整数</p>

<p>图 G’ 此时由 G 创建而来，但是边 (u, v) 的权重 w’(u, v) = w(u, v) + h(u) - h(v)</p>

<p>Claim: 图 G 中的最短路径还是 G’ 中的最短路径</p>

<p>Proof：</p>
<ul>
  <li>G 中路径 π = (v0, …, vk) 权重为 w(π)。该路径在 G’中的权重是 w(π) + h(v0) - h(vk)</li>
  <li>从 v0 到 vk 所有的路径都是改变了相同的量，都是 h(v0)-h(vk)</li>
  <li>所以图 G 中的最短路径还是 G’ 中的最短路径</li>
</ul>

<hr />

<p>找到 potential function：</p>
<ul>
  <li>需要满足对于任意的边 (u, v)，w(u,v) + h(u) - h(v) &gt;= 0</li>
  <li>变形后得到：h(v) &lt;= h(u)+w(u, v)，形式类似于三角不等式</li>
  <li>Idea：选 h(v) = δ(s, v)，那么上述条件可能满足，但是图中可能存在不连通的点，因此 h(v) 不能简单的选为 δ(s, v)</li>
  <li>
    <p>Idea：增加一个新顶点 s，该顶点有指向任一顶点的出边，且这些出边的权重为 0。通过增加新顶点和权重为 0 的边，避免了图不连通的问题。 h(v) 可以选为 δ(s, v)。</p>
  </li>
  <li>Claim：如果 δ(s, v) = −∞，那么原始的图中存在负权重环路</li>
  <li>Proof：
    <ul>
      <li>在图中增加的新顶点 s 不会添加环路，因为 s 只有出边</li>
      <li>如果没有负权重环路，那么 δ(s, v) &lt;= 0，如果 δ(s, v) = −∞，那么原始的图中存在负权重环路</li>
    </ul>
  </li>
</ul>

<p><strong>Johnson’s 算法：</strong></p>
<ul>
  <li>从图 G 增加一个顶点 x，x 有权重为 0 的出边连接到每一个顶点，得到图 Gx</li>
  <li>使用 Bellman-Ford 算法计算 δ(x, v)</li>
  <li>如果 δ(x, v) = −∞，那么对于该顶点 v：
    <ul>
      <li>Abort</li>
    </ul>
  </li>
  <li>否则：
    <ul>
      <li>更改边的权重为 w’(u, v) = w(u, v) + δ(x, u) - δ(x, v)，形成图 G’</li>
      <li>对于每个顶点 u：</li>
      <li>使用 Dijkstra 算法计算到每个顶点 v 的 δ’(u, v)</li>
      <li>图 G 中的距离 δ(u, v) = δ’(u, v) − δ(x, u) + δ(x, v)</li>
    </ul>
  </li>
</ul>

<p>运行时间：
<code class="language-plaintext highlighter-rouge">O(|V| * (|V|log|V| + |E|))</code></p>]]></content><author><name>syh</name><email>songibicf@gmail.com</email></author><category term="算法" /><summary type="html"><![CDATA[1. APSP]]></summary></entry><entry><title type="html">Dijkstra 算法</title><link href="http://localhost:4000/%E7%AE%97%E6%B3%95/2022/10/12/%E7%AE%97%E6%B3%95-0012.html" rel="alternate" type="text/html" title="Dijkstra 算法" /><published>2022-10-12T00:00:00+08:00</published><updated>2022-10-12T00:00:00+08:00</updated><id>http://localhost:4000/%E7%AE%97%E6%B3%95/2022/10/12/%E7%AE%97%E6%B3%95-0012</id><content type="html" xml:base="http://localhost:4000/%E7%AE%97%E6%B3%95/2022/10/12/%E7%AE%97%E6%B3%95-0012.html"><![CDATA[<h3 id="1-dijkstra-算法">1. Dijkstra 算法</h3>

<p>处理 non-negative edge weights:</p>

<p>idea：在加权图中泛化 BFS 方法
    - 重复探索更近的顶点，从近到远探索</p>

<p>如何在不知道距离的前提下探索顶点？</p>

<p><strong>Observation 1：</strong>如果权重非负，那么沿着最短路径，距离是在增加的
    - 例如，如果 u 出现在 s 到 v 的最短路径上，那么 δ(s, u) ≤ δ(s, v)
    - 把从 s 起，经过距离 &lt;= x 可以到达的顶点集合记为 Vx
    - 如果 v ∈ Vx，那么从 s 到 v 的最短路径只包含 Vx 中的顶点
    - 那么可以在探索的时候逐渐扩充 Vx</p>

<p><strong>Ovservation 2：</strong>如果把顶点按照距 s 的距离排列，那么可以很快的解决 SSSP 问题。
    - 移除违反该顺序的边
    - 对于所有顶点 v，使用 DAG relaxation 计算 δ(s, v)</p>

<hr />

<p><strong>Dijkstra 算法：</strong></p>
<ul>
  <li>idea：按照离 s 的距离递增顺序，依次松弛边</li>
  <li>idea：利用数据结构，可以快速的找到顺序中的下一个顶点
    <ul>
      <li>changeable priority queue Q：存储的项带有 key 和独特的 id，可以删除最小 key 的项，也可以把某一个 id 项的 key 改变。</li>
      <li>通过 cross-linking 来实现，把字典 D 映射到 ID，ID 映射到优先队列中的项 Q’</li>
      <li>ID 可以是从 0 到 |V|-1 的整数，表示一个顶点</li>
    </ul>
  </li>
</ul>

<p>Dijkstra 算法的步骤：</p>
<ul>
  <li>对于所有的 v，设置 d(s, v) = ∞，设置 d(s, s) = 0</li>
  <li>创建 changeable priority queue Q，存储所有的 (v, d(s, v))，元组中分别为 id 和 key</li>
  <li>当 Q 不为空时，从 Q 中删除 d(s, u) 最小的项 (u, d(s, u))
    <ul>
      <li>对于 u 的出邻接点 v：</li>
      <li>如果 d(s, v) &gt; d(s, u) + w(u, v)，松弛边 (u, v)，即设置 d(s, v) = d(s, u) + w(u, v)。并且在 Q 中修改 v 的 key 为新的估计 d(s, v)</li>
    </ul>
  </li>
</ul>

<p><strong>例子：</strong></p>
<div align="center">
<img src="/image/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95-0012-1.png" width="500" />
<p></p>
</div>

<h3 id="2-证明">2. 证明</h3>

<p>Claim：Dijkstra 算法结束时，对于所有的 v，d(s, v) = δ(s, v)
Proof：</p>
<ul>
  <li>如果松弛时 d(s, v) 减少到了 δ(s, v)，那么在算法结束时 d(s, v) = δ(s, v)
    <ul>
      <li>松弛只能减少估计 d(s, v)</li>
      <li>松弛是安全的，例如维持 d(s, v) 是从 s 到 v 一条路径的权重</li>
    </ul>
  </li>
  <li>证明当顶点 v 从 Q 中移除时，d(s, v) = δ(s, v)
    <ul>
      <li>基本情况 (k=1)：s 是从 Q 移除的第一个顶点，d(s, s) = 0 = δ(s, s)</li>
      <li>归纳步骤：假设对于 k &lt; k’为真，考虑第 k’ 个顶点 v’ 从 Q 中移除的情况</li>
      <li>从 s 到 v’ 的最短路径表示为 π，用 (x, y) 表示 π 中 y 不在前 k’-1 个顶点的边。</li>
      <li>当 x 从 Q 中移除，根据假设 d(s, x) = δ(s, x)。所以 d(s, y) &lt;= δ(s, x) + w(x, y) = δ(s, y) &lt;= δ(s, v’) &lt;= d(s, v’) &lt;= d(s, y)</li>
      <li>所以 d(s, v’) = δ(s, v’)</li>
    </ul>
  </li>
</ul>

<p>运行时间：</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">O(|E| + |V|log|V|)</code></li>
</ul>]]></content><author><name>syh</name><email>songibicf@gmail.com</email></author><category term="算法" /><summary type="html"><![CDATA[1. Dijkstra 算法]]></summary></entry><entry><title type="html">Bellman-Ford 算法</title><link href="http://localhost:4000/%E7%AE%97%E6%B3%95/2022/10/07/%E7%AE%97%E6%B3%95-0011.html" rel="alternate" type="text/html" title="Bellman-Ford 算法" /><published>2022-10-07T00:00:00+08:00</published><updated>2022-10-07T00:00:00+08:00</updated><id>http://localhost:4000/%E7%AE%97%E6%B3%95/2022/10/07/%E7%AE%97%E6%B3%95-0011</id><content type="html" xml:base="http://localhost:4000/%E7%AE%97%E6%B3%95/2022/10/07/%E7%AE%97%E6%B3%95-0011.html"><![CDATA[<h3 id="1-negative-cycle-witness">1. Negative Cycle Witness</h3>

<p>练习：给定一个 SSSP 算法 A，其时间复杂度为 <code class="language-plaintext highlighter-rouge">O(|V|(|V| + |E|)</code>，如果在 <code class="language-plaintext highlighter-rouge">O(|V||E|)</code> 时间内解决 SSSP 问题。</p>

<p>Solution:</p>
<ul>
  <li>运行 BFS 或者 DFS，找到从 s 可以到达的顶点，时间复杂度为 <code class="language-plaintext highlighter-rouge">O(|E|)</code></li>
  <li>标记其余不可达的顶点 δ(s, v) = ∞，时间复杂度为 <code class="language-plaintext highlighter-rouge">O(|V|)</code></li>
  <li>创建 G’ = (V’, E’)，只包含可以从 s 到达的顶点，时间复杂度为 <code class="language-plaintext highlighter-rouge">O(|V|+ |E|)</code></li>
  <li>在 G’ 上运行 A。G’是连通图， 因此 <code class="language-plaintext highlighter-rouge">|V'| = O(|E'|) = O(|E|)</code>，A 的运行时间是 <code class="language-plaintext highlighter-rouge">O(|V||E|)</code></li>
</ul>

<p>Bellman-Ford 算法的目的：在任意权重的 general graph 上，实现 SSSP 算法的时间复杂度为 <code class="language-plaintext highlighter-rouge">O(|V||E|)</code></p>

<hr />

<p><strong>简单最短路径：</strong></p>
<ul>
  <li>如果图中包含环路和负权重，那么可能包含负权重环路 (negative-weight cycles)</li>
  <li>如果图中不包含 negative-weight cycles，最短路径是简单的</li>
</ul>

<p><strong>Claim 1：</strong>如果 δ(s, v) 是有限的，那么 s 到 v 的最短路径一定是简单路径</p>

<p><strong>证明：</strong>：</p>
<ul>
  <li>反证法，假设 s 到 v 的最短路径 π 不是简单路径</li>
  <li>π 不是简单路径，那么一定存在环路 C，C 是非负的权重。因为 C 如果是负权重环路， δ(s, v) 就是 −∞。</li>
  <li>从 π 中移除 C，得到更少权重的路径，与 π 是最短路径矛盾。</li>
</ul>

<p>由 claim 1 可以看到，有限长度的最短路径一定是简单路径，因此绝不可能包含环路，任意的最短路径最多包含 <code class="language-plaintext highlighter-rouge">|V| − 1</code> 条边。</p>

<hr />

<p><strong>Negative Cycle Witness</strong></p>
<ul>
  <li>k-边距离 δ<sub>k</sub>(s, v)：从 s 到 v 的使用边数小于等于 k 的任何路径的最小权重</li>
  <li>Idea：对于所有的顶点，计算 δ<sub>|V|−1</sub>(s, v) 和 δ<sub>|V|</sub>(s, v)
    <ul>
      <li>如果 δ(s, v) != -∞，δ(s, v) = δ<sub>|V|−1</sub>(s, v)，因为最短路径是简单路径</li>
      <li>如果 δ<sub>|V|</sub>(s, v) &lt; δ<sub>|V|−1</sub>(s, v)，那么存在更短的非简单路径，所以 δ<sub>|V|</sub>(s, v) = -∞，并且把 v 叫做 negative cycle witness</li>
      <li>但是，负环路上的顶点不全是 witness</li>
    </ul>
  </li>
</ul>

<p>Claim 2: 如果 δ(s, v) = −∞，那么 v 可以从一个 witness 抵达</p>

<p>证明：可以从 s 到达的每个负权环路上都包含一个见证</p>

<h3 id="2-bellman-ford">2. Bellman-Ford</h3>

<ul>
  <li>Idea: 使用图重复，对图复制多份</li>
  <li>新图有|V| + 1 层: 在 k 层的顶点 v<sub>k</sub> 表示从 v 到 s 使用 &lt;= k 条边</li>
  <li>如果边仅仅在层与层之间连接，那么，得到的为 DAG</li>
</ul>

<p>步骤：</p>
<ul>
  <li>创建一个新 DAG G’ = (V’, E’)
    <ul>
      <li>G’ 有 <code class="language-plaintext highlighter-rouge">|V|(|V| + 1)</code> 个顶点 v<sub>k</sub>, k ∈ {0, . . . ,|V|}</li>
      <li>G’ 有 <code class="language-plaintext highlighter-rouge">|V|(|V| + |E|)</code> 条边，|V|条边 (vk-1, vk), 且权重为 0。|V|条边 (uk-1, vk)，且权重为 w(u, v)。</li>
      <li>相当于创建 |V| + 1 层图。顶点数很好计算。但是边连接的顶点要变一下，G’ 中有两种类型的边，一种是连接相邻两层、相同顶点的边，由于在顶点内部移动不产生权重，因此边权重为 0；另一种是原图中就有的边，现在连接相邻两层中与原图相对应的顶点，权重还是原图中的权重。</li>
    </ul>
  </li>
  <li>在 G’ 上以 s<sub>0</sub> 为起点运行 DAG Relaxation</li>
  <li>对于每个顶点，设置 d(s, v) = δ(s<sub>0</sub>, v<sub>|V| - 1</sub>)</li>
  <li>接下来处理环路，对于每个 witness u，其  δ(s<sub>0</sub>, u<sub>|V|</sub>) &lt; δ(s<sub>0</sub>, u<sub>|V|−1</sub>):
    <ul>
      <li>对于图 G 中可以从 u 抵达的顶点 v，设置 d(s, v) = -∞</li>
    </ul>
  </li>
</ul>

<p>例子：</p>

<div align="center">
<img src="/image/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95-0011-1.png" width="500" />
<p></p>
</div>

<p>正确性证明：</p>
<ul>
  <li>Claim 3：对于所有的 v，且 k ∈ {0, . . . ,|V|}，δ(s0, vk) = δ<sub>k</sub>(s, v)</li>
  <li>Claim 4：当 Bellman-Ford 算法结束时，d(s, v) = δ(s, v)</li>
</ul>

<p>运行时间：<code class="language-plaintext highlighter-rouge">O(|V||E|)</code></p>]]></content><author><name>syh</name><email>songibicf@gmail.com</email></author><category term="算法" /><summary type="html"><![CDATA[1. Negative Cycle Witness]]></summary></entry><entry><title type="html">加权最短路径</title><link href="http://localhost:4000/%E7%AE%97%E6%B3%95/2022/10/03/%E7%AE%97%E6%B3%95-0010.html" rel="alternate" type="text/html" title="加权最短路径" /><published>2022-10-03T00:00:00+08:00</published><updated>2022-10-03T00:00:00+08:00</updated><id>http://localhost:4000/%E7%AE%97%E6%B3%95/2022/10/03/%E7%AE%97%E6%B3%95-0010</id><content type="html" xml:base="http://localhost:4000/%E7%AE%97%E6%B3%95/2022/10/03/%E7%AE%97%E6%B3%95-0010.html"><![CDATA[<h3 id="1-加权图">1. 加权图</h3>

<p>review:</p>
<ul>
  <li>单源最短路径：BFS， O(|V| + |E|)</li>
  <li>单源可达性：BFS 或者 DFS，O(|E|) (因为只返回可以到达的顶点)</li>
  <li>连通性：Full-BFS 或者 Full-DFS, O(|V| + |E|)</li>
  <li>拓扑排序：Full-DFS, O(|V| + |E|)</li>
</ul>

<p>之前最短路径按照 distance = number of edges in path 来算，现在考虑加权图中的最短路径。</p>

<p>加权图：</p>
<ul>
  <li>带有权重函数 w 的图，例如给图中的每条边 e = (u, v) 分配一个整数权重 w(e) = w(u, v)</li>
  <li>加权图的应用：
    <ul>
      <li>道路交通中的距离</li>
      <li>网络连接中的延迟</li>
      <li>社交网络中的关系好坏程度</li>
    </ul>
  </li>
  <li>表示权重的两种方式：
    <ul>
      <li>直接在邻接表中存储权重</li>
      <li>或者存储一个 set 数据结构，把边映射到权重</li>
    </ul>
  </li>
</ul>

<p>加权路径：</p>
<ul>
  <li>一条路径的权重 w(π) 是路径中所有边的权重之和</li>
  <li>在加权图中，从 s 到 t 的加权最短路径是权重最小的路径</li>
</ul>

<p>加权最短路径算法：</p>

<div align="center">
<img src="/image/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95-0010-1.png" width="600" />
<p></p>
</div>

<h3 id="2-计算最短路径树">2. 计算最短路径树</h3>
<ul>
  <li>对于 BFS，在搜索时一直记录 parent。但是，也可以从每个顶点的最短距离计算出来。</li>
  <li>如果知道所有顶点 v 的 δ(s, v)， 可以用 <code class="language-plaintext highlighter-rouge">O(|V|+|E|)</code> 的时间创建出最短路径树</li>
</ul>

<p>使用 δ(s, v) 计算最短路径树，步骤如下：</p>
<ul>
  <li>初始化 P，设置 P(s) = None</li>
  <li>对于每个顶点 u，δ(s, u) 是有限的：
    <ul>
      <li>对于 u 的 outgoing neighbor v:</li>
      <li>如果 P(v) 没有被分配，并且 δ(s, v) = δ(s, u) + w(u, v)</li>
      <li>那么在 (u, v) 之间存在最短路径，设置 P(v) = u</li>
    </ul>
  </li>
  <li>父指针可能会遍历零权重的环路，标记在环中的所有顶点</li>
  <li>对于所有未标记的顶点 u
    <ul>
      <li>对于 u 的邻接点 v，且 v 已经被标记，并且 δ(s, v) = δ(s, u) + w(u, v)</li>
      <li>从 v 开始遍历父指针，取消标记该环中的顶点</li>
      <li>设置 P(v) = u, 打破环</li>
    </ul>
  </li>
</ul>

<p>该算法可以在线性时间内计算出最短路径树结点中的父指针。</p>

<h3 id="3-dag-relaxation">3. DAG Relaxation</h3>

<p>relaxation: 对于一个优化问题，要得到最优解， 可以从一个非最优解开始然后逐渐迭代来改进解，直到达到问题的最优解。</p>

<ul>
  <li>记录距离估计 d(s, v)，初始化为无穷大。该距离估计一定是真实距离 δ(s, v) 的上界，接下来需要逐步减少距离，直到 d(s, v) = δ(s, v)</li>
  <li>
    <p>什么时候降低 d(s, v)？在边违反<strong>三角不等式</strong>的时候</p>
  </li>
  <li>三角不等式：从 u 到 v 的最短路径权重不能大于从 u 经另一个顶点 x 到 v 的最短路径权重，即 δ(u, v) ≤ δ(u, x)+ δ(x, v) for all u, v, x ∈ V</li>
  <li>如果 d(s, v) &gt; d(s, u) + w(u, v)，违反了三角不等式</li>
  <li>fix 方法：降低 d(s, v) 为 d(s, u) + w(u, v)。</li>
</ul>

<p>可以证明最短路径估计 d(s, v) 永远不会小于真实的最短路径权重 δ(s, v)</p>
<ul>
  <li>Safety Lemma: 在 relax 过程中，d(s, v) 会一直大于等于 δ(s, v)</li>
  <li>证明：证明更强的声明，对于所有的 v，d(s, v) 在迭代时要么是无穷大，要么是 s 到 v 的<strong>某一条路径</strong>的权重，即 d(s, v) 会一直大于等于 δ(s, v)。
    <ul>
      <li>在初始的时候正确，d(s, v) 为无穷大</li>
      <li>假设在某一时刻声明为正确，relax 边 (u, v)。relax 边会让 d(s, v) 减少到 d(s, u) + w(u, v)，即 d(s, v) 变为从 s 出发，经过 u 到 v 路径的权重。</li>
    </ul>
  </li>
</ul>

<p>在 DAG 中，不存在环路，relaxation 最后一定会结束。按照拓扑顺序依次松弛出边，可以正确的计算出最短路径。该算法叫做 DAG Relaxation。</p>

<p>步骤：</p>
<ul>
  <li>设置 d(s, v) = ∞, d(s, s) = 0</li>
  <li>对于图 G 中的所有顶点，按照拓扑顺序处理每一个顶点 u
    <ul>
      <li>对于 u 的 outgoing neighbor v ∈ Adj<sup>+</sup>(u)</li>
      <li>如果 d(s, v) &gt; d(s, u) + w(u, v)</li>
      <li>设置 d(s, v) = d(s, u) + w(u, v)</li>
    </ul>
  </li>
</ul>

<p>运行时间：</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">O(|V| + |E|)</code></li>
</ul>]]></content><author><name>syh</name><email>songibicf@gmail.com</email></author><category term="算法" /><summary type="html"><![CDATA[1. 加权图]]></summary></entry><entry><title type="html">DFS</title><link href="http://localhost:4000/%E7%AE%97%E6%B3%95/2022/10/01/%E7%AE%97%E6%B3%95-0009.html" rel="alternate" type="text/html" title="DFS" /><published>2022-10-01T00:00:00+08:00</published><updated>2022-10-01T00:00:00+08:00</updated><id>http://localhost:4000/%E7%AE%97%E6%B3%95/2022/10/01/%E7%AE%97%E6%B3%95-0009</id><content type="html" xml:base="http://localhost:4000/%E7%AE%97%E6%B3%95/2022/10/01/%E7%AE%97%E6%B3%95-0009.html"><![CDATA[<h3 id="1-dfs">1. DFS</h3>

<p>BFS 用来解决单源最短路径问题，得到从一个顶点到其余所有顶点的最短路径，运行时间为 <code class="language-plaintext highlighter-rouge">O(|V| + |E|)</code></p>

<p>DFS:</p>
<ul>
  <li>解决单源可达性问题，而不是最短路径问题</li>
  <li>
    <p>return (not necessarily shortest) parent tree of parent pointers back to s</p>
  </li>
  <li>Idea: vist outgoing adjacencies recursively, but never revisit a vertex</li>
  <li>
    <p>i.e., 沿着一条路径前进，直到无法再前进，接着回溯，直到找到一条未探索过的路径。对于可以从 s 到达的任何顶点 v，DFS 都会访问 v 并正确设置 P(v)。一次 DFS 后，在图中未访问过的顶点上依次调用 DFS，即可遍历图中所有顶点。</p>
  </li>
  <li>P(s) = None, 接着 visit(s)</li>
  <li>visit(u):
    <ul>
      <li>对于 u 的所有未出现在 P 中的邻接点，设置 P(v) = u，递归调用 visit(v)</li>
    </ul>
  </li>
  <li>如果还有未访问到的顶点，在该顶点上再次调用 DFS</li>
</ul>

<p>运行时间 <code class="language-plaintext highlighter-rouge">O(|V| + |E|) </code></p>

<h3 id="2-拓扑排序">2. 拓扑排序</h3>

<ul>
  <li>DAG 图：有向无环图</li>
  <li>拓扑顺序：对顶点分配顺序 f，使得对于每条边 (u, v) ∈ E 满足 f(u) &lt; f(v)。</li>
  <li>DAG 图可以得到顶点的拓扑排序</li>
</ul>

<p>步骤：</p>
<ul>
  <li>Finishing Order 是 DFS <strong>完成访问顶点</strong>的顺序，即 visit(u) 结束的顺序</li>
  <li>Claim: 对于图 G，如果 G 是 DAG 图，finishing order 的翻转序列是拓扑排序</li>
  <li>Proof: 需要证明对于每条边 (u, v) ∈ E，u 排在 v 前面，DFS 先访问完 v。分成两种情况：
    <ul>
      <li>如果 u 在 v 前面访问：在访问 u 结束前，会访问 v，因此访问 v 先结束</li>
      <li>如果在 v 在 u 前面访问，由于图是无环图，从 v 不能到达 u，因此v 在 u 前面结束访问</li>
    </ul>
  </li>
</ul>

<h3 id="3-cycle-detection">3. Cycle Detection</h3>

<ul>
  <li>如果图 G 是无环的，DFS 可以找到拓扑顺序</li>
  <li>如果反向 finishing order 不是拓扑排序，那么图中一定存在环</li>
</ul>]]></content><author><name>syh</name><email>songibicf@gmail.com</email></author><category term="算法" /><summary type="html"><![CDATA[1. DFS]]></summary></entry><entry><title type="html">Binary Heaps</title><link href="http://localhost:4000/%E7%AE%97%E6%B3%95/2022/09/28/%E7%AE%97%E6%B3%95-0007.html" rel="alternate" type="text/html" title="Binary Heaps" /><published>2022-09-28T00:00:00+08:00</published><updated>2022-09-28T00:00:00+08:00</updated><id>http://localhost:4000/%E7%AE%97%E6%B3%95/2022/09/28/%E7%AE%97%E6%B3%95-0007</id><content type="html" xml:base="http://localhost:4000/%E7%AE%97%E6%B3%95/2022/09/28/%E7%AE%97%E6%B3%95-0007.html"><![CDATA[<h3 id="1-优先队列接口">1. 优先队列接口</h3>

<ul>
  <li>存储多个项，可以快速的访问、移除最重要的项，实际例子有：
    <ul>
      <li>有限带宽的路由器必须优先处理重要的信息</li>
      <li>操作系统内核中的进程调度</li>
      <li>离散事件模拟</li>
      <li>图算法</li>
    </ul>
  </li>
  <li>优先队列是按照优先级对项进行了排序，所以也可以看作 Set 接口</li>
  <li>对于特定集合操作进行了优化：
    <ul>
      <li>build(X)</li>
      <li>insert(x)</li>
      <li>delete_max()</li>
      <li>find_max()</li>
    </ul>
  </li>
  <li>关注 insert 和 delete_max 操作</li>
  <li>优先队列有多种实现方法，例如 array， sorted array， set AVL tree。</li>
</ul>

<h3 id="2-优先队列排序">2. 优先队列排序</h3>

<ul>
  <li>在任何的优先队列中，都可以按以下方法对 A 进行排序
    <ul>
      <li>build(A)，例如依次 insert 每一项</li>
      <li>然后重复 delete_max()</li>
    </ul>
  </li>
  <li>时间复杂度：T<sub>build</sub> + n * T<sub>delete_max</sub> = n * T<sub>insert</sub> + n * T<sub>delete_max</sub></li>
  <li>在以下的优先队列实现中，应用优先队列排序的时间复杂度如下图。并且在特定实现中，优先队列排序和一些排序算法很相似。</li>
</ul>

<div align="center">
<img src="/image/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95-0007-1.png" width="600" />
<p></p>
</div>

<h4 id="21-优先队列set-avl-tree">2.1 优先队列：Set AVL Tree</h4>

<ul>
  <li>Set AVL 树支持 insert(x), find_min(), find_max(), delete_min() 和 delete_max() 操作，并且时间复杂度全部为 O(logn)</li>
  <li>按照优先队列排序，时间复杂度为 O(nlogn)</li>
  <li>但是这个数据结构复杂，并且排序不是原位的</li>
</ul>

<h4 id="22-优先队列array">2.2 优先队列：Array</h4>

<ul>
  <li>在动态数组中以无序的方式存储元素</li>
  <li>insert(x)：O(1)</li>
  <li>delete_max(): 找到最大值，交换到末尾，并且移除</li>
  <li>insert 很快，但是 delete_max() 慢</li>
  <li>在 array 实现中进行优先队列排序，基本上和选择排序一样</li>
</ul>

<h4 id="23-优先队列sorted-array">2.3 优先队列：Sorted Array</h4>

<ul>
  <li>在有序的动态数组中存储元素</li>
  <li>insert(x)：把 x 放入末尾，并将 x 交换到合适的位置</li>
  <li>delete_max(x)：直接从末尾删除</li>
  <li>delete_max 快，但是 insert 慢</li>
  <li>在 sorted array 上进行优先队列排序，基本上就是插入排序</li>
</ul>

<h3 id="3-heap">3. heap</h3>

<p>那么，可以在以上的优先队列实现中找到一个平衡吗？既保持排序算法的<strong>低时间复杂度</strong>，又是<strong>原位排序</strong>算法。</p>

<p>idea：<strong>把数组看作一个完全二叉树</strong>，除了最后一层，完全二叉树在深度为 i 的层上都有 2^i 个结点。在最后一层上所有的结点都是左对齐的。</p>

<p>完全二叉树填充数组时，是按照<strong>层次遍历</strong>的顺序放入，从根到叶子结点，一层一层从左往右依次放入。这样，完全二叉树和数组建立了对应关系，完全二叉树不是由指针来确定结点关系，而是由数组中的位置来确定结点关系。</p>

<p>根结点在索引 0 处。结点 i 的左孩子在索引 2i+1 处，右孩子在索引 2i+2 处，父结点在 math.floor((i-1)/2) 处。</p>

<h4 id="31-binary-heaps">3.1 Binary Heaps</h4>

<p>idea：元素越大，在树中放置的高度越高。</p>

<p>最大堆属性：在结点 i 处，Q[i] &gt;= Q[j] for j ∈ {left(i), right(i)}</p>

<p><strong>最大堆</strong>：在所有结点上都满足最大堆属性的<strong>数组</strong></p>

<p>在最大堆中，可以证明对于结点 i，Q[i] &gt;= Q[j]，j 可以是子树中任一结点。</p>

<h4 id="32-heap-insert">3.2 Heap Insert</h4>

<ul>
  <li>把要插入的元素 x 放入数组的末尾，相当于插入到树的叶子结点中</li>
  <li>max_heapify_up(i): 为了维持最大堆属性，依次与父结点交换
    <ul>
      <li>检查是否 Q[parent(i)] &gt;= Q[i]</li>
      <li>如果不是，交换结点，递归执行 max_heapify_up(parent(i))</li>
    </ul>
  </li>
  <li>运行时间：树的高度 O(logn)</li>
</ul>

<h4 id="33-heap-delete-max">3.3 Heap Delete Max</h4>

<ul>
  <li>在数组中只能容易的移除最后的元素，但是最大项却在索引 0 的位置</li>
  <li>所以，把索引 0 的项和最后一项进行交换，并删除交换后的最后一项</li>
  <li>然后执行 max_heapify_down(i)：从上往下维持最大堆属性
    <ul>
      <li>检查是否 Q[i] &gt;= Q[j] for j ∈ {left(i), right(i)}</li>
      <li>如果不是，把 Q[i] 和 最大的孩子结点交换，并递归执行 max_heapify_down</li>
    </ul>
  </li>
  <li>运行时间：树的高度 O(logn)</li>
</ul>

<h4 id="34-heap-sort">3.4 Heap Sort</h4>

<p>堆排序时间复杂度为 O(nlogn)</p>

<p>线性时间内建堆：</p>
<ul>
  <li>假如是依次插入 n 个元素到堆中，那么得调用 max_heapify_up(i) n 次，每次都得经过整个树高，时间复杂度为 Ω(n lg n)</li>
  <li>idea: 把数组看作完全二叉树，从 n-1 到 0 依次调用 max_heapify_down(i)，调用时只用确保子树，时间复杂度为 O(n)</li>
</ul>]]></content><author><name>syh</name><email>songibicf@gmail.com</email></author><category term="算法" /><summary type="html"><![CDATA[1. 优先队列接口]]></summary></entry><entry><title type="html">BFS</title><link href="http://localhost:4000/%E7%AE%97%E6%B3%95/2022/09/28/%E7%AE%97%E6%B3%95-0008.html" rel="alternate" type="text/html" title="BFS" /><published>2022-09-28T00:00:00+08:00</published><updated>2022-09-28T00:00:00+08:00</updated><id>http://localhost:4000/%E7%AE%97%E6%B3%95/2022/09/28/%E7%AE%97%E6%B3%95-0008</id><content type="html" xml:base="http://localhost:4000/%E7%AE%97%E6%B3%95/2022/09/28/%E7%AE%97%E6%B3%95-0008.html"><![CDATA[<h3 id="1-graph">1. Graph</h3>

<p>图的应用例子：</p>
<ul>
  <li>任何网络系统，例如道路交通、计算机网络、社交网络</li>
  <li>任何离散系统的状态空间可以表示为图，例如 Chess、Teris、Rubik’s cube</li>
</ul>

<p><strong>图定义：</strong></p>
<ul>
  <li>G = (V, E)</li>
  <li>有向边由有序对表示，例如 (u, v)，无向边由无序对表示，例如 {u, v}</li>
  <li>简单图：
    <ul>
      <li>edges are distinct</li>
      <li>边连接不同的顶点</li>
      <li>|E| = O(|V|^2)</li>
    </ul>
  </li>
  <li>出边集：Adj<sup>+</sup>(u) = {v ∈ V | (u, v) ∈ E}</li>
  <li>入边集: Adj<sup>-</sup>(u) = {v ∈ V | (v, u) ∈ E}</li>
  <li>出度: deg<sup>+</sup>(u) = |Adj<sup>+</sup>(u)|</li>
  <li>入度: deg<sup>-</sup>(u) = |Adj<sup>-</sup>(u)|</li>
  <li>对于无向图 Adj<sup>-</sup>(u) = Adj<sup>+</sup>(u)， deg<sup>-</sup>(u) = deg<sup>+</sup>(u)</li>
</ul>

<p><strong>图的表示：</strong></p>
<ul>
  <li>对于图 G = (V, E)，存储 u 的所有出边 Adj(u)。</li>
  <li>使用 Set 来存储所有的顶点，可以使用直接访问数组或哈希表，size 为 Θ(|V|)</li>
  <li>对于每个顶点，为了存储邻接的顶点，使用数组或者链表。每个顶点邻接列表 size 为 Θ(deg(u))</li>
  <li>图存储需要 Θ(|V| + |E|) 空间</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># 图的直接访问数组表示
A1 = [
      [1, 4, 3],
      [0],
      [3],
      [0, 2],
      [0]
    ]

# 图的哈希表表示
A1 = {
      0: {1, 3, 4},
      1: {0},
      2: {3},
      3: {0, 2},
      4: {0}
    }
</code></pre></div></div>

<p><strong>路径：</strong></p>
<ul>
  <li>路径：顶点序列 p = (v1, v2, . . . , vk)，(vi, vi+1) ∈ E</li>
  <li>简单路径：没有重复顶点，或者说没有环的路径</li>
  <li>路径的长度：路径中的边数</li>
  <li>u 和 v 之间的距离：从 u 到 v 的最短路径的长度</li>
</ul>

<p><strong>图路径问题：</strong></p>
<ul>
  <li>single_pair_reachability(G, s, t): 从 s 到 t 有路径吗</li>
  <li>single_pair_shortest_path(G, s, t): 找到 s 到 t 的最短路径</li>
  <li>single_source_shortest_paths(G, s): 返回 s 到其它所有顶点的最短路径树</li>
</ul>

<p><strong>Shortest Paths Tree：</strong></p>
<ul>
  <li>得到从 s 到其他所有顶点的最短路径</li>
  <li>用 P(v) 代表从 s 到 v 顶点最短路径上的 v 的上一个顶点</li>
</ul>

<h3 id="2-bfs">2. BFS</h3>
<p><strong>BFS：</strong></p>
<ul>
  <li>对于 v ∈ V，如何计算 δ(s, v) 和 P(v)</li>
  <li>在一个集合数据类型中存储 δ(s, v) 和 P(v)，把 v 映射到距离和 P(v)</li>
  <li><strong>Idea:</strong> 按距离递增的顺序探索图结点</li>
  <li>Goal：计算所有的 Level sets L<sub>i</sub> = {v | v ∈ V and d(s, v) = i}</li>
  <li>Claim: L<sub>i</sub> 中每个顶点 v 一定与 L<sub>i-1</sub> 中的某个顶点 u 邻接，v ∈ Adj(u)</li>
  <li><strong>Invariant:</strong> δ(s, v) and P(v) have been computed correctly for all v in any L<sub>j</sub> for j &lt; i。对于当前层的顶点，上一层的顶点已经全部得到了最短的路径。</li>
</ul>

<p>BFS 按照层次顺序得到顶点 L<sub>i</sub>，且 L<sub>i</sub> 中的顶点是最短路径为 i 可以到达的顶点。</p>

<p><strong>BFS 步骤：</strong></p>
<ul>
  <li>base case (i=1): L0 = {s}, δ(s, s) = 0, P(s) = None</li>
  <li>Inductive Step: 为了计算 L<sub>i</sub>:
    <ul>
      <li>对于 L<sub>i-1</sub> 中每个顶点 u
        <ul>
          <li>对于每个顶点 v ∈ Adj(u)，并且 v 不出现在之前的层中，把 v 添加到 L<sub>i</sub>，设置 δ(s, v) = i，P(v) = u</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>重复计算 L<sub>i</sub>，直到 L<sub>i</sub> 不能再添加顶点</li>
  <li>对于剩余的顶点，设置 δ(s, v) = ∞</li>
</ul>

<p>BFS 的运行时间为 O(|V| + |E|)</p>]]></content><author><name>syh</name><email>songibicf@gmail.com</email></author><category term="算法" /><summary type="html"><![CDATA[1. Graph]]></summary></entry><entry><title type="html">测试</title><link href="http://localhost:4000/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0/2022/09/26/%E8%BD%AF%E4%BB%B6-0004.html" rel="alternate" type="text/html" title="测试" /><published>2022-09-26T00:00:00+08:00</published><updated>2022-09-26T00:00:00+08:00</updated><id>http://localhost:4000/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0/2022/09/26/%E8%BD%AF%E4%BB%B6-0004</id><content type="html" xml:base="http://localhost:4000/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0/2022/09/26/%E8%BD%AF%E4%BB%B6-0004.html"><![CDATA[<h3 id="1-validation">1. Validation</h3>

<p>测试是 Validation 的重要一步。验证的目的是发现程序中存在的问题。Validation 包括：</p>
<ul>
  <li>形式推理 (Formal reasoning)：通过推导，证明程序的正确性。</li>
  <li>代码审查 (Code review)：让其他人仔细阅读你的代码。</li>
  <li>测试 (Testing)：在精心选择的输入上验证程序的输出。</li>
</ul>

<p>即使进行了最好的验证，在软件上也很难实现最好的质量。典型的 residual defect rates:</p>
<ul>
  <li>1 - 10 defects/kloc: 典型的工业软件</li>
  <li>0.1 - 1 defects/kloc: 高质量验证的软件，例如成熟浏览器的 JavaScript 库</li>
  <li>0.01 - 0.1 defects/kloc: 最好的、安全关键的验证。例如航空领域软件</li>
</ul>

<p>软件测试中的有些方法是不可行的：</p>
<ul>
  <li>详尽测试</li>
  <li>Haphazard testing</li>
  <li>随机或者统计测试</li>
</ul>

<h3 id="2-test-first-编程">2. Test-first 编程</h3>

<ul>
  <li>module：软件系统的一部分，可以被设计、实现、测试、推理，并且该部分与系统的其他部分独立。该节主要关注的模块为函数，之后会关注 class</li>
  <li>specification：描述模块的行为。</li>
  <li>一个模块通过实现 (implementation) 来提供功能，并且 clients 可以使用该模块。</li>
  <li>test case：测试用例，特定选择的输入，同时在 specification 中包含期望输出。</li>
  <li>test suite：一个模块的测试用例的集合</li>
</ul>

<p>test-first programming: 在写代码前先写 spec 和 tests。例如写函数的步骤如下：</p>
<ol>
  <li>Spec：为函数写一个 specification</li>
  <li>Test：写与 specification 对应的测试</li>
  <li>Implement：具体实现</li>
</ol>

<h3 id="3-系统测试">3. 系统测试</h3>

<p>系统测试：按照特定的方式选择测试例子，按以下三个属性设计 test suite：</p>
<ul>
  <li>Correct：correct test suite 是 specification 合法的 client，接受所有合法的实现。</li>
  <li>Thorough：一个彻底的 test suite 可以发现实现中实际的 bug</li>
  <li>Small：test suite 要尽可能的小</li>
</ul>

<h3 id="4-通过划分来选择测试用例">4. 通过划分来选择测试用例</h3>]]></content><author><name>syh</name><email>songibicf@gmail.com</email></author><category term="软件构造" /><summary type="html"><![CDATA[1. Validation]]></summary></entry><entry><title type="html">TypeScript 基础</title><link href="http://localhost:4000/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0/2022/09/23/%E8%BD%AF%E4%BB%B6-0003.html" rel="alternate" type="text/html" title="TypeScript 基础" /><published>2022-09-23T00:00:00+08:00</published><updated>2022-09-23T00:00:00+08:00</updated><id>http://localhost:4000/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0/2022/09/23/%E8%BD%AF%E4%BB%B6-0003</id><content type="html" xml:base="http://localhost:4000/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0/2022/09/23/%E8%BD%AF%E4%BB%B6-0003.html"><![CDATA[<h3 id="1-snapshot-图">1. Snapshot 图</h3>
<p>snapshot 图：表示程序运行时的内部状态，包括 stack (运行中的方法和局部变量) 和 heap (当前存在的对象)。</p>

<p>改变一个变量或字段：改变了变量的箭头指向
改变一个可修改对象的内容：改变值内部的引用</p>

<p>string 是不可修改的类型，当创建之后，<strong>值</strong>不能被改变。可修改对象则是可以改变对象的值。</p>

<p><strong>不可重新分配的引用</strong>：变量只能赋值一次，并且永远不能被重新赋值，用 const 来声明。</p>

<p>不可重新分配的引用可以指向可修改的值，例如</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const arr:Array&lt;string&gt; = ["a"];
arr.push("b")
</code></pre></div></div>

<p>可重新分配的引用可以指向不可修改的值，此时变量的值可以改变。例如：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let s:string = "a";
s = "ab";
</code></pre></div></div>

<p>函数调用中参数传递为值传递，即参数接受一个初始值，在函数内部参数可以任意的重新分配，不会影响到 caller。大多数的编程语言都是值传递，例如 Python, Java, C。少数语言，如 C++，C# 提供引用传递。</p>

<h3 id="2-typescript-基础">2. TypeScript 基础</h3>

<p>TypeScript 中的 Array 与 Python 中的 list 类似。</p>

<table>
  <tbody>
    <tr>
      <td>TypeScript</td>
      <td>Python</td>
    </tr>
    <tr>
      <td>lst.length</td>
      <td>len(lst)</td>
    </tr>
    <tr>
      <td>lst.push(e)</td>
      <td>lst.append(e)</td>
    </tr>
    <tr>
      <td>if (lst.length === 0)</td>
      <td>if not list: …</td>
    </tr>
    <tr>
      <td>lst.includes(e)</td>
      <td>e in lst</td>
    </tr>
    <tr>
      <td>lst.splice(i, 1)</td>
      <td>del lst[i]</td>
    </tr>
  </tbody>
</table>

<p>Map 与 Python 中字典相似。在 Python 中，键必须是可哈希的。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Python 中的可哈希：一个对象的哈希值如果在其生命周期内绝不改变，并可以同其他对象进行比较 (具有 __eq__ 方法)，就被称为可哈希的 (它需要具有 __hash__ 方法)。

可哈希行使得对象能够作为字典键或集合成员使用，这些数据结构在内部使用哈希值。
</code></pre></div></div>

<table>
  <tbody>
    <tr>
      <td>TypeScript</td>
      <td>Python</td>
    </tr>
    <tr>
      <td>map.set(key, val)</td>
      <td>map[key] = val</td>
    </tr>
    <tr>
      <td>map.get(key)</td>
      <td>map[key]</td>
    </tr>
    <tr>
      <td>map.has(key)</td>
      <td>key in map</td>
    </tr>
    <tr>
      <td>map.delete(key)</td>
      <td>del map[key]</td>
    </tr>
    <tr>
      <td>map.size</td>
      <td>len(map)</td>
    </tr>
  </tbody>
</table>

<p>Set 类型
| TypeScript | Python |
| s.has(e) | e in s|
| s.add(e) | s.add(e) |
| s.delete(e) | s.remove(e) |
| s.size | len(s) |</p>

<h4 id="21-generics">2.1 Generics</h4>
<p>不像 Python 中的容器类型。 TypeScript 中的容器可以严格限定容器中对象的类型。当向容器中添加项时，TypeScript 会对项进行静态检查。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># 容器例子
let cities: Array&lt;string&gt;;
let cities: string[]
let number: Set&lt;number&gt;;
let turtles: Map&lt;string, Turtle&gt;
</code></pre></div></div>

<h4 id="22-iteration">2.2 Iteration</h4>

<p>Python 中：</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for city in cities:
    print(city)

for num in numbers:
    print(num)

for key in turtles:
    print("%s: %s" %(key, turtles[key]))
</code></pre></div></div>

<p>TypeScript:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for (const city of cities) {
    console.log(city);
}

for (const num of numbers) {
    console.log(num);
}

for (const key of turtles.keys()) {
    console.log(key + ":" + turtles.get(key));
}
</code></pre></div></div>

<p>在 array 和 map 中使用 <code class="language-plaintext highlighter-rouge">get()</code> 去访问一个 key，如果 key 不存在，会返回特殊的值 <code class="language-plaintext highlighter-rouge">undefined</code></p>

<p>JavaScript 中数组实际上是 sparse 的，可以在任意的索引位置放置一个新元素。</p>

<h4 id="23-变量声明">2.3 变量声明</h4>

<p>JavaScript 中可以使用 let、const、var 来声明一个变量。let 声明的变量可重新赋值，const 声明的为不可重新分配的变量。var 为旧的风格，因为声明变量的 scope 为整个 functions，而 let 声明的变量 scope 为闭合花括号内。</p>

<h4 id="24-对象字面量和对象类型">2.4 对象字面量和对象类型</h4>

<p>record type: 一个对象，只有 named fields，没有方法。在 C/C++ 里面叫做 struct。</p>

<p>TypeScript 可以使用 {field1:value1, field2:value2, …}，快速创建具有特定值的 record type 对象。</p>

<p>解构赋值：通过解构赋值，可以将属性/值从对象/数组中取出，赋值给其他变量。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let a, b, rest;
[a, b] = [10, 20]

[a, b, ...rest] = [10, 20, 30, 40, 50];

({a, b} = {a:10, b:20});
</code></pre></div></div>

<h3 id="3-api-文档与工具">3. API 文档与工具</h3>

<ul>
  <li>MDN： JavaScript 的通用功能，包含浏览器指定的 API</li>
  <li>Node.js: outside-the-browser API</li>
  <li>TypeScript Handbook：与 TypeScript 有关的 API</li>
</ul>

<p>MDN 文档的结构：</p>

<ol>
  <li>Description
    <ul>
      <li>类的简短描述</li>
    </ul>
  </li>
  <li>Constructor</li>
  <li>Instance properties</li>
  <li>Instance methods
    <ul>
      <li>method signature</li>
      <li>full description</li>
      <li>parameters</li>
      <li>returns</li>
    </ul>
  </li>
</ol>

<p>Node.js：JavaScript 的解释器
npm：”Node Package Manager”，有两个功能。首先，它管理用于程序的外部包库。其次，npm 是其他编程工具的通用运行环境。</p>

<p>使用 TypeScript prompt:</p>
<ol>
  <li>npm install ts-node</li>
  <li>npx ts-node</li>
</ol>]]></content><author><name>syh</name><email>songibicf@gmail.com</email></author><category term="软件构造" /><summary type="html"><![CDATA[1. Snapshot 图 snapshot 图：表示程序运行时的内部状态，包括 stack (运行中的方法和局部变量) 和 heap (当前存在的对象)。]]></summary></entry><entry><title type="html">二叉树 II</title><link href="http://localhost:4000/%E7%AE%97%E6%B3%95/2022/09/21/%E7%AE%97%E6%B3%95-0006.html" rel="alternate" type="text/html" title="二叉树 II" /><published>2022-09-21T00:00:00+08:00</published><updated>2022-09-21T00:00:00+08:00</updated><id>http://localhost:4000/%E7%AE%97%E6%B3%95/2022/09/21/%E7%AE%97%E6%B3%95-0006</id><content type="html" xml:base="http://localhost:4000/%E7%AE%97%E6%B3%95/2022/09/21/%E7%AE%97%E6%B3%95-0006.html"><![CDATA[<h3 id="1-平衡二叉树">1. 平衡二叉树</h3>

<p>之前提到二叉树目的是对于树高为 h 的树，使得算法的时间复杂度为 O(h), 并且尽可能维持 h = O(logn)，最终 O(h)=O(logn)。那么，如何维持树的高度 h = O(logn) ?</p>

<p><strong>平衡二叉树</strong>：在动态操作时，例如 insert(x), delete(x), 可以维持高度为 O(logn) 的二叉树。有许多平衡的范式 (Red-Black Trees, Splay Trees, 2-3 Trees,…)。最早提出的平衡范式为 AVL 树 (Adelson-Velsky and Landis, 1962)。</p>

<p>树的旋转：</p>
<ul>
  <li>目的：降低树的高度，但是不改变遍历顺序</li>
  <li>旋转操作只是修改了指针，时间复杂度为 O(1)</li>
</ul>

<div align="center">
<img src="/image/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95-0006-1.png" width="500" />
<p></p>
</div>

<p>旋转的特性：O(n) 次旋转可以将二叉树转换为具有相同遍历顺序的任何其他二叉树。</p>

<h3 id="2-avl-树">2. AVL 树</h3>

<ul>
  <li>AVL 树保持了 height-balance
    <ul>
      <li>一个结点叫做 height-balance，如果左子树和右子树的高度最多差 1</li>
      <li>一个结点的偏斜 (skew) 为其右子树的高度减去左子树的高度</li>
      <li>如果 skew 为 -1， 0， 1， 那么该结点是 height-balance</li>
    </ul>
  </li>
  <li>所有结点为 height-balance 的二叉树，其高度 h = O(log n)
    <ul>
      <li>高度为 h 二叉树的结点树 F(h) = 1 + F(h-1) + F(h-2) &gt;= 2F(h-2)</li>
    </ul>
  </li>
  <li>假设增加或者删除叶子结点，导致原先 height-balance 的树不平衡
    <ul>
      <li>那么仅叶子结点的祖先结点在高度或者 skew 上有改变</li>
      <li>高度最多改变 ±1, 所以 skew 的绝对值还是  ≤ 2</li>
      <li>修复的 idea: 从叶子结点开始，一直到根结点，依次修复，使得叶子结点的所有祖先结点 height-balance</li>
    </ul>
  </li>
</ul>

<h4 id="21-avl-树的-rebalance">2.1 AVL 树的 Rebalance</h4>

<p><strong>Local Rebalance</strong>：给定一个二叉树结点 B</p>
<ul>
  <li>假设其 skew 为 2</li>
  <li>B 子树中其他结点为 height-balanced</li>
  <li>那么，B 子树通过一次或者两次旋转操作可以变平衡</li>
</ul>

<hr />

<p><strong>证明</strong>：
因为 B 的 skew 为 2，那么 B 的右孩子结点一定存在，记为 F。</p>

<p><strong>Case 1</strong>: F 的 skew 为 0。</p>

<p><strong>Case 2</strong>: F 的 skew 为 1。</p>

<p>对于这两种情况，都是对 B 执行左旋操作。</p>

<div align="center">
<img src="/image/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95-0006-2.png" width="500" />
<p></p>
</div>

<p>假设 h = height(A), 那么原始状态下 height(G) = h+1, 情况 1 中 height(D) = h+1, 情况 2 中 height(D) = h。
旋转后，B 的 skew 在情况 1 为 1，情况 2 为 0，所以 B 是 height-balanced。旋转后，F 的 skew 为 -1，F height-balanced。</p>

<p><strong>Case 3</strong>：
F 的 skew 为 -1，那么得先对 F 执行右旋，再左旋。证明和上面类似。</p>

<div align="center">
<img src="/image/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95-0006-3.png" width="500" />
<p></p>
</div>

<hr />

<p><strong>Global Rebalance</strong>：对于 height-balanced 树 T，增加或者移除一个叶子结点，得到 T’。之后可以通过最多 O(logn) 次旋转，重新得到平衡二叉树 T’‘。</p>

<p><strong>证明</strong>：</p>
<ul>
  <li>仅叶子结点的祖先，高度受到了影响。且最多有 O(logn) 个祖先。</li>
  <li>把最低的受到影响的祖先记为 X</li>
  <li>如果 T 中是增加了一个叶子结点：
    <ul>
      <li>插入操作增加了 X 的高度，可以对 X 进行 local rebalance 操作</li>
      <li>在旋转后保持了平衡</li>
    </ul>
  </li>
  <li>如果 T 中移除了一个叶子结点
    <ul>
      <li>删除可能减少了 X 的一个孩子结点的高度，但是 X 的高度未受影响</li>
      <li>删除也可能导致 X 的高度减少 1，X 的父结点也可能不平衡</li>
      <li>所以得重新平衡 X 的祖先，但是最多 O(logn) 次</li>
    </ul>
  </li>
  <li>因此，O(logn) 次旋转操作可以变回平衡二叉树</li>
</ul>

<h3 id="3-计算高度">3. 计算高度</h3>

<p>如果判断结点 X 是否 height-balanced? 这需要知道子树的高度，因此要计算子树的高度。</p>

<p>方法：subtree augmentation</p>
<ul>
  <li>在结点处附加上<strong>子树高度</strong>的属性</li>
  <li>
    <p>X 结点的子树高度可以用 O(1) 时间计算出来</p>

    <p>h(X) = max( h(X.left), h(X.right) ) + 1</p>
  </li>
  <li>在动态操作时，也必须维持高度属性</li>
</ul>

<hr />

<p>Steps to Augment a Binary Tree:</p>
<ul>
  <li>为了在二叉树中增添子树属性 p，需要在每个结点处存储属性 p，并且可以用 O(1) 时间，从结点的孩子结点计算出属性值。</li>
  <li>那么，增加属性 p，不会改变动态操作的时间复杂度。</li>
</ul>]]></content><author><name>syh</name><email>songibicf@gmail.com</email></author><category term="算法" /><summary type="html"><![CDATA[1. 平衡二叉树]]></summary></entry></feed>