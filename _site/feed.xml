<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2022-10-07T17:54:17+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">syh 的博客</title><subtitle>记录计算机专业相关内容，Mens et Manus
</subtitle><author><name>syh</name><email>songibicf@gmail.com</email></author><entry><title type="html">加权最短路径</title><link href="http://localhost:4000/%E7%AE%97%E6%B3%95/2022/10/03/%E7%AE%97%E6%B3%95-0010.html" rel="alternate" type="text/html" title="加权最短路径" /><published>2022-10-03T00:00:00+08:00</published><updated>2022-10-03T00:00:00+08:00</updated><id>http://localhost:4000/%E7%AE%97%E6%B3%95/2022/10/03/%E7%AE%97%E6%B3%95-0010</id><content type="html" xml:base="http://localhost:4000/%E7%AE%97%E6%B3%95/2022/10/03/%E7%AE%97%E6%B3%95-0010.html"><![CDATA[<h3 id="1-加权图">1. 加权图</h3>

<p>review:</p>
<ul>
  <li>单源最短路径：BFS， O(|V| + |E|)</li>
  <li>单源可达性：BFS 或者 DFS，O(|E|) (因为只返回可以到达的顶点)</li>
  <li>连通性：Full-BFS 或者 Full-DFS, O(|V| + |E|)</li>
  <li>拓扑排序：Full-DFS, O(|V| + |E|)</li>
</ul>

<p>之前最短路径按照 distance = number of edges in path 来算，现在考虑加权图中的最短路径。</p>

<p>加权图：</p>
<ul>
  <li>带有权重函数 w 的图，例如给图中的每条边 e = (u, v) 分配一个整数权重 w(e) = w(u, v)</li>
  <li>加权图的应用：
    <ul>
      <li>道路交通中的距离</li>
      <li>网络连接中的延迟</li>
      <li>社交网络中的关系好坏程度</li>
    </ul>
  </li>
  <li>表示权重的两种方式：
    <ul>
      <li>直接在邻接表中存储权重</li>
      <li>或者存储一个 set 数据结构，把边映射到权重</li>
    </ul>
  </li>
</ul>

<p>加权路径：</p>
<ul>
  <li>一条路径的权重 w(π) 是路径中所有边的权重之和</li>
  <li>在加权图中，从 s 到 t 的加权最短路径是权重最小的路径</li>
</ul>

<p>加权最短路径算法：</p>

<div align="center">
<img src="/image/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95-0010-1.png" width="600" />
<p></p>
</div>

<h3 id="2-计算最短路径树">2. 计算最短路径树</h3>
<ul>
  <li>对于 BFS，在搜索时一直记录 parent。但是，也可以从每个顶点的最短距离计算出来。</li>
  <li>如果知道所有顶点 v 的 δ(s, v)， 可以用 <code class="language-plaintext highlighter-rouge">O(|V|+|E|)</code> 的时间创建出最短路径树</li>
</ul>

<p>使用 δ(s, v) 计算最短路径树，步骤如下：</p>
<ul>
  <li>初始化 P，设置 P(s) = None</li>
  <li>对于每个顶点 u，δ(s, u) 是有限的：
    <ul>
      <li>对于 u 的 outgoing neighbor v:</li>
      <li>如果 P(v) 没有被分配，并且 δ(s, v) = δ(s, u) + w(u, v)</li>
      <li>那么在 (u, v) 之间存在最短路径，设置 P(v) = u</li>
    </ul>
  </li>
  <li>父指针可能会遍历零权重的环路，标记在环中的所有顶点</li>
  <li>对于所有未标记的顶点 u
    <ul>
      <li>对于 u 的邻接点 v，且 v 已经被标记，并且 δ(s, v) = δ(s, u) + w(u, v)</li>
      <li>从 v 开始遍历父指针，取消标记该环中的顶点</li>
      <li>设置 P(v) = u, 打破环</li>
    </ul>
  </li>
</ul>

<p>该算法可以在线性时间内计算出最短路径树结点中的父指针。</p>

<h3 id="3-dag-relaxation">3. DAG Relaxation</h3>

<p>relaxation: 对于一个优化问题，要得到最优解， 可以从一个非最优解开始然后逐渐迭代来改进解，直到达到问题的最优解。</p>

<ul>
  <li>记录距离估计 d(s, v)，初始化为无穷大。该距离估计一定是真实距离 δ(s, v) 的上界，接下来需要逐步减少距离，直到 d(s, v) = δ(s, v)</li>
  <li>
    <p>什么时候降低 d(s, v)？在边违反<strong>三角不等式</strong>的时候</p>
  </li>
  <li>三角不等式：从 u 到 v 的最短路径权重不能大于从 u 经另一个顶点 x 到 v 的最短路径权重，即 δ(u, v) ≤ δ(u, x)+ δ(x, v) for all u, v, x ∈ V</li>
  <li>如果 d(s, v) &gt; d(s, u) + w(u, v)，违反了三角不等式</li>
  <li>fix 方法：降低 d(s, v) 为 d(s, u) + w(u, v)。</li>
</ul>

<p>可以证明最短路径估计 d(s, v) 永远不会小于真实的最短路径权重 δ(s, v)</p>
<ul>
  <li>Safety Lemma: 在 relax 过程中，d(s, v) 会一直大于等于 δ(s, v)</li>
  <li>证明：证明更强的声明，对于所有的 v，d(s, v) 在迭代时要么是无穷大，要么是 s 到 v 的<strong>某一条路径</strong>的权重，即 d(s, v) 会一直大于等于 δ(s, v)。
    <ul>
      <li>在初始的时候正确，d(s, v) 为无穷大</li>
      <li>假设在某一时刻声明为正确，relax 边 (u, v)。relax 边会让 d(s, v) 减少到 d(s, u) + w(u, v)，即 d(s, v) 变为从 s 出发，经过 u 到 v 路径的权重。</li>
    </ul>
  </li>
</ul>

<p>在 DAG 中，不存在环路，relaxation 最后一定会结束。按照拓扑顺序依次放松出边，可以正确的计算出最短路径。该算法叫做 DAG Relaxation。</p>

<p>步骤：</p>
<ul>
  <li>设置 d(s, v) = ∞, d(s, s) = 0</li>
  <li>对于图 G 中的所有顶点，按照拓扑顺序处理每一个顶点 u
    <ul>
      <li>对于 u 的 outgoing neighbor v ∈ Adj<sup>+</sup>(u)</li>
      <li>如果 d(s, v) &gt; d(s, u) + w(u, v)</li>
      <li>设置 d(s, v) = d(s, u) + w(u, v)</li>
    </ul>
  </li>
</ul>

<p>运行时间：</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">O(|V| + |E|)</code></li>
</ul>]]></content><author><name>syh</name><email>songibicf@gmail.com</email></author><category term="算法" /><summary type="html"><![CDATA[1. 加权图]]></summary></entry><entry><title type="html">DFS</title><link href="http://localhost:4000/%E7%AE%97%E6%B3%95/2022/10/01/%E7%AE%97%E6%B3%95-0009.html" rel="alternate" type="text/html" title="DFS" /><published>2022-10-01T00:00:00+08:00</published><updated>2022-10-01T00:00:00+08:00</updated><id>http://localhost:4000/%E7%AE%97%E6%B3%95/2022/10/01/%E7%AE%97%E6%B3%95-0009</id><content type="html" xml:base="http://localhost:4000/%E7%AE%97%E6%B3%95/2022/10/01/%E7%AE%97%E6%B3%95-0009.html"><![CDATA[<h3 id="1-dfs">1. DFS</h3>

<p>BFS 用来解决单源最短路径问题，得到从一个顶点到其余所有顶点的最短路径，运行时间为 <code class="language-plaintext highlighter-rouge">O(|V| + |E|)</code></p>

<p>DFS:</p>
<ul>
  <li>解决单源可达性问题，而不是最短路径问题</li>
  <li>
    <p>return (not necessarily shortest) parent tree of parent pointers back to s</p>
  </li>
  <li>Idea: vist outgoing adjacencies recursively, but never revisit a vertex</li>
  <li>
    <p>i.e., 沿着一条路径前进，直到无法再前进，接着回溯，直到找到一条未探索过的路径。对于可以从 s 到达的任何顶点 v，DFS 都会访问 v 并正确设置 P(v)。一次 DFS 后，在图中未访问过的顶点上依次调用 DFS，即可遍历图中所有顶点。</p>
  </li>
  <li>P(s) = None, 接着 visit(s)</li>
  <li>visit(u):
    <ul>
      <li>对于 u 的所有未出现在 P 中的邻接点，设置 P(v) = u，递归调用 visit(v)</li>
    </ul>
  </li>
  <li>如果还有未访问到的顶点，在该顶点上再次调用 DFS</li>
</ul>

<p>运行时间 <code class="language-plaintext highlighter-rouge">O(|V| + |E|) </code></p>

<h3 id="2-拓扑排序">2. 拓扑排序</h3>

<ul>
  <li>DAG 图：有向无环图</li>
  <li>拓扑顺序：对顶点分配顺序 f，使得对于每条边 (u, v) ∈ E 满足 f(u) &lt; f(v)。</li>
  <li>DAG 图可以得到顶点的拓扑排序</li>
</ul>

<p>步骤：</p>
<ul>
  <li>Finishing Order 是 DFS <strong>完成访问顶点</strong>的顺序，即 visit(u) 结束的顺序</li>
  <li>Claim: 对于图 G，如果 G 是 DAG 图，finishing order 的翻转序列是拓扑排序</li>
  <li>Proof: 需要证明对于每条边 (u, v) ∈ E，u 排在 v 前面，DFS 先访问完 v。分成两种情况：
    <ul>
      <li>如果 u 在 v 前面访问：在访问 u 结束前，会访问 v，因此访问 v 先结束</li>
      <li>如果在 v 在 u 前面访问，由于图是无环图，从 v 不能到达 u，因此v 在 u 前面结束访问</li>
    </ul>
  </li>
</ul>

<h3 id="3-cycle-detection">3. Cycle Detection</h3>

<ul>
  <li>如果图 G 是无环的，DFS 可以找到拓扑顺序</li>
  <li>如果反向 finishing order 不是拓扑排序，那么图中一定存在环</li>
</ul>]]></content><author><name>syh</name><email>songibicf@gmail.com</email></author><category term="算法" /><summary type="html"><![CDATA[1. DFS]]></summary></entry><entry><title type="html">Binary Heaps</title><link href="http://localhost:4000/%E7%AE%97%E6%B3%95/2022/09/28/%E7%AE%97%E6%B3%95-0007.html" rel="alternate" type="text/html" title="Binary Heaps" /><published>2022-09-28T00:00:00+08:00</published><updated>2022-09-28T00:00:00+08:00</updated><id>http://localhost:4000/%E7%AE%97%E6%B3%95/2022/09/28/%E7%AE%97%E6%B3%95-0007</id><content type="html" xml:base="http://localhost:4000/%E7%AE%97%E6%B3%95/2022/09/28/%E7%AE%97%E6%B3%95-0007.html"><![CDATA[<h3 id="1-优先队列接口">1. 优先队列接口</h3>

<ul>
  <li>存储多个项，可以快速的访问、移除最重要的项，实际例子有：
    <ul>
      <li>有限带宽的路由器必须优先处理重要的信息</li>
      <li>操作系统内核中的进程调度</li>
      <li>离散事件模拟</li>
      <li>图算法</li>
    </ul>
  </li>
  <li>优先队列是按照优先级对项进行了排序，所以也可以看作 Set 接口</li>
  <li>对于特定集合操作进行了优化：
    <ul>
      <li>build(X)</li>
      <li>insert(x)</li>
      <li>delete_max()</li>
      <li>find_max()</li>
    </ul>
  </li>
  <li>关注 insert 和 delete_max 操作</li>
  <li>优先队列有多种实现方法，例如 array， sorted array， set AVL tree。</li>
</ul>

<h3 id="2-优先队列排序">2. 优先队列排序</h3>

<ul>
  <li>在任何的优先队列中，都可以按以下方法对 A 进行排序
    <ul>
      <li>build(A)，例如依次 insert 每一项</li>
      <li>然后重复 delete_max()</li>
    </ul>
  </li>
  <li>时间复杂度：T<sub>build</sub> + n * T<sub>delete_max</sub> = n * T<sub>insert</sub> + n * T<sub>delete_max</sub></li>
  <li>在以下的优先队列实现中，应用优先队列排序的时间复杂度如下图。并且在特定实现中，优先队列排序和一些排序算法很相似。</li>
</ul>

<div align="center">
<img src="/image/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95-0007-1.png" width="600" />
<p></p>
</div>

<h4 id="21-优先队列set-avl-tree">2.1 优先队列：Set AVL Tree</h4>

<ul>
  <li>Set AVL 树支持 insert(x), find_min(), find_max(), delete_min() 和 delete_max() 操作，并且时间复杂度全部为 O(logn)</li>
  <li>按照优先队列排序，时间复杂度为 O(nlogn)</li>
  <li>但是这个数据结构复杂，并且排序不是原位的</li>
</ul>

<h4 id="22-优先队列array">2.2 优先队列：Array</h4>

<ul>
  <li>在动态数组中以无序的方式存储元素</li>
  <li>insert(x)：O(1)</li>
  <li>delete_max(): 找到最大值，交换到末尾，并且移除</li>
  <li>insert 很快，但是 delete_max() 慢</li>
  <li>在 array 实现中进行优先队列排序，基本上和选择排序一样</li>
</ul>

<h4 id="23-优先队列sorted-array">2.3 优先队列：Sorted Array</h4>

<ul>
  <li>在有序的动态数组中存储元素</li>
  <li>insert(x)：把 x 放入末尾，并将 x 交换到合适的位置</li>
  <li>delete_max(x)：直接从末尾删除</li>
  <li>delete_max 快，但是 insert 慢</li>
  <li>在 sorted array 上进行优先队列排序，基本上就是插入排序</li>
</ul>

<h3 id="3-heap">3. heap</h3>

<p>那么，可以在以上的优先队列实现中找到一个平衡吗？既保持排序算法的<strong>低时间复杂度</strong>，又是<strong>原位排序</strong>算法。</p>

<p>idea：<strong>把数组看作一个完全二叉树</strong>，除了最后一层，完全二叉树在深度为 i 的层上都有 2^i 个结点。在最后一层上所有的结点都是左对齐的。</p>

<p>完全二叉树填充数组时，是按照<strong>层次遍历</strong>的顺序放入，从根到叶子结点，一层一层从左往右依次放入。这样，完全二叉树和数组建立了对应关系，完全二叉树不是由指针来确定结点关系，而是由数组中的位置来确定结点关系。</p>

<p>根结点在索引 0 处。结点 i 的左孩子在索引 2i+1 处，右孩子在索引 2i+2 处，父结点在 math.floor((i-1)/2) 处。</p>

<h4 id="31-binary-heaps">3.1 Binary Heaps</h4>

<p>idea：元素越大，在树中放置的高度越高。</p>

<p>最大堆属性：在结点 i 处，Q[i] &gt;= Q[j] for j ∈ {left(i), right(i)}</p>

<p><strong>最大堆</strong>：在所有结点上都满足最大堆属性的<strong>数组</strong></p>

<p>在最大堆中，可以证明对于结点 i，Q[i] &gt;= Q[j]，j 可以是子树中任一结点。</p>

<h4 id="32-heap-insert">3.2 Heap Insert</h4>

<ul>
  <li>把要插入的元素 x 放入数组的末尾，相当于插入到树的叶子结点中</li>
  <li>max_heapify_up(i): 为了维持最大堆属性，依次与父结点交换
    <ul>
      <li>检查是否 Q[parent(i)] &gt;= Q[i]</li>
      <li>如果不是，交换结点，递归执行 max_heapify_up(parent(i))</li>
    </ul>
  </li>
  <li>运行时间：树的高度 O(logn)</li>
</ul>

<h4 id="33-heap-delete-max">3.3 Heap Delete Max</h4>

<ul>
  <li>在数组中只能容易的移除最后的元素，但是最大项却在索引 0 的位置</li>
  <li>所以，把索引 0 的项和最后一项进行交换，并删除交换后的最后一项</li>
  <li>然后执行 max_heapify_down(i)：从上往下维持最大堆属性
    <ul>
      <li>检查是否 Q[i] &gt;= Q[j] for j ∈ {left(i), right(i)}</li>
      <li>如果不是，把 Q[i] 和 最大的孩子结点交换，并递归执行 max_heapify_down</li>
    </ul>
  </li>
  <li>运行时间：树的高度 O(logn)</li>
</ul>

<h4 id="34-heap-sort">3.4 Heap Sort</h4>

<p>堆排序时间复杂度为 O(nlogn)</p>

<p>线性时间内建堆：</p>
<ul>
  <li>假如是依次插入 n 个元素到堆中，那么得调用 max_heapify_up(i) n 次，每次都得经过整个树高，时间复杂度为 Ω(n lg n)</li>
  <li>idea: 把数组看作完全二叉树，从 n-1 到 0 依次调用 max_heapify_down(i)，调用时只用确保子树，时间复杂度为 O(n)</li>
</ul>]]></content><author><name>syh</name><email>songibicf@gmail.com</email></author><category term="算法" /><summary type="html"><![CDATA[1. 优先队列接口]]></summary></entry><entry><title type="html">BFS</title><link href="http://localhost:4000/%E7%AE%97%E6%B3%95/2022/09/28/%E7%AE%97%E6%B3%95-0008.html" rel="alternate" type="text/html" title="BFS" /><published>2022-09-28T00:00:00+08:00</published><updated>2022-09-28T00:00:00+08:00</updated><id>http://localhost:4000/%E7%AE%97%E6%B3%95/2022/09/28/%E7%AE%97%E6%B3%95-0008</id><content type="html" xml:base="http://localhost:4000/%E7%AE%97%E6%B3%95/2022/09/28/%E7%AE%97%E6%B3%95-0008.html"><![CDATA[<h3 id="1-graph">1. Graph</h3>

<p>图的应用例子：</p>
<ul>
  <li>任何网络系统，例如道路交通、计算机网络、社交网络</li>
  <li>任何离散系统的状态空间可以表示为图，例如 Chess、Teris、Rubik’s cube</li>
</ul>

<p><strong>图定义：</strong></p>
<ul>
  <li>G = (V, E)</li>
  <li>有向边由有序对表示，例如 (u, v)，无向边由无序对表示，例如 {u, v}</li>
  <li>简单图：
    <ul>
      <li>edges are distinct</li>
      <li>边连接不同的顶点</li>
      <li>|E| = O(|V|^2)</li>
    </ul>
  </li>
  <li>出边集：Adj<sup>+</sup>(u) = {v ∈ V | (u, v) ∈ E}</li>
  <li>入边集: Adj<sup>-</sup>(u) = {v ∈ V | (v, u) ∈ E}</li>
  <li>出度: deg<sup>+</sup>(u) = |Adj<sup>+</sup>(u)|</li>
  <li>入度: deg<sup>-</sup>(u) = |Adj<sup>-</sup>(u)|</li>
  <li>对于无向图 Adj<sup>-</sup>(u) = Adj<sup>+</sup>(u)， deg<sup>-</sup>(u) = deg<sup>+</sup>(u)</li>
</ul>

<p><strong>图的表示：</strong></p>
<ul>
  <li>对于图 G = (V, E)，存储 u 的所有出边 Adj(u)。</li>
  <li>使用 Set 来存储所有的顶点，可以使用直接访问数组或哈希表，size 为 Θ(|V|)</li>
  <li>对于每个顶点，为了存储邻接的顶点，使用数组或者链表。每个顶点邻接列表 size 为 Θ(deg(u))</li>
  <li>图存储需要 Θ(|V| + |E|) 空间</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># 图的直接访问数组表示
A1 = [
      [1, 4, 3],
      [0],
      [3],
      [0, 2],
      [0]
    ]

# 图的哈希表表示
A1 = {
      0: {1, 3, 4},
      1: {0},
      2: {3},
      3: {0, 2},
      4: {0}
    }
</code></pre></div></div>

<p><strong>路径：</strong></p>
<ul>
  <li>路径：顶点序列 p = (v1, v2, . . . , vk)，(vi, vi+1) ∈ E</li>
  <li>简单路径：没有重复顶点，或者说没有环的路径</li>
  <li>路径的长度：路径中的边数</li>
  <li>u 和 v 之间的距离：从 u 到 v 的最短路径的长度</li>
</ul>

<p><strong>图路径问题：</strong></p>
<ul>
  <li>single_pair_reachability(G, s, t): 从 s 到 t 有路径吗</li>
  <li>single_pair_shortest_path(G, s, t): 找到 s 到 t 的最短路径</li>
  <li>single_source_shortest_paths(G, s): 返回 s 到其它所有顶点的最短路径树</li>
</ul>

<p><strong>Shortest Paths Tree：</strong></p>
<ul>
  <li>得到从 s 到其他所有顶点的最短路径</li>
  <li>用 P(v) 代表从 s 到 v 顶点最短路径上的 v 的上一个顶点</li>
</ul>

<h3 id="2-bfs">2. BFS</h3>
<p><strong>BFS：</strong></p>
<ul>
  <li>对于 v ∈ V，如何计算 δ(s, v) 和 P(v)</li>
  <li>在一个集合数据类型中存储 δ(s, v) 和 P(v)，把 v 映射到距离和 P(v)</li>
  <li><strong>Idea:</strong> 按距离递增的顺序探索图结点</li>
  <li>Goal：计算所有的 Level sets L<sub>i</sub> = {v | v ∈ V and d(s, v) = i}</li>
  <li>Claim: L<sub>i</sub> 中每个顶点 v 一定与 L<sub>i-1</sub> 中的某个顶点 u 邻接，v ∈ Adj(u)</li>
  <li><strong>Invariant:</strong> δ(s, v) and P(v) have been computed correctly for all v in any L<sub>j</sub> for j &lt; i。对于当前层的顶点，上一层的顶点已经全部得到了最短的路径。</li>
</ul>

<p>BFS 按照层次顺序得到顶点 L<sub>i</sub>，且 L<sub>i</sub> 中的顶点是最短路径为 i 可以到达的顶点。</p>

<p><strong>BFS 步骤：</strong></p>
<ul>
  <li>base case (i=1): L0 = {s}, δ(s, s) = 0, P(s) = None</li>
  <li>Inductive Step: 为了计算 L<sub>i</sub>:
    <ul>
      <li>对于 L<sub>i-1</sub> 中每个顶点 u
        <ul>
          <li>对于每个顶点 v ∈ Adj(u)，并且 v 不出现在之前的层中，把 v 添加到 L<sub>i</sub>，设置 δ(s, v) = i，P(v) = u</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>重复计算 L<sub>i</sub>，直到 L<sub>i</sub> 不能再添加顶点</li>
  <li>对于剩余的顶点，设置 δ(s, v) = ∞</li>
</ul>

<p>BFS 的运行时间为 O(|V| + |E|)</p>]]></content><author><name>syh</name><email>songibicf@gmail.com</email></author><category term="算法" /><summary type="html"><![CDATA[1. Graph]]></summary></entry><entry><title type="html">测试</title><link href="http://localhost:4000/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0/2022/09/26/%E8%BD%AF%E4%BB%B6-0004.html" rel="alternate" type="text/html" title="测试" /><published>2022-09-26T00:00:00+08:00</published><updated>2022-09-26T00:00:00+08:00</updated><id>http://localhost:4000/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0/2022/09/26/%E8%BD%AF%E4%BB%B6-0004</id><content type="html" xml:base="http://localhost:4000/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0/2022/09/26/%E8%BD%AF%E4%BB%B6-0004.html"><![CDATA[<h3 id="1-validation">1. Validation</h3>

<p>测试是 Validation 的重要一步。验证的目的是发现程序中存在的问题。Validation 包括：</p>
<ul>
  <li>形式推理 (Formal reasoning)：通过推导，证明程序的正确性。</li>
  <li>代码审查 (Code review)：让其他人仔细阅读你的代码。</li>
  <li>测试 (Testing)：在精心选择的输入上验证程序的输出。</li>
</ul>

<p>即使进行了最好的验证，在软件上也很难实现最好的质量。典型的 residual defect rates:</p>
<ul>
  <li>1 - 10 defects/kloc: 典型的工业软件</li>
  <li>0.1 - 1 defects/kloc: 高质量验证的软件，例如成熟浏览器的 JavaScript 库</li>
  <li>0.01 - 0.1 defects/kloc: 最好的、安全关键的验证。例如航空领域软件</li>
</ul>

<p>软件测试中的有些方法是不可行的：</p>
<ul>
  <li>详尽测试</li>
  <li>Haphazard testing</li>
  <li>随机或者统计测试</li>
</ul>

<h3 id="2-test-first-编程">2. Test-first 编程</h3>

<ul>
  <li>module：软件系统的一部分，可以被设计、实现、测试、推理，并且该部分与系统的其他部分独立。该节主要关注的模块为函数，之后会关注 class</li>
  <li>specification：描述模块的行为。</li>
  <li>一个模块通过实现 (implementation) 来提供功能，并且 clients 可以使用该模块。</li>
  <li>test case：测试用例，特定选择的输入，同时在 specification 中包含期望输出。</li>
  <li>test suite：一个模块的测试用例的集合</li>
</ul>

<p>test-first programming: 在写代码前先写 spec 和 tests。例如写函数的步骤如下：</p>
<ol>
  <li>Spec：为函数写一个 specification</li>
  <li>Test：写与 specification 对应的测试</li>
  <li>Implement：具体实现</li>
</ol>

<h3 id="3-系统测试">3. 系统测试</h3>

<p>系统测试：按照特定的方式选择测试例子，按以下三个属性设计 test suite：</p>
<ul>
  <li>Correct：correct test suite 是 specification 合法的 client，接受所有合法的实现。</li>
  <li>Thorough：一个彻底的 test suite 可以发现实现中实际的 bug</li>
  <li>Small：test suite 要尽可能的小</li>
</ul>

<h3 id="4-通过划分来选择测试用例">4. 通过划分来选择测试用例</h3>]]></content><author><name>syh</name><email>songibicf@gmail.com</email></author><category term="软件构造" /><summary type="html"><![CDATA[1. Validation]]></summary></entry><entry><title type="html">TypeScript 基础</title><link href="http://localhost:4000/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0/2022/09/23/%E8%BD%AF%E4%BB%B6-0003.html" rel="alternate" type="text/html" title="TypeScript 基础" /><published>2022-09-23T00:00:00+08:00</published><updated>2022-09-23T00:00:00+08:00</updated><id>http://localhost:4000/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0/2022/09/23/%E8%BD%AF%E4%BB%B6-0003</id><content type="html" xml:base="http://localhost:4000/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0/2022/09/23/%E8%BD%AF%E4%BB%B6-0003.html"><![CDATA[<h3 id="1-snapshot-图">1. Snapshot 图</h3>
<p>snapshot 图：表示程序运行时的内部状态，包括 stack (运行中的方法和局部变量) 和 heap (当前存在的对象)。</p>

<p>改变一个变量或字段：改变了变量的箭头指向
改变一个可修改对象的内容：改变值内部的引用</p>

<p>string 是不可修改的类型，当创建之后，<strong>值</strong>不能被改变。可修改对象则是可以改变对象的值。</p>

<p><strong>不可重新分配的引用</strong>：变量只能赋值一次，并且永远不能被重新赋值，用 const 来声明。</p>

<p>不可重新分配的引用可以指向可修改的值，例如</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const arr:Array&lt;string&gt; = ["a"];
arr.push("b")
</code></pre></div></div>

<p>可重新分配的引用可以指向不可修改的值，此时变量的值可以改变。例如：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let s:string = "a";
s = "ab";
</code></pre></div></div>

<p>函数调用中参数传递为值传递，即参数接受一个初始值，在函数内部参数可以任意的重新分配，不会影响到 caller。大多数的编程语言都是值传递，例如 Python, Java, C。少数语言，如 C++，C# 提供引用传递。</p>

<h3 id="2-typescript-基础">2. TypeScript 基础</h3>

<p>TypeScript 中的 Array 与 Python 中的 list 类似。</p>

<table>
  <tbody>
    <tr>
      <td>TypeScript</td>
      <td>Python</td>
    </tr>
    <tr>
      <td>lst.length</td>
      <td>len(lst)</td>
    </tr>
    <tr>
      <td>lst.push(e)</td>
      <td>lst.append(e)</td>
    </tr>
    <tr>
      <td>if (lst.length === 0)</td>
      <td>if not list: …</td>
    </tr>
    <tr>
      <td>lst.includes(e)</td>
      <td>e in lst</td>
    </tr>
    <tr>
      <td>lst.splice(i, 1)</td>
      <td>del lst[i]</td>
    </tr>
  </tbody>
</table>

<p>Map 与 Python 中字典相似。在 Python 中，键必须是可哈希的。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Python 中的可哈希：一个对象的哈希值如果在其生命周期内绝不改变，并可以同其他对象进行比较 (具有 __eq__ 方法)，就被称为可哈希的 (它需要具有 __hash__ 方法)。

可哈希行使得对象能够作为字典键或集合成员使用，这些数据结构在内部使用哈希值。
</code></pre></div></div>

<table>
  <tbody>
    <tr>
      <td>TypeScript</td>
      <td>Python</td>
    </tr>
    <tr>
      <td>map.set(key, val)</td>
      <td>map[key] = val</td>
    </tr>
    <tr>
      <td>map.get(key)</td>
      <td>map[key]</td>
    </tr>
    <tr>
      <td>map.has(key)</td>
      <td>key in map</td>
    </tr>
    <tr>
      <td>map.delete(key)</td>
      <td>del map[key]</td>
    </tr>
    <tr>
      <td>map.size</td>
      <td>len(map)</td>
    </tr>
  </tbody>
</table>

<p>Set 类型
| TypeScript | Python |
| s.has(e) | e in s|
| s.add(e) | s.add(e) |
| s.delete(e) | s.remove(e) |
| s.size | len(s) |</p>

<h4 id="21-generics">2.1 Generics</h4>
<p>不像 Python 中的容器类型。 TypeScript 中的容器可以严格限定容器中对象的类型。当向容器中添加项时，TypeScript 会对项进行静态检查。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># 容器例子
let cities: Array&lt;string&gt;;
let cities: string[]
let number: Set&lt;number&gt;;
let turtles: Map&lt;string, Turtle&gt;
</code></pre></div></div>

<h4 id="22-iteration">2.2 Iteration</h4>

<p>Python 中：</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for city in cities:
    print(city)

for num in numbers:
    print(num)

for key in turtles:
    print("%s: %s" %(key, turtles[key]))
</code></pre></div></div>

<p>TypeScript:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for (const city of cities) {
    console.log(city);
}

for (const num of numbers) {
    console.log(num);
}

for (const key of turtles.keys()) {
    console.log(key + ":" + turtles.get(key));
}
</code></pre></div></div>

<p>在 array 和 map 中使用 <code class="language-plaintext highlighter-rouge">get()</code> 去访问一个 key，如果 key 不存在，会返回特殊的值 <code class="language-plaintext highlighter-rouge">undefined</code></p>

<p>JavaScript 中数组实际上是 sparse 的，可以在任意的索引位置放置一个新元素。</p>

<h4 id="23-变量声明">2.3 变量声明</h4>

<p>JavaScript 中可以使用 let、const、var 来声明一个变量。let 声明的变量可重新赋值，const 声明的为不可重新分配的变量。var 为旧的风格，因为声明变量的 scope 为整个 functions，而 let 声明的变量 scope 为闭合花括号内。</p>

<h4 id="24-对象字面量和对象类型">2.4 对象字面量和对象类型</h4>

<p>record type: 一个对象，只有 named fields，没有方法。在 C/C++ 里面叫做 struct。</p>

<p>TypeScript 可以使用 {field1:value1, field2:value2, …}，快速创建具有特定值的 record type 对象。</p>

<p>解构赋值：通过解构赋值，可以将属性/值从对象/数组中取出，赋值给其他变量。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let a, b, rest;
[a, b] = [10, 20]

[a, b, ...rest] = [10, 20, 30, 40, 50];

({a, b} = {a:10, b:20});
</code></pre></div></div>

<h3 id="3-api-文档与工具">3. API 文档与工具</h3>

<ul>
  <li>MDN： JavaScript 的通用功能，包含浏览器指定的 API</li>
  <li>Node.js: outside-the-browser API</li>
  <li>TypeScript Handbook：与 TypeScript 有关的 API</li>
</ul>

<p>MDN 文档的结构：</p>

<ol>
  <li>Description
    <ul>
      <li>类的简短描述</li>
    </ul>
  </li>
  <li>Constructor</li>
  <li>Instance properties</li>
  <li>Instance methods
    <ul>
      <li>method signature</li>
      <li>full description</li>
      <li>parameters</li>
      <li>returns</li>
    </ul>
  </li>
</ol>

<p>Node.js：JavaScript 的解释器
npm：”Node Package Manager”，有两个功能。首先，它管理用于程序的外部包库。其次，npm 是其他编程工具的通用运行环境。</p>

<p>使用 TypeScript prompt:</p>
<ol>
  <li>npm install ts-node</li>
  <li>npx ts-node</li>
</ol>]]></content><author><name>syh</name><email>songibicf@gmail.com</email></author><category term="软件构造" /><summary type="html"><![CDATA[1. Snapshot 图 snapshot 图：表示程序运行时的内部状态，包括 stack (运行中的方法和局部变量) 和 heap (当前存在的对象)。]]></summary></entry><entry><title type="html">二叉树 II</title><link href="http://localhost:4000/%E7%AE%97%E6%B3%95/2022/09/21/%E7%AE%97%E6%B3%95-0006.html" rel="alternate" type="text/html" title="二叉树 II" /><published>2022-09-21T00:00:00+08:00</published><updated>2022-09-21T00:00:00+08:00</updated><id>http://localhost:4000/%E7%AE%97%E6%B3%95/2022/09/21/%E7%AE%97%E6%B3%95-0006</id><content type="html" xml:base="http://localhost:4000/%E7%AE%97%E6%B3%95/2022/09/21/%E7%AE%97%E6%B3%95-0006.html"><![CDATA[<h3 id="1-平衡二叉树">1. 平衡二叉树</h3>

<p>之前提到二叉树目的是对于树高为 h 的树，使得算法的时间复杂度为 O(h), 并且尽可能维持 h = O(logn)，最终 O(h)=O(logn)。那么，如何维持树的高度 h = O(logn) ?</p>

<p><strong>平衡二叉树</strong>：在动态操作时，例如 insert(x), delete(x), 可以维持高度为 O(logn) 的二叉树。有许多平衡的范式 (Red-Black Trees, Splay Trees, 2-3 Trees,…)。最早提出的平衡范式为 AVL 树 (Adelson-Velsky and Landis, 1962)。</p>

<p>树的旋转：</p>
<ul>
  <li>目的：降低树的高度，但是不改变遍历顺序</li>
  <li>旋转操作只是修改了指针，时间复杂度为 O(1)</li>
</ul>

<div align="center">
<img src="/image/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95-0006-1.png" width="500" />
<p></p>
</div>

<p>旋转的特性：O(n) 次旋转可以将二叉树转换为具有相同遍历顺序的任何其他二叉树。</p>

<h3 id="2-avl-树">2. AVL 树</h3>

<ul>
  <li>AVL 树保持了 height-balance
    <ul>
      <li>一个结点叫做 height-balance，如果左子树和右子树的高度最多差 1</li>
      <li>一个结点的偏斜 (skew) 为其右子树的高度减去左子树的高度</li>
      <li>如果 skew 为 -1， 0， 1， 那么该结点是 height-balance</li>
    </ul>
  </li>
  <li>所有结点为 height-balance 的二叉树，其高度 h = O(log n)
    <ul>
      <li>高度为 h 二叉树的结点树 F(h) = 1 + F(h-1) + F(h-2) &gt;= 2F(h-2)</li>
    </ul>
  </li>
  <li>假设增加或者删除叶子结点，导致原先 height-balance 的树不平衡
    <ul>
      <li>那么仅叶子结点的祖先结点在高度或者 skew 上有改变</li>
      <li>高度最多改变 ±1, 所以 skew 的绝对值还是  ≤ 2</li>
      <li>修复的 idea: 从叶子结点开始，一直到根结点，依次修复，使得叶子结点的所有祖先结点 height-balance</li>
    </ul>
  </li>
</ul>

<h4 id="21-avl-树的-rebalance">2.1 AVL 树的 Rebalance</h4>

<p><strong>Local Rebalance</strong>：给定一个二叉树结点 B</p>
<ul>
  <li>假设其 skew 为 2</li>
  <li>B 子树中其他结点为 height-balanced</li>
  <li>那么，B 子树通过一次或者两次旋转操作可以变平衡</li>
</ul>

<hr />

<p><strong>证明</strong>：
因为 B 的 skew 为 2，那么 B 的右孩子结点一定存在，记为 F。</p>

<p><strong>Case 1</strong>: F 的 skew 为 0。</p>

<p><strong>Case 2</strong>: F 的 skew 为 1。</p>

<p>对于这两种情况，都是对 B 执行左旋操作。</p>

<div align="center">
<img src="/image/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95-0006-2.png" width="500" />
<p></p>
</div>

<p>假设 h = height(A), 那么原始状态下 height(G) = h+1, 情况 1 中 height(D) = h+1, 情况 2 中 height(D) = h。
旋转后，B 的 skew 在情况 1 为 1，情况 2 为 0，所以 B 是 height-balanced。旋转后，F 的 skew 为 -1，F height-balanced。</p>

<p><strong>Case 3</strong>：
F 的 skew 为 -1，那么得先对 F 执行右旋，再左旋。证明和上面类似。</p>

<div align="center">
<img src="/image/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95-0006-3.png" width="500" />
<p></p>
</div>

<hr />

<p><strong>Global Rebalance</strong>：对于 height-balanced 树 T，增加或者移除一个叶子结点，得到 T’。之后可以通过最多 O(logn) 次旋转，重新得到平衡二叉树 T’‘。</p>

<p><strong>证明</strong>：</p>
<ul>
  <li>仅叶子结点的祖先，高度受到了影响。且最多有 O(logn) 个祖先。</li>
  <li>把最低的受到影响的祖先记为 X</li>
  <li>如果 T 中是增加了一个叶子结点：
    <ul>
      <li>插入操作增加了 X 的高度，可以对 X 进行 local rebalance 操作</li>
      <li>在旋转后保持了平衡</li>
    </ul>
  </li>
  <li>如果 T 中移除了一个叶子结点
    <ul>
      <li>删除可能减少了 X 的一个孩子结点的高度，但是 X 的高度未受影响</li>
      <li>删除也可能导致 X 的高度减少 1，X 的父结点也可能不平衡</li>
      <li>所以得重新平衡 X 的祖先，但是最多 O(logn) 次</li>
    </ul>
  </li>
  <li>因此，O(logn) 次旋转操作可以变回平衡二叉树</li>
</ul>

<h3 id="3-计算高度">3. 计算高度</h3>

<p>如果判断结点 X 是否 height-balanced? 这需要知道子树的高度，因此要计算子树的高度。</p>

<p>方法：subtree augmentation</p>
<ul>
  <li>在结点处附加上<strong>子树高度</strong>的属性</li>
  <li>
    <p>X 结点的子树高度可以用 O(1) 时间计算出来</p>

    <p>h(X) = max( h(X.left), h(X.right) ) + 1</p>
  </li>
  <li>在动态操作时，也必须维持高度属性</li>
</ul>

<hr />

<p>Steps to Augment a Binary Tree:</p>
<ul>
  <li>为了在二叉树中增添子树属性 p，需要在每个结点处存储属性 p，并且可以用 O(1) 时间，从结点的孩子结点计算出属性值。</li>
  <li>那么，增加属性 p，不会改变动态操作的时间复杂度。</li>
</ul>]]></content><author><name>syh</name><email>songibicf@gmail.com</email></author><category term="算法" /><summary type="html"><![CDATA[1. 平衡二叉树]]></summary></entry><entry><title type="html">二叉树 I</title><link href="http://localhost:4000/%E7%AE%97%E6%B3%95/2022/09/16/%E7%AE%97%E6%B3%95-0005.html" rel="alternate" type="text/html" title="二叉树 I" /><published>2022-09-16T00:00:00+08:00</published><updated>2022-09-16T00:00:00+08:00</updated><id>http://localhost:4000/%E7%AE%97%E6%B3%95/2022/09/16/%E7%AE%97%E6%B3%95-0005</id><content type="html" xml:base="http://localhost:4000/%E7%AE%97%E6%B3%95/2022/09/16/%E7%AE%97%E6%B3%95-0005.html"><![CDATA[<h3 id="1-二叉树">1. 二叉树</h3>

<p>序列结构介绍了数组、链表、动态数组，操作的时间复杂度见上表。集合数据结构介绍了数组、有序数组、直接访问数组、hash 表。但是这些数据结构在某一项或者两项操作的时间复杂度占优势，无法兼顾全部操作的时间复杂度。而通过二叉树可以实现 “Goal” 一栏的时间复杂度。</p>

<p>二叉树是基于指针的数据结构，每个结点包含三个指针，分别为 node.parent, node.left, node.right。</p>

<p><strong>术语</strong>：</p>
<ul>
  <li>根：在树中如果某一结点没有父结点，那么该结点叫做树的根</li>
  <li>叶结点：没有孩子结点</li>
  <li>结点 x 的深度：从根结点到该结点的路径长度</li>
  <li>结点 x 的高度：以 x 为根的子树的最大深度</li>
</ul>

<p>为什么要使用树结构？</p>

<p>树结构也是也指针为基础的，每个结点包含三个指针。但是与链表不同，在链表中每访问一个结点都得从前往后开始遍历，时间复杂度为 O(n)。二叉树通过每个结点的 2 个分支，将树的高度最低可以降到 O(logn)。</p>

<p>因此，二叉树所有算法的基本 idea 为：对于树高为 h 的树，设计算法，使得操作的时间复杂度为 O(h), 并且尽可能维持 h = O(logn)，使得最后算法的时间复杂度为 O(h)=O(logn)</p>

<p>二叉树的遍历，如果按照中序遍历：</p>
<ul>
  <li>结点 x 左子树的结点在 x 之前</li>
  <li>结点 x 右子树的结点在 x 之后</li>
  <li>从根结点开始递归遍历</li>
</ul>

<h3 id="2-树的遍历">2. 树的遍历</h3>

<p>以下全部按中序遍历，介绍了遍历中结点出现的顺序。</p>

<p>以结点 x 为根的子树中<strong>第一个结点</strong>：</p>
<ul>
  <li>如果 x 有左孩子，递归返回左子树的第一个结点</li>
  <li>否则，x 是第一个结点，返回 x</li>
  <li>运行时间为 O(h)</li>
</ul>

<p>以结点 x 为根的子树中<strong>最后一个结点</strong>：</p>
<ul>
  <li>如果 x 有右孩子，递归返回右子树的最后一个结点</li>
  <li>否则，x 是最后一个结点，返回 x</li>
</ul>

<p>结点 x 的<strong>后继结点</strong>：</p>
<ul>
  <li>如果 x 有右子树，返回右子树第一个结点</li>
  <li>否则，返回 x 的最低祖先结点，且 x 要在该祖先结点的左子树中</li>
  <li>运行时间为 O(h)</li>
</ul>

<p>结点 x 的<strong>前驱结点</strong>：</p>
<ul>
  <li>如果 x 有左子树，返回左子树最后一个结点</li>
  <li>否则，返回 x 的最低祖先结点，x 要在该祖先结点的右子树中</li>
</ul>

<h3 id="3-动态操作">3. 动态操作</h3>

<p>在 x 结点之后<strong>插入</strong>新结点 y：</p>
<ul>
  <li>如果 x 没有右子树，把 y 放入 x 的右孩子结点</li>
  <li>否则，把 y 放入 x 后继结点 s 的左孩子结点中。s 一定没有左孩子，因为 s 是 x 右子树第一个结点。y 相当于放在 s 的前面。</li>
</ul>

<p><strong>删除</strong>结点 x：</p>
<ul>
  <li>如果 x 是叶子结点，直接删除</li>
  <li>否则，x 有孩子结点。此时不能直接删除 x，得与其他结点交换，让 x 变到叶子结点。
    <ul>
      <li>如果 x 有左孩子，让 x 与其<strong>前驱结点</strong>交换，递归删除 x 结点</li>
      <li>否则，让 x 与其<strong>后继结点</strong>交换，递归删除 x 结点</li>
    </ul>
  </li>
  <li>运行时间为 O(h)</li>
</ul>

<h3 id="4-应用">4. 应用</h3>

<h4 id="41-set">4.1 Set</h4>

<ul>
  <li>idea：集合中重要的是 <strong>find</strong> 操作，为了用树实现比较，常用的是二叉搜索树 (Binary Search Tree / BST)。
    <ul>
      <li>中序遍历得到的结果是按键排列好的</li>
      <li>等价的 BST 属性：对于每个结点，左子树中的值小于结点的值，右子树中的值大于结点的值。</li>
    </ul>
  </li>
  <li>在树中查找键值 k
    <ul>
      <li>如果 k 小于结点 x 的值，在左子树中递归查找</li>
      <li>如果 k 大于结点 x 的值，在右子树中递归查找</li>
      <li>否则，返回 x</li>
    </ul>
  </li>
</ul>

<h4 id="42-sequence">4.2 Sequence</h4>

<ul>
  <li>idea：使得中序遍历得到的顺序是按序列顺序排列的</li>
  <li>查找 i 结点的操作，调用 subtree_at(i)。但是需要从头开始进行中序遍历，时间复杂度为 O(n)。</li>
  <li>但是，如果可以用 O(1) 的时间复杂度得到<strong>子树的大小</strong> (size)，访问 i 结点的操作时间复杂度可以降到 O(h)。子树大小指子树中结点的总个数。
    <ul>
      <li>首先检查<strong>左子树</strong>的大小 n<sub>L</sub>，并且与 i 比较</li>
      <li>如果 i &lt; n<sub>L</sub>，说明第 i 个结点在左子树，递归查找</li>
      <li>如果 i &gt; n<sub>L</sub>，在右子树上递归查找，且 i’ = i - n<sub>L</sub> - 1</li>
      <li>否则，i = n<sub>L</sub>，则根结点索引值为 i，返回根结点</li>
    </ul>
  </li>
  <li>通过扩增 (augmentation) 来记录每个结点子树的尺寸
    <ul>
      <li>在 node 中加入属性 node.size</li>
      <li>当加入一个新的叶子结点，对于该结点的所有祖先结点，size 都加 1</li>
      <li>当删除一个叶子结点，对于该结点的所有祖先结点，size 减少 1</li>
    </ul>
  </li>
  <li>subtree augmentation：
    <ul>
      <li>每个结点存储 O(1) 额外的属性</li>
      <li>subtree 的属性可以从其左子树和右子树的属性用 O(1) 时间计算出来</li>
      <li>无论对树进行什么修改操作，都得更新结点的属性</li>
      <li>可能的 subtree properties：sum，product，min，max，height</li>
      <li>不能作为 subtree properties：index，depth</li>
    </ul>
  </li>
</ul>

<p>时间复杂度：</p>
<div align="center">
<img src="/image/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95-0005-1.png" width="500" />
<p></p>
</div>]]></content><author><name>syh</name><email>songibicf@gmail.com</email></author><category term="算法" /><summary type="html"><![CDATA[1. 二叉树]]></summary></entry><entry><title type="html">环境配置</title><link href="http://localhost:4000/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0/2022/09/14/%E8%BD%AF%E4%BB%B6-0001.html" rel="alternate" type="text/html" title="环境配置" /><published>2022-09-14T00:00:00+08:00</published><updated>2022-09-14T00:00:00+08:00</updated><id>http://localhost:4000/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0/2022/09/14/%E8%BD%AF%E4%BB%B6-0001</id><content type="html" xml:base="http://localhost:4000/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0/2022/09/14/%E8%BD%AF%E4%BB%B6-0001.html"><![CDATA[<p>课程名称是 Software Construction，网站为：<a href="https://web.mit.edu/6.031/www/sp22/">https://web.mit.edu/6.031/www/sp22/</a>。课程用的是 JavaScript，开始先安装软件。全部在 WSL 下安装。</p>

<h3 id="1-安装-typescript">1. 安装 TypeScript</h3>
<h4 id="11-node">1.1 node</h4>

<p>按照说明安装</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>https://github.com/nodesource/distributions/blob/master/README.md
</code></pre></div></div>

<p>检查：</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>node --version
</code></pre></div></div>

<h4 id="12-install-typescript">1.2 install TypeScript</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo -H npm install -g typescript

# 检查
tsc --version
</code></pre></div></div>

<h3 id="2-git-配置">2. Git 配置</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># 用户名和邮箱
git config --global user.name "Your Name"
git config --global user.email email@email

# 设置 alias，以后输入 git lol 就可代替 log 后面的一串命令
git config --global alias.lol "log --graph --oneline --decorate --color --all"

# 列出目前的 config
git config --list
</code></pre></div></div>

<h4 id="21-git-基础概念">2.1 Git 基础概念</h4>

<p>Git 是一种版本控制系统 (version control system, VCS)。一些基础的概念：</p>
<ul>
  <li>存储库 (repository)：包含与项目相关所有文件的文件夹，以及对这些文件的整个提交历史。</li>
  <li>提交 (commit)：给定时间点时存储库中文件的快照。</li>
  <li>添加/暂存 (add/stage)：在对文件的更改可以提交到存储库之前，必须添加或暂存相关文件。</li>
  <li>克隆 (clone)：开发人员可以从 github 上 “克隆” 远程存储库，得到一份本地存储库。之后可以对本地存储库进行修改。</li>
  <li>push：将本地的 commit 发送到远程存储库中，相当于上传修改。</li>
  <li>pull：检查远程存储库的提交，并将远程存储库中的修改写入本地存储库，相当于得到最新版本。</li>
</ul>]]></content><author><name>syh</name><email>songibicf@gmail.com</email></author><category term="软件构造" /><summary type="html"><![CDATA[课程名称是 Software Construction，网站为：https://web.mit.edu/6.031/www/sp22/。课程用的是 JavaScript，开始先安装软件。全部在 WSL 下安装。]]></summary></entry><entry><title type="html">静态检查</title><link href="http://localhost:4000/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0/2022/09/14/%E8%BD%AF%E4%BB%B6-0002.html" rel="alternate" type="text/html" title="静态检查" /><published>2022-09-14T00:00:00+08:00</published><updated>2022-09-14T00:00:00+08:00</updated><id>http://localhost:4000/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0/2022/09/14/%E8%BD%AF%E4%BB%B6-0002</id><content type="html" xml:base="http://localhost:4000/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0/2022/09/14/%E8%BD%AF%E4%BB%B6-0002.html"><![CDATA[<h3 id="1-types">1. Types</h3>

<p>数据类型：值 + 操作</p>

<p>TypeScript 的几个内建类型：</p>
<ul>
  <li>number，表示整数和浮点数</li>
  <li>boolean</li>
  <li>string，表示字符序列</li>
</ul>

<p>Operation：有输入，并且产生输出的<strong>函数</strong>，syntax 包括：</p>
<ul>
  <li>operator</li>
  <li>function</li>
  <li>method</li>
  <li>property</li>
</ul>

<p>TypeScript 是静态类型语言，变量可以被指定一个类型，在编译时会进行类型检查，并且编译器可以推导出表达式的类型。JavaScript 和 Python 是动态类型语言，只有在运行时才可进行类型检查。</p>

<p>TypeScript 相比于 JavaScript 增加了静态类型检查，反映了软件工程领域一条规则，即对于创建和维护大型的软件来说，使用静态类型是不可或缺的。</p>

<h3 id="2-静态检查动态检查不检查">2. 静态检查，动态检查，不检查</h3>

<p>语言可以提供的三类自动检查：</p>
<ul>
  <li>静态检查：在编译时就可以发现程序中的类型错误</li>
  <li>动态检查：在代码实际运行时发现错误</li>
  <li>不检查：语言不提供任何检查功能</li>
</ul>

<p>提供静态检查比提供动态检查要好，提供动态检查比不检查要好。</p>

<p>静态检查能发现的错误：</p>
<ul>
  <li>句式错误：例如多余的标点符号或者可疑的词。</li>
  <li>错误拼写的名称：例如 Math.sine(2)</li>
  <li>错误的参数数目：例如 Math.sin(30, 20)</li>
  <li>错误的参数类型：例如 Math.sin(“30”)</li>
  <li>错误的返回值：  例如一个函数声明返回 number，却 return “30”，</li>
</ul>

<p>动态检查可以发现的错误：</p>
<ul>
  <li>特定的不合法的参数值：例如表达式 x/y，当 y 是 0 时，引发错误。</li>
  <li>不合法的类型转换：例如 int(“hello”)</li>
  <li>索引越界：数组中的 IndexError</li>
  <li>在错误的对象引用上调用方法：例如 underfined 或者 null 上调用方法</li>
</ul>

<p>静态类型可以检测与变量类型有关的错误，但是通常不能发现与合法类型中特定值有关的错误。</p>

<p>在 TypeScript 中，TypeScript 提供静态检查，但是运行时的行为完全由 JavaScript 提供。但是 JavaScript 在设计时，对于大多数的动态检查都不支持。例如，当 string 或者 array 越界，JavaScript 返回一个特殊的值 undefined，而不是像 Python 一样 throw IndexError；当除以 0 时，JavaScript 返回代表 infinity 的特殊值，同样不是引发错误。不提供检查使得 bug 更难被发现，因为特殊的值可能会继续进行接下来的计算，直到发生错误。</p>

<h4 id="21-surprisenumber-is-not-a-true-number">2.1 Surprise：<code class="language-plaintext highlighter-rouge">number</code> is not a true number</h4>

<p>TypeScript 的另一个陷阱是，数字类型有几个例子，与常见的实数运算不同。</p>

<ul>
  <li>整数的有限精度：在 TypeScript 中，所有的数字都是浮点数，这意味着大的整数只能近似表示。从 -2^53 到 2^53 的整数可以准确表示，但是当超过这个范围，只能保留最高有效二进制位。</li>
  <li>特殊的值：<code class="language-plaintext highlighter-rouge">number</code> 有几个特殊的值，这些值不是实数，例如 <code class="language-plaintext highlighter-rouge">Number.NaN</code>， <code class="language-plaintext highlighter-rouge">Number.POSITIVE_INFINITY</code>, <code class="language-plaintext highlighter-rouge">Number.NEGATIVE_INFINITY</code></li>
  <li>overflow 和 underflow：不能表示非常大的数与非常小的数。当表示超过 Number.MAX_VALUE 的数，结果是 POSITIVE_INFINITY。</li>
</ul>

<h3 id="3-javascript">3. JavaScript</h3>

<h4 id="31-array">3.1 Array</h4>

<p>Array：可变长度的序列，可以保持任何的类型，与 Python 中的 list 相似。</p>

<p>创建空数组：</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let array: Arary&lt;number&gt; = [];
</code></pre></div></div>

<h4 id="32-functions">3.2 Functions</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/**
 * Compute a hailstone sequence.
 * @param n starting number for sequence. Assumes n &gt; 0
 * @returns hailstone sequence starting with n and ending with 1
 */
function hailstoneSequence(n:number): Array&lt;number&gt; {
    let array: Array&lt;number&gt; = [];
    while (n != 1) {
        array.push(n);
        if (n % 2 === 0) {
            n = n / 2;
        } else {
            n = 3 * n + 1;
        }
    }
    array.push(n);
    return array;
}
</code></pre></div></div>

<h4 id="33-可修改的值-vs-重新分配变量">3.3 可修改的值 vs. 重新分配变量</h4>

<p>不可变类型：一旦创建，值不能改变的类型。string 类型在 Python 和 JavaScript 中都不可变。</p>

<p>TypeScript 允许声明不可变引用。变量一旦被赋值，永远不能重新分配。使用 const 来声明不可变引用。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const n: number = 5;
</code></pre></div></div>

<h3 id="4-文档假设">4. 文档假设</h3>

<p>写变量的类型其实对变量做出了假设，变量有自己的取值范围。 程序员必须有以下两个目标：</p>
<ul>
  <li>与计算机交流。首先得让编译器知道程序是正确的，例如句式是正确的，类型也正确。</li>
  <li>与其他人交流。程序得益于理解，其他人可以修改程序。</li>
</ul>

<h4 id="41-hacking-vs-engineering">4.1 hacking vs. engineering</h4>

<p>haching：</p>
<ul>
  <li>不进行代码测试</li>
  <li>把所有的细节都记在脑子里，假设你会永远记住它们，而不是把它们写在你的代码中。</li>
  <li>假设 bug 不存在或者很容易修复</li>
</ul>

<p>工程：</p>
<ul>
  <li>一次写一点，逐步测试</li>
  <li>在代码内附带上你的假设</li>
  <li>远离愚蠢的错误，静态检查有许多帮助</li>
</ul>

<p>6.031 目标：</p>
<ul>
  <li>Safe from bugs</li>
  <li>Easy to understand</li>
  <li>Ready for change</li>
</ul>

<p>为什么使用 TypeScript：</p>

<ul>
  <li>安全：TypeScript 有静态检查</li>
  <li>无处不在：TypeScript 直接编译成 JavaScript，广泛用在各领域中。相比于 Java，TypeScript 有更为丰富的类型系统，更适合创建现代用户接口和网页应用。</li>
</ul>]]></content><author><name>syh</name><email>songibicf@gmail.com</email></author><category term="软件构造" /><summary type="html"><![CDATA[1. Types]]></summary></entry></feed>