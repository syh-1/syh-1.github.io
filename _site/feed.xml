<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2022-11-05T17:42:57+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">syh 的博客</title><subtitle>记录计算机专业相关内容，Mens et Manus
</subtitle><author><name>syh</name><email>songibicf@gmail.com</email></author><entry><title type="html">代码审查</title><link href="http://localhost:4000/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0/2022/11/04/%E8%BD%AF%E4%BB%B6-0005.html" rel="alternate" type="text/html" title="代码审查" /><published>2022-11-04T00:00:00+08:00</published><updated>2022-11-04T00:00:00+08:00</updated><id>http://localhost:4000/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0/2022/11/04/%E8%BD%AF%E4%BB%B6-0005</id><content type="html" xml:base="http://localhost:4000/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0/2022/11/04/%E8%BD%AF%E4%BB%B6-0005.html"><![CDATA[<h3 id="1-code-review">1. Code review</h3>

<p>代码审查的目的：</p>
<ol>
  <li>改进代码：查找错误，预测可能的错误，检查代码的清晰度，并检查与项目标准的一致性。</li>
  <li>学习编程：代码审查是程序员互相学习的重要方式，包括学习新的语言特定，改变项目的设计或编码标准。</li>
</ol>

<p>通常，代码审查是维持代码质量的重要一步。<a href="https://google.github.io/eng-practices/review/">Code Review Developer Guide</a></p>

<h3 id="2-如何进行代码审查">2. 如何进行代码审查</h3>

<p>代码审查的目的是确保代码质量可以逐步提升。通常，一旦代码肯定会改善当前系统的整体代码运行状况，审阅者应该赞成批准 CL (change list)，即使 CL 并不完美。关键一点是不存在 “perfect” 代码，只有更好的代码。</p>

<p>代码审查看什么：</p>
<ul>
  <li>Design：CL 是否设计良好？CL 是否适合系统其余部分？需要增加该功能吗？</li>
  <li>功能性：代码达到预期的功能了吗？代码对于使用者来说好用吗？</li>
  <li>复杂度：代码能够更简单吗？一行的代码是否太复杂？别的开发者可以容易理解和使用代码吗？</li>
  <li>测试：代码有正确的、设计良好的自动测试吗？单元测试，集成测试通过了吗？</li>
  <li>命名：变量、类、方法有清晰的命名吗？</li>
  <li>注释：注释清晰有用吗？通常注释用来解释为什么代码这样写，而不是解释代码在做什么。</li>
  <li>风格：代码符合 style guides 吗？</li>
  <li>文档：相关的文档与代码一致吗？</li>
</ul>

<p>代码审查的步骤：</p>
<ol>
  <li>全面浏览改变的地方</li>
  <li>检查 CL 主要的部分</li>
  <li>按照合适的顺序查看 CL 的其余部分</li>
</ol>

<p>如何写代码审查评论：</p>
<ul>
  <li>解释理由</li>
  <li>在给出具体的方向和单指出问题之间取舍</li>
  <li>鼓励开发者简化代码，或者增加注释</li>
</ul>

<p>如何写 CL 描述：</p>
<ul>
  <li>CL 描述记录了改变了什么代码，为什么改变</li>
  <li>第一行：简短的描述做了什么，使用完整的句子</li>
  <li>body 要描述细节，描述解决了什么问题，为什么要这样解决</li>
  <li>CL 的大小：改变应该是自我包含的改变</li>
</ul>

<h3 id="3-style-standards">3. Style standards</h3>

<p><a href="https://google.github.io/styleguide/">Google style guides</a></p>

<p>好的代码原则：</p>
<ul>
  <li>Don’t repeat yourself</li>
  <li>在需要的地方写注释</li>
  <li>Fail fast</li>
  <li>Avoid magic numbers</li>
  <li>One purpose for each variable</li>
  <li>Use good names</li>
  <li>Don’t use global variables</li>
  <li>函数应该返回值，而不是打印出来</li>
  <li>Avoid special-case code</li>
</ul>

<p>三种变量：</p>
<ul>
  <li>局部变量：函数内的变量</li>
  <li>实例变量：在对象的实例内，也被叫做 property、member variable、attribute、field</li>
  <li>全局变量：在函数外的变量</li>
</ul>]]></content><author><name>syh</name><email>songibicf@gmail.com</email></author><category term="软件构造" /><summary type="html"><![CDATA[1. Code review]]></summary></entry><entry><title type="html">APSP 算法</title><link href="http://localhost:4000/%E7%AE%97%E6%B3%95/2022/10/13/%E7%AE%97%E6%B3%95-0013.html" rel="alternate" type="text/html" title="APSP 算法" /><published>2022-10-13T00:00:00+08:00</published><updated>2022-10-13T00:00:00+08:00</updated><id>http://localhost:4000/%E7%AE%97%E6%B3%95/2022/10/13/%E7%AE%97%E6%B3%95-0013</id><content type="html" xml:base="http://localhost:4000/%E7%AE%97%E6%B3%95/2022/10/13/%E7%AE%97%E6%B3%95-0013.html"><![CDATA[<h3 id="1-apsp">1. APSP</h3>

<p>APSP (All-Pairs Shortest Paths) 问题：</p>
<ul>
  <li>输入: 有向图 G = (V, E)，带有权重函数 w</li>
  <li>输出：输出所有的 δ(u, v)，如果 G 包含负权重环路，记录该顶点</li>
</ul>

<p>可以简单的运行 SSSP 算法 |V| 次。但是在包含负权重的图中，Johnson 算法可以把复杂度降低为 <code class="language-plaintext highlighter-rouge">|V|·O(|V|log|V|+|E|)</code></p>

<p>方法：</p>
<ul>
  <li>Idea：在保留最短路径的前提下，让所有边的权重变为非负。例如，让 G 变为 G’，且 G’ 中没有负权重，在这个过程中，G 中的最短路径和 G’ 中的最短路径要保持一致。如果图中没有负权重，那么可以使用 Dijkstra 算法运行 |V| 次来解决 APSP。</li>
  <li>Claim：可以从 G’ 中的距离计算出 G 中的距离，且时间复杂度为 <code class="language-plaintext highlighter-rouge">O(|V|(|V|+|E|))</code>
    <ul>
      <li>对于 V’ 中的每个顶点 s，从距离中可以计算出最短路径树，时间复杂度为 <code class="language-plaintext highlighter-rouge">O(|V| + |E|)</code></li>
      <li>这也是 G 中的最短路径树，所以用 DFS 遍历树，可以计算出 G 中的距离</li>
      <li>总共花费 <code class="language-plaintext highlighter-rouge">O(|V|(|V|+|E|))</code>时间</li>
    </ul>
  </li>
  <li>Claim：如果 G 中包含负权重环路，无法把 G 转变为非负权重图 G’</li>
  <li>Proof：如果一个图为非负权重，那么其最短路径是简单路径。但是在有负权重环路的图中，最短路径不一定是简单路径。无法做到 G 和 G’ 中的最短路径保持不变。</li>
</ul>

<h3 id="2-权重变为非负">2. 权重变为非负</h3>

<p>如果图 G 有负权重，但是没有负权重环路，如何把权重变为非负：</p>
<ul>
  <li>Idea：在每条的权重上，增加最小权重的负值，那么得到的所有权重都是非负的</li>
  <li>上述 idea 不可行，因为，没有保留最短路径不变， G’ 中最短路径偏向于选择更少边的路径。</li>
  <li>Idea：给定顶点 v，在所有的出边上加 h，在所有的入边上减少 h</li>
  <li>Claim：在上述的重新赋权重后，最短路径得到了保留</li>
  <li>Proof：
    <ul>
      <li>v 开始的每条路径权重改变了 h</li>
      <li>以 v 结束的每条路径权重改变了 -h</li>
      <li>经过 v 的路径权重局部不改变</li>
    </ul>
  </li>
</ul>

<p><strong>potential function h：</strong>把 V 映射到整数</p>

<p>图 G’ 此时由 G 创建而来，但是边 (u, v) 的权重 w’(u, v) = w(u, v) + h(u) - h(v)</p>

<p>Claim: 图 G 中的最短路径还是 G’ 中的最短路径</p>

<p>Proof：</p>
<ul>
  <li>G 中路径 π = (v0, …, vk) 权重为 w(π)。该路径在 G’中的权重是 w(π) + h(v0) - h(vk)</li>
  <li>从 v0 到 vk 所有的路径都是改变了相同的量，都是 h(v0)-h(vk)</li>
  <li>所以图 G 中的最短路径还是 G’ 中的最短路径</li>
</ul>

<hr />

<p>找到 potential function：</p>
<ul>
  <li>需要满足对于任意的边 (u, v)，w(u,v) + h(u) - h(v) &gt;= 0</li>
  <li>变形后得到：h(v) &lt;= h(u)+w(u, v)，形式类似于三角不等式</li>
  <li>Idea：选 h(v) = δ(s, v)，那么上述条件可能满足，但是图中可能存在不连通的点，因此 h(v) 不能简单的选为 δ(s, v)</li>
  <li>
    <p>Idea：增加一个新顶点 s，该顶点有指向任一顶点的出边，且这些出边的权重为 0。通过增加新顶点和权重为 0 的边，避免了图不连通的问题。 h(v) 可以选为 δ(s, v)。</p>
  </li>
  <li>Claim：如果 δ(s, v) = −∞，那么原始的图中存在负权重环路</li>
  <li>Proof：
    <ul>
      <li>在图中增加的新顶点 s 不会添加环路，因为 s 只有出边</li>
      <li>如果没有负权重环路，那么 δ(s, v) &lt;= 0，如果 δ(s, v) = −∞，那么原始的图中存在负权重环路</li>
    </ul>
  </li>
</ul>

<p><strong>Johnson’s 算法：</strong></p>
<ul>
  <li>从图 G 增加一个顶点 x，x 有权重为 0 的出边连接到每一个顶点，得到图 Gx</li>
  <li>使用 Bellman-Ford 算法计算 δ(x, v)</li>
  <li>如果 δ(x, v) = −∞，那么对于该顶点 v：
    <ul>
      <li>Abort</li>
    </ul>
  </li>
  <li>否则：
    <ul>
      <li>更改边的权重为 w’(u, v) = w(u, v) + δ(x, u) - δ(x, v)，形成图 G’</li>
      <li>对于每个顶点 u：</li>
      <li>使用 Dijkstra 算法计算到每个顶点 v 的 δ’(u, v)</li>
      <li>图 G 中的距离 δ(u, v) = δ’(u, v) − δ(x, u) + δ(x, v)</li>
    </ul>
  </li>
</ul>

<p>运行时间：
<code class="language-plaintext highlighter-rouge">O(|V| * (|V|log|V| + |E|))</code></p>]]></content><author><name>syh</name><email>songibicf@gmail.com</email></author><category term="算法" /><summary type="html"><![CDATA[1. APSP]]></summary></entry><entry><title type="html">递归算法</title><link href="http://localhost:4000/%E7%AE%97%E6%B3%95/2022/10/13/%E7%AE%97%E6%B3%95-0014.html" rel="alternate" type="text/html" title="递归算法" /><published>2022-10-13T00:00:00+08:00</published><updated>2022-10-13T00:00:00+08:00</updated><id>http://localhost:4000/%E7%AE%97%E6%B3%95/2022/10/13/%E7%AE%97%E6%B3%95-0014</id><content type="html" xml:base="http://localhost:4000/%E7%AE%97%E6%B3%95/2022/10/13/%E7%AE%97%E6%B3%95-0014.html"><![CDATA[<h3 id="1-如何解决算法问题">1. 如何解决算法问题</h3>
<ol>
  <li>使用已有的算法
    <ul>
      <li>search data structure：数组、链表、动态数组、有序数组、直接访问数组、哈希表、AVL 树、堆</li>
      <li>排序算法：插入排序、选择排序、归并排序、计数排序、基数排序、AVL 排序、堆排序</li>
      <li>图算法：BFS、DFS、DAG relaxation、Dijkstra、Bellman-Ford、Johnson</li>
    </ul>
  </li>
  <li>设计递归算法</li>
</ol>

<hr />

<p>如何递归的解决问题：</p>
<ol>
  <li>Subproblem definition</li>
  <li>Relate subproblem solutions recursively</li>
  <li>Topological order on subproblems</li>
  <li>Base cases of relation</li>
  <li>original problem solution via subproblem</li>
  <li>Time analysis</li>
</ol>

<p>Merge Sort 例子：</p>
<ul>
  <li>Subproblem：S(i, j) = 对原数组 A[i:j] 排好序的数组</li>
  <li>Relation：S(i, j) = merge(S(i, m), S(m, j)), m = (i+j)/2</li>
  <li>Topo. order：j-i 的值越来越大</li>
  <li>Base cases：S(i, i+1) = <code class="language-plaintext highlighter-rouge">[A[i]]</code></li>
  <li>Original：S(0, n)</li>
  <li>Time: T(n) = 2T(n/2) + O(n) = O(nlgn)</li>
</ul>

<p>Fibonacci Numbers 例子:</p>
<ul>
  <li>Subproblem: F(i) = 第 i 个 fibonacci 数</li>
  <li>Relation：F(i) = F(i-1) + F(i-2)</li>
  <li>Topo. order：i 从小到大</li>
  <li>Base cases：F(0) = 0, F(1) = 1</li>
  <li>Original: F(n)</li>
  <li>Time: T(n) = T(n-1) + T(n-2) + O(1)
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def fib(n):
  if n &lt; 2:
      return n
  return fib(n-1) + fib(n-2)
</code></pre></div>    </div>
  </li>
</ul>

<hr />

<p>为了避免重复计算子问题，可以重新使用已经得到的子问题的解，有两种方法：</p>
<ul>
  <li>子问题的依赖图是 DAG</li>
  <li>为了重新使用子问题的解：
    <ul>
      <li>自上往下：在内存中记录子问题的解，并且重新使用解 (recursive + memoization)</li>
      <li>自下往上：按照拓扑排序的顺序来求解子问题 (via loops)</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># recursive solution （top down)
def fib(n):
    memo = {}
    def F(i):
        if i &lt; 2:
            return i
        if i not in memo:
            memo[i] = F(i-1) + F(i-2)
        return memo[i]
    return F(n)

# iterative solution (bottom up)
def fib(n):
    F = {}
    F[0], F[1] = 0, 1
    for i in range(2, n+1):
        F[i] = F[i-1] + F[i-2]
    return F[n]
</code></pre></div></div>

<h3 id="2-动态规划">2. 动态规划</h3>
<ul>
  <li>可以使用递归意味着问题可以分解成子问题</li>
  <li>递归算法意味着计算过程可以表示成图</li>
  <li>如果子问题依赖有重叠 (DAG 图中的入度 &gt; 1)，那么可以使用动态规划</li>
</ul>

<p>动态规划是分治法的泛化，在分治法中，子问题依赖形成的是树，而在动态规划中，子问题依赖是有向无环图。动态规划经常用于优化问题，例如最大化或最小化单个标量值。</p>

<p>当选择好子问题，并且子问题依赖确定的话，有两种方法来求解问题：</p>
<ol>
  <li>“Recurse but re-use” (top down: record and lookup subproblem solutions)</li>
  <li>“Careful brute force” (Bottom up: do each subproblem in order)</li>
</ol>

<p>这两种方法中都要用到 Memoization，需要在过程中记录之前计算得到的值。</p>

<hr />

<p>如何递归的解决问题 (SRT BOT)</p>
<ol>
  <li>Subproblem definition
    <ul>
      <li>用语言描述子问题的含义</li>
      <li>经常是输入的子集：序列的前缀、后缀、连续子字符串</li>
      <li>如果有多个输入，经常是可能子集的乘积</li>
      <li>经常记录部分状态：通过增加一些辅助变量创建子问题</li>
    </ul>
  </li>
  <li>Relate subproblem solutions recursively
    <ul>
      <li>找到子问题之间的关系</li>
      <li>locally brute-force all possible answers to the question</li>
    </ul>
  </li>
  <li>Topological order to argue relation is acyclic and subproblems form a DAG
    <ul>
      <li>找到拓扑排序，证明关系是无环的，子问题形成一个 DAG</li>
    </ul>
  </li>
  <li>Base cases
    <ul>
      <li>所有的基础情况</li>
    </ul>
  </li>
  <li>Original problem
    <ul>
      <li>根据子问题，计算原始问题</li>
      <li>可以使用父指针来得到实际的解</li>
    </ul>
  </li>
  <li>Time analysis
    <ul>
      <li>子问题的个数 * 子问题关系计算中的非递归代价</li>
    </ul>
  </li>
</ol>

<h3 id="3-动态规划例子">3. 动态规划例子</h3>

<p>DAG Shortest Paths：</p>
<ul>
  <li>Subproblems： 计算 δ(s, v)</li>
  <li>Relation：δ(s, v) = min{δ(s, u) + w(u, v) | u ∈ Adj<sup>-</sup>(v) }</li>
  <li>Topo. order: G 的拓扑排序</li>
  <li>Base cases: δ(s, s) = 0</li>
  <li>Original: 所有的子问题</li>
</ul>

<p>其余例子：</p>
<ul>
  <li>Longest Common Subsequence</li>
  <li>Longest Increasing Subsequence</li>
  <li>Max Subarray Sum</li>
  <li>Edit Distance</li>
</ul>]]></content><author><name>syh</name><email>songibicf@gmail.com</email></author><category term="算法" /><summary type="html"><![CDATA[1. 如何解决算法问题 使用已有的算法 search data structure：数组、链表、动态数组、有序数组、直接访问数组、哈希表、AVL 树、堆 排序算法：插入排序、选择排序、归并排序、计数排序、基数排序、AVL 排序、堆排序 图算法：BFS、DFS、DAG relaxation、Dijkstra、Bellman-Ford、Johnson 设计递归算法]]></summary></entry><entry><title type="html">Dijkstra 算法</title><link href="http://localhost:4000/%E7%AE%97%E6%B3%95/2022/10/12/%E7%AE%97%E6%B3%95-0012.html" rel="alternate" type="text/html" title="Dijkstra 算法" /><published>2022-10-12T00:00:00+08:00</published><updated>2022-10-12T00:00:00+08:00</updated><id>http://localhost:4000/%E7%AE%97%E6%B3%95/2022/10/12/%E7%AE%97%E6%B3%95-0012</id><content type="html" xml:base="http://localhost:4000/%E7%AE%97%E6%B3%95/2022/10/12/%E7%AE%97%E6%B3%95-0012.html"><![CDATA[<h3 id="1-dijkstra-算法">1. Dijkstra 算法</h3>

<p>处理 non-negative edge weights:</p>

<p>idea：在加权图中泛化 BFS 方法
    - 重复探索更近的顶点，从近到远探索</p>

<p>如何在不知道距离的前提下探索顶点？</p>

<p><strong>Observation 1：</strong>如果权重非负，那么沿着最短路径，距离是在增加的
    - 例如，如果 u 出现在 s 到 v 的最短路径上，那么 δ(s, u) ≤ δ(s, v)
    - 把从 s 起，经过距离 &lt;= x 可以到达的顶点集合记为 Vx
    - 如果 v ∈ Vx，那么从 s 到 v 的最短路径只包含 Vx 中的顶点
    - 那么可以在探索的时候逐渐扩充 Vx</p>

<p><strong>Ovservation 2：</strong>如果把顶点按照距 s 的距离排列，那么可以很快的解决 SSSP 问题。
    - 移除违反该顺序的边
    - 对于所有顶点 v，使用 DAG relaxation 计算 δ(s, v)</p>

<hr />

<p><strong>Dijkstra 算法：</strong></p>
<ul>
  <li>idea：按照离 s 的距离递增顺序，依次松弛边</li>
  <li>idea：利用数据结构，可以快速的找到顺序中的下一个顶点
    <ul>
      <li>changeable priority queue Q：存储的项带有 key 和独特的 id，可以删除最小 key 的项，也可以把某一个 id 项的 key 改变。</li>
      <li>通过 cross-linking 来实现，把字典 D 映射到 ID，ID 映射到优先队列中的项 Q’</li>
      <li>ID 可以是从 0 到 |V|-1 的整数，表示一个顶点</li>
    </ul>
  </li>
</ul>

<p>Dijkstra 算法的步骤：</p>
<ul>
  <li>对于所有的 v，设置 d(s, v) = ∞，设置 d(s, s) = 0</li>
  <li>创建 changeable priority queue Q，存储所有的 (v, d(s, v))，元组中分别为 id 和 key</li>
  <li>当 Q 不为空时，从 Q 中删除 d(s, u) 最小的项 (u, d(s, u))
    <ul>
      <li>对于 u 的出邻接点 v：</li>
      <li>如果 d(s, v) &gt; d(s, u) + w(u, v)，松弛边 (u, v)，即设置 d(s, v) = d(s, u) + w(u, v)。并且在 Q 中修改 v 的 key 为新的估计 d(s, v)</li>
    </ul>
  </li>
</ul>

<p><strong>例子：</strong></p>
<div align="center">
<img src="/image/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95-0012-1.png" width="500" />
<p></p>
</div>

<h3 id="2-证明">2. 证明</h3>

<p>Claim：Dijkstra 算法结束时，对于所有的 v，d(s, v) = δ(s, v)
Proof：</p>
<ul>
  <li>如果松弛时 d(s, v) 减少到了 δ(s, v)，那么在算法结束时 d(s, v) = δ(s, v)
    <ul>
      <li>松弛只能减少估计 d(s, v)</li>
      <li>松弛是安全的，例如维持 d(s, v) 是从 s 到 v 一条路径的权重</li>
    </ul>
  </li>
  <li>证明当顶点 v 从 Q 中移除时，d(s, v) = δ(s, v)
    <ul>
      <li>基本情况 (k=1)：s 是从 Q 移除的第一个顶点，d(s, s) = 0 = δ(s, s)</li>
      <li>归纳步骤：假设对于 k &lt; k’为真，考虑第 k’ 个顶点 v’ 从 Q 中移除的情况</li>
      <li>从 s 到 v’ 的最短路径表示为 π，用 (x, y) 表示 π 中 y 不在前 k’-1 个顶点的边。</li>
      <li>当 x 从 Q 中移除，根据假设 d(s, x) = δ(s, x)。所以 d(s, y) &lt;= δ(s, x) + w(x, y) = δ(s, y) &lt;= δ(s, v’) &lt;= d(s, v’) &lt;= d(s, y)</li>
      <li>所以 d(s, v’) = δ(s, v’)</li>
    </ul>
  </li>
</ul>

<p>运行时间：</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">O(|E| + |V|log|V|)</code></li>
</ul>]]></content><author><name>syh</name><email>songibicf@gmail.com</email></author><category term="算法" /><summary type="html"><![CDATA[1. Dijkstra 算法]]></summary></entry><entry><title type="html">Bellman-Ford 算法</title><link href="http://localhost:4000/%E7%AE%97%E6%B3%95/2022/10/07/%E7%AE%97%E6%B3%95-0011.html" rel="alternate" type="text/html" title="Bellman-Ford 算法" /><published>2022-10-07T00:00:00+08:00</published><updated>2022-10-07T00:00:00+08:00</updated><id>http://localhost:4000/%E7%AE%97%E6%B3%95/2022/10/07/%E7%AE%97%E6%B3%95-0011</id><content type="html" xml:base="http://localhost:4000/%E7%AE%97%E6%B3%95/2022/10/07/%E7%AE%97%E6%B3%95-0011.html"><![CDATA[<h3 id="1-negative-cycle-witness">1. Negative Cycle Witness</h3>

<p>练习：给定一个 SSSP 算法 A，其时间复杂度为 <code class="language-plaintext highlighter-rouge">O(|V|(|V| + |E|)</code>，如果在 <code class="language-plaintext highlighter-rouge">O(|V||E|)</code> 时间内解决 SSSP 问题。</p>

<p>Solution:</p>
<ul>
  <li>运行 BFS 或者 DFS，找到从 s 可以到达的顶点，时间复杂度为 <code class="language-plaintext highlighter-rouge">O(|E|)</code></li>
  <li>标记其余不可达的顶点 δ(s, v) = ∞，时间复杂度为 <code class="language-plaintext highlighter-rouge">O(|V|)</code></li>
  <li>创建 G’ = (V’, E’)，只包含可以从 s 到达的顶点，时间复杂度为 <code class="language-plaintext highlighter-rouge">O(|V|+ |E|)</code></li>
  <li>在 G’ 上运行 A。G’是连通图， 因此 <code class="language-plaintext highlighter-rouge">|V'| = O(|E'|) = O(|E|)</code>，A 的运行时间是 <code class="language-plaintext highlighter-rouge">O(|V||E|)</code></li>
</ul>

<p>Bellman-Ford 算法的目的：在任意权重的 general graph 上，实现 SSSP 算法的时间复杂度为 <code class="language-plaintext highlighter-rouge">O(|V||E|)</code></p>

<hr />

<p><strong>简单最短路径：</strong></p>
<ul>
  <li>如果图中包含环路和负权重，那么可能包含负权重环路 (negative-weight cycles)</li>
  <li>如果图中不包含 negative-weight cycles，最短路径是简单的</li>
</ul>

<p><strong>Claim 1：</strong>如果 δ(s, v) 是有限的，那么 s 到 v 的最短路径一定是简单路径</p>

<p><strong>证明：</strong>：</p>
<ul>
  <li>反证法，假设 s 到 v 的最短路径 π 不是简单路径</li>
  <li>π 不是简单路径，那么一定存在环路 C，C 是非负的权重。因为 C 如果是负权重环路， δ(s, v) 就是 −∞。</li>
  <li>从 π 中移除 C，得到更少权重的路径，与 π 是最短路径矛盾。</li>
</ul>

<p>由 claim 1 可以看到，有限长度的最短路径一定是简单路径，因此绝不可能包含环路，任意的最短路径最多包含 <code class="language-plaintext highlighter-rouge">|V| − 1</code> 条边。</p>

<hr />

<p><strong>Negative Cycle Witness</strong></p>
<ul>
  <li>k-边距离 δ<sub>k</sub>(s, v)：从 s 到 v 的使用边数小于等于 k 的任何路径的最小权重</li>
  <li>Idea：对于所有的顶点，计算 δ<sub>|V|−1</sub>(s, v) 和 δ<sub>|V|</sub>(s, v)
    <ul>
      <li>如果 δ(s, v) != -∞，δ(s, v) = δ<sub>|V|−1</sub>(s, v)，因为最短路径是简单路径</li>
      <li>如果 δ<sub>|V|</sub>(s, v) &lt; δ<sub>|V|−1</sub>(s, v)，那么存在更短的非简单路径，所以 δ<sub>|V|</sub>(s, v) = -∞，并且把 v 叫做 negative cycle witness</li>
      <li>但是，负环路上的顶点不全是 witness</li>
    </ul>
  </li>
</ul>

<p>Claim 2: 如果 δ(s, v) = −∞，那么 v 可以从一个 witness 抵达</p>

<p>证明：可以从 s 到达的每个负权环路上都包含一个见证</p>

<h3 id="2-bellman-ford">2. Bellman-Ford</h3>

<ul>
  <li>Idea: 使用图重复，对图复制多份</li>
  <li>新图有|V| + 1 层: 在 k 层的顶点 v<sub>k</sub> 表示从 v 到 s 使用 &lt;= k 条边</li>
  <li>如果边仅仅在层与层之间连接，那么，得到的为 DAG</li>
</ul>

<p>步骤：</p>
<ul>
  <li>创建一个新 DAG G’ = (V’, E’)
    <ul>
      <li>G’ 有 <code class="language-plaintext highlighter-rouge">|V|(|V| + 1)</code> 个顶点 v<sub>k</sub>, k ∈ {0, . . . ,|V|}</li>
      <li>G’ 有 <code class="language-plaintext highlighter-rouge">|V|(|V| + |E|)</code> 条边，|V|条边 (vk-1, vk), 且权重为 0。|V|条边 (uk-1, vk)，且权重为 w(u, v)。</li>
      <li>相当于创建 |V| + 1 层图。顶点数很好计算。但是边连接的顶点要变一下，G’ 中有两种类型的边，一种是连接相邻两层、相同顶点的边，由于在顶点内部移动不产生权重，因此边权重为 0；另一种是原图中就有的边，现在连接相邻两层中与原图相对应的顶点，权重还是原图中的权重。</li>
    </ul>
  </li>
  <li>在 G’ 上以 s<sub>0</sub> 为起点运行 DAG Relaxation</li>
  <li>对于每个顶点，设置 d(s, v) = δ(s<sub>0</sub>, v<sub>|V| - 1</sub>)</li>
  <li>接下来处理环路，对于每个 witness u，其  δ(s<sub>0</sub>, u<sub>|V|</sub>) &lt; δ(s<sub>0</sub>, u<sub>|V|−1</sub>):
    <ul>
      <li>对于图 G 中可以从 u 抵达的顶点 v，设置 d(s, v) = -∞</li>
    </ul>
  </li>
</ul>

<p>例子：</p>

<div align="center">
<img src="/image/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95-0011-1.png" width="500" />
<p></p>
</div>

<p>正确性证明：</p>
<ul>
  <li>Claim 3：对于所有的 v，且 k ∈ {0, . . . ,|V|}，δ(s0, vk) = δ<sub>k</sub>(s, v)</li>
  <li>Claim 4：当 Bellman-Ford 算法结束时，d(s, v) = δ(s, v)</li>
</ul>

<p>运行时间：<code class="language-plaintext highlighter-rouge">O(|V||E|)</code></p>]]></content><author><name>syh</name><email>songibicf@gmail.com</email></author><category term="算法" /><summary type="html"><![CDATA[1. Negative Cycle Witness]]></summary></entry><entry><title type="html">加权最短路径</title><link href="http://localhost:4000/%E7%AE%97%E6%B3%95/2022/10/03/%E7%AE%97%E6%B3%95-0010.html" rel="alternate" type="text/html" title="加权最短路径" /><published>2022-10-03T00:00:00+08:00</published><updated>2022-10-03T00:00:00+08:00</updated><id>http://localhost:4000/%E7%AE%97%E6%B3%95/2022/10/03/%E7%AE%97%E6%B3%95-0010</id><content type="html" xml:base="http://localhost:4000/%E7%AE%97%E6%B3%95/2022/10/03/%E7%AE%97%E6%B3%95-0010.html"><![CDATA[<h3 id="1-加权图">1. 加权图</h3>

<p>review:</p>
<ul>
  <li>单源最短路径：BFS， O(|V| + |E|)</li>
  <li>单源可达性：BFS 或者 DFS，O(|E|) (因为只返回可以到达的顶点)</li>
  <li>连通性：Full-BFS 或者 Full-DFS, O(|V| + |E|)</li>
  <li>拓扑排序：Full-DFS, O(|V| + |E|)</li>
</ul>

<p>之前最短路径按照 distance = number of edges in path 来算，现在考虑加权图中的最短路径。</p>

<p>加权图：</p>
<ul>
  <li>带有权重函数 w 的图，例如给图中的每条边 e = (u, v) 分配一个整数权重 w(e) = w(u, v)</li>
  <li>加权图的应用：
    <ul>
      <li>道路交通中的距离</li>
      <li>网络连接中的延迟</li>
      <li>社交网络中的关系好坏程度</li>
    </ul>
  </li>
  <li>表示权重的两种方式：
    <ul>
      <li>直接在邻接表中存储权重</li>
      <li>或者存储一个 set 数据结构，把边映射到权重</li>
    </ul>
  </li>
</ul>

<p>加权路径：</p>
<ul>
  <li>一条路径的权重 w(π) 是路径中所有边的权重之和</li>
  <li>在加权图中，从 s 到 t 的加权最短路径是权重最小的路径</li>
</ul>

<p>加权最短路径算法：</p>

<div align="center">
<img src="/image/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95-0010-1.png" width="600" />
<p></p>
</div>

<h3 id="2-计算最短路径树">2. 计算最短路径树</h3>
<ul>
  <li>对于 BFS，在搜索时一直记录 parent。但是，也可以从每个顶点的最短距离计算出来。</li>
  <li>如果知道所有顶点 v 的 δ(s, v)， 可以用 <code class="language-plaintext highlighter-rouge">O(|V|+|E|)</code> 的时间创建出最短路径树</li>
</ul>

<p>使用 δ(s, v) 计算最短路径树，步骤如下：</p>
<ul>
  <li>初始化 P，设置 P(s) = None</li>
  <li>对于每个顶点 u，δ(s, u) 是有限的：
    <ul>
      <li>对于 u 的 outgoing neighbor v:</li>
      <li>如果 P(v) 没有被分配，并且 δ(s, v) = δ(s, u) + w(u, v)</li>
      <li>那么在 (u, v) 之间存在最短路径，设置 P(v) = u</li>
    </ul>
  </li>
  <li>父指针可能会遍历零权重的环路，标记在环中的所有顶点</li>
  <li>对于所有未标记的顶点 u
    <ul>
      <li>对于 u 的邻接点 v，且 v 已经被标记，并且 δ(s, v) = δ(s, u) + w(u, v)</li>
      <li>从 v 开始遍历父指针，取消标记该环中的顶点</li>
      <li>设置 P(v) = u, 打破环</li>
    </ul>
  </li>
</ul>

<p>该算法可以在线性时间内计算出最短路径树结点中的父指针。</p>

<h3 id="3-dag-relaxation">3. DAG Relaxation</h3>

<p>relaxation: 对于一个优化问题，要得到最优解， 可以从一个非最优解开始然后逐渐迭代来改进解，直到达到问题的最优解。</p>

<ul>
  <li>记录距离估计 d(s, v)，初始化为无穷大。该距离估计一定是真实距离 δ(s, v) 的上界，接下来需要逐步减少距离，直到 d(s, v) = δ(s, v)</li>
  <li>
    <p>什么时候降低 d(s, v)？在边违反<strong>三角不等式</strong>的时候</p>
  </li>
  <li>三角不等式：从 u 到 v 的最短路径权重不能大于从 u 经另一个顶点 x 到 v 的最短路径权重，即 δ(u, v) ≤ δ(u, x)+ δ(x, v) for all u, v, x ∈ V</li>
  <li>如果 d(s, v) &gt; d(s, u) + w(u, v)，违反了三角不等式</li>
  <li>fix 方法：降低 d(s, v) 为 d(s, u) + w(u, v)。</li>
</ul>

<p>可以证明最短路径估计 d(s, v) 永远不会小于真实的最短路径权重 δ(s, v)</p>
<ul>
  <li>Safety Lemma: 在 relax 过程中，d(s, v) 会一直大于等于 δ(s, v)</li>
  <li>证明：证明更强的声明，对于所有的 v，d(s, v) 在迭代时要么是无穷大，要么是 s 到 v 的<strong>某一条路径</strong>的权重，即 d(s, v) 会一直大于等于 δ(s, v)。
    <ul>
      <li>在初始的时候正确，d(s, v) 为无穷大</li>
      <li>假设在某一时刻声明为正确，relax 边 (u, v)。relax 边会让 d(s, v) 减少到 d(s, u) + w(u, v)，即 d(s, v) 变为从 s 出发，经过 u 到 v 路径的权重。</li>
    </ul>
  </li>
</ul>

<p>在 DAG 中，不存在环路，relaxation 最后一定会结束。按照拓扑顺序依次松弛出边，可以正确的计算出最短路径。该算法叫做 DAG Relaxation。</p>

<p>步骤：</p>
<ul>
  <li>设置 d(s, v) = ∞, d(s, s) = 0</li>
  <li>对于图 G 中的所有顶点，按照拓扑顺序处理每一个顶点 u
    <ul>
      <li>对于 u 的 outgoing neighbor v ∈ Adj<sup>+</sup>(u)</li>
      <li>如果 d(s, v) &gt; d(s, u) + w(u, v)</li>
      <li>设置 d(s, v) = d(s, u) + w(u, v)</li>
    </ul>
  </li>
</ul>

<p>运行时间：</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">O(|V| + |E|)</code></li>
</ul>]]></content><author><name>syh</name><email>songibicf@gmail.com</email></author><category term="算法" /><summary type="html"><![CDATA[1. 加权图]]></summary></entry><entry><title type="html">DFS</title><link href="http://localhost:4000/%E7%AE%97%E6%B3%95/2022/10/01/%E7%AE%97%E6%B3%95-0009.html" rel="alternate" type="text/html" title="DFS" /><published>2022-10-01T00:00:00+08:00</published><updated>2022-10-01T00:00:00+08:00</updated><id>http://localhost:4000/%E7%AE%97%E6%B3%95/2022/10/01/%E7%AE%97%E6%B3%95-0009</id><content type="html" xml:base="http://localhost:4000/%E7%AE%97%E6%B3%95/2022/10/01/%E7%AE%97%E6%B3%95-0009.html"><![CDATA[<h3 id="1-dfs">1. DFS</h3>

<p>BFS 用来解决单源最短路径问题，得到从一个顶点到其余所有顶点的最短路径，运行时间为 <code class="language-plaintext highlighter-rouge">O(|V| + |E|)</code></p>

<p>DFS:</p>
<ul>
  <li>解决单源可达性问题，而不是最短路径问题</li>
  <li>
    <p>return (not necessarily shortest) parent tree of parent pointers back to s</p>
  </li>
  <li>Idea: vist outgoing adjacencies recursively, but never revisit a vertex</li>
  <li>
    <p>i.e., 沿着一条路径前进，直到无法再前进，接着回溯，直到找到一条未探索过的路径。对于可以从 s 到达的任何顶点 v，DFS 都会访问 v 并正确设置 P(v)。一次 DFS 后，在图中未访问过的顶点上依次调用 DFS，即可遍历图中所有顶点。</p>
  </li>
  <li>P(s) = None, 接着 visit(s)</li>
  <li>visit(u):
    <ul>
      <li>对于 u 的所有未出现在 P 中的邻接点，设置 P(v) = u，递归调用 visit(v)</li>
    </ul>
  </li>
  <li>如果还有未访问到的顶点，在该顶点上再次调用 DFS</li>
</ul>

<p>运行时间 <code class="language-plaintext highlighter-rouge">O(|V| + |E|) </code></p>

<h3 id="2-拓扑排序">2. 拓扑排序</h3>

<ul>
  <li>DAG 图：有向无环图</li>
  <li>拓扑顺序：对顶点分配顺序 f，使得对于每条边 (u, v) ∈ E 满足 f(u) &lt; f(v)。</li>
  <li>DAG 图可以得到顶点的拓扑排序</li>
</ul>

<p>步骤：</p>
<ul>
  <li>Finishing Order 是 DFS <strong>完成访问顶点</strong>的顺序，即 visit(u) 结束的顺序</li>
  <li>Claim: 对于图 G，如果 G 是 DAG 图，finishing order 的翻转序列是拓扑排序</li>
  <li>Proof: 需要证明对于每条边 (u, v) ∈ E，u 排在 v 前面，DFS 先访问完 v。分成两种情况：
    <ul>
      <li>如果 u 在 v 前面访问：在访问 u 结束前，会访问 v，因此访问 v 先结束</li>
      <li>如果在 v 在 u 前面访问，由于图是无环图，从 v 不能到达 u，因此v 在 u 前面结束访问</li>
    </ul>
  </li>
</ul>

<h3 id="3-cycle-detection">3. Cycle Detection</h3>

<ul>
  <li>如果图 G 是无环的，DFS 可以找到拓扑顺序</li>
  <li>如果反向 finishing order 不是拓扑排序，那么图中一定存在环</li>
</ul>]]></content><author><name>syh</name><email>songibicf@gmail.com</email></author><category term="算法" /><summary type="html"><![CDATA[1. DFS]]></summary></entry><entry><title type="html">Binary Heaps</title><link href="http://localhost:4000/%E7%AE%97%E6%B3%95/2022/09/28/%E7%AE%97%E6%B3%95-0007.html" rel="alternate" type="text/html" title="Binary Heaps" /><published>2022-09-28T00:00:00+08:00</published><updated>2022-09-28T00:00:00+08:00</updated><id>http://localhost:4000/%E7%AE%97%E6%B3%95/2022/09/28/%E7%AE%97%E6%B3%95-0007</id><content type="html" xml:base="http://localhost:4000/%E7%AE%97%E6%B3%95/2022/09/28/%E7%AE%97%E6%B3%95-0007.html"><![CDATA[<h3 id="1-优先队列接口">1. 优先队列接口</h3>

<ul>
  <li>存储多个项，可以快速的访问、移除最重要的项，实际例子有：
    <ul>
      <li>有限带宽的路由器必须优先处理重要的信息</li>
      <li>操作系统内核中的进程调度</li>
      <li>离散事件模拟</li>
      <li>图算法</li>
    </ul>
  </li>
  <li>优先队列是按照优先级对项进行了排序，所以也可以看作 Set 接口</li>
  <li>对于特定集合操作进行了优化：
    <ul>
      <li>build(X)</li>
      <li>insert(x)</li>
      <li>delete_max()</li>
      <li>find_max()</li>
    </ul>
  </li>
  <li>关注 insert 和 delete_max 操作</li>
  <li>优先队列有多种实现方法，例如 array， sorted array， set AVL tree。</li>
</ul>

<h3 id="2-优先队列排序">2. 优先队列排序</h3>

<ul>
  <li>在任何的优先队列中，都可以按以下方法对 A 进行排序
    <ul>
      <li>build(A)，例如依次 insert 每一项</li>
      <li>然后重复 delete_max()</li>
    </ul>
  </li>
  <li>时间复杂度：T<sub>build</sub> + n * T<sub>delete_max</sub> = n * T<sub>insert</sub> + n * T<sub>delete_max</sub></li>
  <li>在以下的优先队列实现中，应用优先队列排序的时间复杂度如下图。并且在特定实现中，优先队列排序和一些排序算法很相似。</li>
</ul>

<div align="center">
<img src="/image/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95-0007-1.png" width="600" />
<p></p>
</div>

<h4 id="21-优先队列set-avl-tree">2.1 优先队列：Set AVL Tree</h4>

<ul>
  <li>Set AVL 树支持 insert(x), find_min(), find_max(), delete_min() 和 delete_max() 操作，并且时间复杂度全部为 O(logn)</li>
  <li>按照优先队列排序，时间复杂度为 O(nlogn)</li>
  <li>但是这个数据结构复杂，并且排序不是原位的</li>
</ul>

<h4 id="22-优先队列array">2.2 优先队列：Array</h4>

<ul>
  <li>在动态数组中以无序的方式存储元素</li>
  <li>insert(x)：O(1)</li>
  <li>delete_max(): 找到最大值，交换到末尾，并且移除</li>
  <li>insert 很快，但是 delete_max() 慢</li>
  <li>在 array 实现中进行优先队列排序，基本上和选择排序一样</li>
</ul>

<h4 id="23-优先队列sorted-array">2.3 优先队列：Sorted Array</h4>

<ul>
  <li>在有序的动态数组中存储元素</li>
  <li>insert(x)：把 x 放入末尾，并将 x 交换到合适的位置</li>
  <li>delete_max(x)：直接从末尾删除</li>
  <li>delete_max 快，但是 insert 慢</li>
  <li>在 sorted array 上进行优先队列排序，基本上就是插入排序</li>
</ul>

<h3 id="3-heap">3. heap</h3>

<p>那么，可以在以上的优先队列实现中找到一个平衡吗？既保持排序算法的<strong>低时间复杂度</strong>，又是<strong>原位排序</strong>算法。</p>

<p>idea：<strong>把数组看作一个完全二叉树</strong>，除了最后一层，完全二叉树在深度为 i 的层上都有 2^i 个结点。在最后一层上所有的结点都是左对齐的。</p>

<p>完全二叉树填充数组时，是按照<strong>层次遍历</strong>的顺序放入，从根到叶子结点，一层一层从左往右依次放入。这样，完全二叉树和数组建立了对应关系，完全二叉树不是由指针来确定结点关系，而是由数组中的位置来确定结点关系。</p>

<p>根结点在索引 0 处。结点 i 的左孩子在索引 2i+1 处，右孩子在索引 2i+2 处，父结点在 math.floor((i-1)/2) 处。</p>

<h4 id="31-binary-heaps">3.1 Binary Heaps</h4>

<p>idea：元素越大，在树中放置的高度越高。</p>

<p>最大堆属性：在结点 i 处，Q[i] &gt;= Q[j] for j ∈ {left(i), right(i)}</p>

<p><strong>最大堆</strong>：在所有结点上都满足最大堆属性的<strong>数组</strong></p>

<p>在最大堆中，可以证明对于结点 i，Q[i] &gt;= Q[j]，j 可以是子树中任一结点。</p>

<h4 id="32-heap-insert">3.2 Heap Insert</h4>

<ul>
  <li>把要插入的元素 x 放入数组的末尾，相当于插入到树的叶子结点中</li>
  <li>max_heapify_up(i): 为了维持最大堆属性，依次与父结点交换
    <ul>
      <li>检查是否 Q[parent(i)] &gt;= Q[i]</li>
      <li>如果不是，交换结点，递归执行 max_heapify_up(parent(i))</li>
    </ul>
  </li>
  <li>运行时间：树的高度 O(logn)</li>
</ul>

<h4 id="33-heap-delete-max">3.3 Heap Delete Max</h4>

<ul>
  <li>在数组中只能容易的移除最后的元素，但是最大项却在索引 0 的位置</li>
  <li>所以，把索引 0 的项和最后一项进行交换，并删除交换后的最后一项</li>
  <li>然后执行 max_heapify_down(i)：从上往下维持最大堆属性
    <ul>
      <li>检查是否 Q[i] &gt;= Q[j] for j ∈ {left(i), right(i)}</li>
      <li>如果不是，把 Q[i] 和 最大的孩子结点交换，并递归执行 max_heapify_down</li>
    </ul>
  </li>
  <li>运行时间：树的高度 O(logn)</li>
</ul>

<h4 id="34-heap-sort">3.4 Heap Sort</h4>

<p>堆排序时间复杂度为 O(nlogn)</p>

<p>线性时间内建堆：</p>
<ul>
  <li>假如是依次插入 n 个元素到堆中，那么得调用 max_heapify_up(i) n 次，每次都得经过整个树高，时间复杂度为 Ω(n lg n)</li>
  <li>idea: 把数组看作完全二叉树，从 n-1 到 0 依次调用 max_heapify_down(i)，调用时只用确保子树，时间复杂度为 O(n)</li>
</ul>]]></content><author><name>syh</name><email>songibicf@gmail.com</email></author><category term="算法" /><summary type="html"><![CDATA[1. 优先队列接口]]></summary></entry><entry><title type="html">BFS</title><link href="http://localhost:4000/%E7%AE%97%E6%B3%95/2022/09/28/%E7%AE%97%E6%B3%95-0008.html" rel="alternate" type="text/html" title="BFS" /><published>2022-09-28T00:00:00+08:00</published><updated>2022-09-28T00:00:00+08:00</updated><id>http://localhost:4000/%E7%AE%97%E6%B3%95/2022/09/28/%E7%AE%97%E6%B3%95-0008</id><content type="html" xml:base="http://localhost:4000/%E7%AE%97%E6%B3%95/2022/09/28/%E7%AE%97%E6%B3%95-0008.html"><![CDATA[<h3 id="1-graph">1. Graph</h3>

<p>图的应用例子：</p>
<ul>
  <li>任何网络系统，例如道路交通、计算机网络、社交网络</li>
  <li>任何离散系统的状态空间可以表示为图，例如 Chess、Teris、Rubik’s cube</li>
</ul>

<p><strong>图定义：</strong></p>
<ul>
  <li>G = (V, E)</li>
  <li>有向边由有序对表示，例如 (u, v)，无向边由无序对表示，例如 {u, v}</li>
  <li>简单图：
    <ul>
      <li>edges are distinct</li>
      <li>边连接不同的顶点</li>
      <li>|E| = O(|V|^2)</li>
    </ul>
  </li>
  <li>出边集：Adj<sup>+</sup>(u) = {v ∈ V | (u, v) ∈ E}</li>
  <li>入边集: Adj<sup>-</sup>(u) = {v ∈ V | (v, u) ∈ E}</li>
  <li>出度: deg<sup>+</sup>(u) = |Adj<sup>+</sup>(u)|</li>
  <li>入度: deg<sup>-</sup>(u) = |Adj<sup>-</sup>(u)|</li>
  <li>对于无向图 Adj<sup>-</sup>(u) = Adj<sup>+</sup>(u)， deg<sup>-</sup>(u) = deg<sup>+</sup>(u)</li>
</ul>

<p><strong>图的表示：</strong></p>
<ul>
  <li>对于图 G = (V, E)，存储 u 的所有出边 Adj(u)。</li>
  <li>使用 Set 来存储所有的顶点，可以使用直接访问数组或哈希表，size 为 Θ(|V|)</li>
  <li>对于每个顶点，为了存储邻接的顶点，使用数组或者链表。每个顶点邻接列表 size 为 Θ(deg(u))</li>
  <li>图存储需要 Θ(|V| + |E|) 空间</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># 图的直接访问数组表示
A1 = [
      [1, 4, 3],
      [0],
      [3],
      [0, 2],
      [0]
    ]

# 图的哈希表表示
A1 = {
      0: {1, 3, 4},
      1: {0},
      2: {3},
      3: {0, 2},
      4: {0}
    }
</code></pre></div></div>

<p><strong>路径：</strong></p>
<ul>
  <li>路径：顶点序列 p = (v1, v2, . . . , vk)，(vi, vi+1) ∈ E</li>
  <li>简单路径：没有重复顶点，或者说没有环的路径</li>
  <li>路径的长度：路径中的边数</li>
  <li>u 和 v 之间的距离：从 u 到 v 的最短路径的长度</li>
</ul>

<p><strong>图路径问题：</strong></p>
<ul>
  <li>single_pair_reachability(G, s, t): 从 s 到 t 有路径吗</li>
  <li>single_pair_shortest_path(G, s, t): 找到 s 到 t 的最短路径</li>
  <li>single_source_shortest_paths(G, s): 返回 s 到其它所有顶点的最短路径树</li>
</ul>

<p><strong>Shortest Paths Tree：</strong></p>
<ul>
  <li>得到从 s 到其他所有顶点的最短路径</li>
  <li>用 P(v) 代表从 s 到 v 顶点最短路径上的 v 的上一个顶点</li>
</ul>

<h3 id="2-bfs">2. BFS</h3>
<p><strong>BFS：</strong></p>
<ul>
  <li>对于 v ∈ V，如何计算 δ(s, v) 和 P(v)</li>
  <li>在一个集合数据类型中存储 δ(s, v) 和 P(v)，把 v 映射到距离和 P(v)</li>
  <li><strong>Idea:</strong> 按距离递增的顺序探索图结点</li>
  <li>Goal：计算所有的 Level sets L<sub>i</sub> = {v | v ∈ V and d(s, v) = i}</li>
  <li>Claim: L<sub>i</sub> 中每个顶点 v 一定与 L<sub>i-1</sub> 中的某个顶点 u 邻接，v ∈ Adj(u)</li>
  <li><strong>Invariant:</strong> δ(s, v) and P(v) have been computed correctly for all v in any L<sub>j</sub> for j &lt; i。对于当前层的顶点，上一层的顶点已经全部得到了最短的路径。</li>
</ul>

<p>BFS 按照层次顺序得到顶点 L<sub>i</sub>，且 L<sub>i</sub> 中的顶点是最短路径为 i 可以到达的顶点。</p>

<p><strong>BFS 步骤：</strong></p>
<ul>
  <li>base case (i=1): L0 = {s}, δ(s, s) = 0, P(s) = None</li>
  <li>Inductive Step: 为了计算 L<sub>i</sub>:
    <ul>
      <li>对于 L<sub>i-1</sub> 中每个顶点 u
        <ul>
          <li>对于每个顶点 v ∈ Adj(u)，并且 v 不出现在之前的层中，把 v 添加到 L<sub>i</sub>，设置 δ(s, v) = i，P(v) = u</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>重复计算 L<sub>i</sub>，直到 L<sub>i</sub> 不能再添加顶点</li>
  <li>对于剩余的顶点，设置 δ(s, v) = ∞</li>
</ul>

<p>BFS 的运行时间为 O(|V| + |E|)</p>]]></content><author><name>syh</name><email>songibicf@gmail.com</email></author><category term="算法" /><summary type="html"><![CDATA[1. Graph]]></summary></entry><entry><title type="html">测试</title><link href="http://localhost:4000/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0/2022/09/26/%E8%BD%AF%E4%BB%B6-0004.html" rel="alternate" type="text/html" title="测试" /><published>2022-09-26T00:00:00+08:00</published><updated>2022-09-26T00:00:00+08:00</updated><id>http://localhost:4000/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0/2022/09/26/%E8%BD%AF%E4%BB%B6-0004</id><content type="html" xml:base="http://localhost:4000/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0/2022/09/26/%E8%BD%AF%E4%BB%B6-0004.html"><![CDATA[<h3 id="1-validation">1. Validation</h3>

<p>测试是 Validation 的重要一步。验证的目的是发现程序中存在的问题。Validation 包括：</p>
<ul>
  <li>形式推理 (Formal reasoning)：通过推导，证明程序的正确性。</li>
  <li>代码审查 (Code review)：让其他人仔细阅读你的代码。</li>
  <li>测试 (Testing)：在精心选择的输入上验证程序的输出。</li>
</ul>

<p>即使进行了最好的验证，在软件上也很难实现最好的质量。典型的 residual defect rates:</p>
<ul>
  <li>1 - 10 defects/kloc: 典型的工业软件</li>
  <li>0.1 - 1 defects/kloc: 高质量验证的软件，例如成熟浏览器的 JavaScript 库</li>
  <li>0.01 - 0.1 defects/kloc: 最好的、安全关键的验证。例如航空领域软件</li>
</ul>

<p>软件测试中的有些方法是不可行的：</p>
<ul>
  <li>详尽测试</li>
  <li>Haphazard testing</li>
  <li>随机或者统计测试</li>
</ul>

<h3 id="2-test-first-编程">2. Test-first 编程</h3>

<ul>
  <li>module：软件系统的一部分，可以被设计、实现、测试、推理，并且该部分与系统的其他部分独立。该节主要关注的模块为函数，之后会关注 class</li>
  <li>specification：规范，描述模块的行为。</li>
  <li>一个模块通过实现 (implementation) 来提供功能，并且 clients 可以使用该模块。</li>
  <li>test case：测试用例，特定选择的输入，同时在 specification 中包含期望输出。</li>
  <li>test suite：测试用例集，一个模块测试用例的集合</li>
</ul>

<p>test-first programming: 在写代码前先写 spec 和 tests。例如写函数的步骤如下：</p>
<ol>
  <li>Spec：为函数写一个 specification</li>
  <li>Test：写与 specification 对应的测试</li>
  <li>Implement：写具体实现</li>
</ol>

<h3 id="3-系统测试">3. 系统测试</h3>

<p>系统测试：按照特定的方式选择测试例子，按以下三个属性设计 test suite：</p>
<ul>
  <li>Correct：correct test suite 是 specification 合法的 client，接受所有合法的实现。</li>
  <li>Thorough：一个彻底的 test suite 可以发现实现中实际的 bug</li>
  <li>Small：test suite 要尽可能的小</li>
</ul>

<h3 id="4-通过划分来选择测试用例">4. 通过划分来选择测试用例</h3>

<p>idea：函数的输入有非常多种，但是有些输入可能具有相似的特性，这些相似的输入中可以只选择一个输入作为测试用例。系统测试的方法就是把输入空间按照相似性进行划分。</p>

<p>把<strong>输入空间划分为子空间</strong>，每个子空间包含输入的一部分。所有的子空间合起来，构成了输入空间。对于测试来说，需要在每个子空间选择一个测试用例，作为该子空间的代表。</p>

<p>划分的要求：</p>
<ul>
  <li>所有的子空间合起来要涵盖输入空间</li>
  <li>子空间与子空间之间没有交集</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Example
/**
 * 
 * @param a  the argument whose absolute value is to be determinded
 * @returns  the absolute value of the argument.
 */
function abs(a: number): number 

// partition: a &gt;=0; a &lt; 0
// 可以选择 a = 17 和 a = -3 作为测试用例

/**
 * @param a  an argument
 * @param b  another argument
 * @returns  the larger of a and b
 */
function max(a:number, b:number): number

// partion: a&lt;b; a&gt;b; a=b
// 可以选择 (1, 2), (10, -8), (9, 9) 来测试
</code></pre></div></div>

<p>在划分中包含边界：</p>
<ul>
  <li>bug 通常出现在子空间的边界情况处，例如</li>
  <li>0 是正数和负数的边界</li>
  <li>Number.Max_SAFE_INTEGER 或者 Number.MAX_VALUE</li>
  <li>空集合</li>
  <li>序列的第一个元素或者最后一个元素</li>
</ul>

<p>为什么边界容易出问题：</p>
<ul>
  <li>容易犯 off-by-one 错误，例如错误使用 &lt;=, &lt;</li>
  <li>有可能边界情况需要作为特殊情况来处理</li>
  <li>边界可能是代码行为不连续的地方</li>
</ul>

<p>单个划分：使用多个不相交子空间的集合，来组成整个输入空间</p>

<p>使用多个划分：</p>
<ul>
  <li>对于有多个参数的函数，使用单个划分，有可能会有过多数目的子空间。每个参数有不同的划分和边界值，多个参数的子空间数目乘积会得到非常大的值</li>
  <li>因此可以使用多个划分，用 a 和 b 参数对输入空间进行独立划分。一个划分只考虑 a，另一个划分只考虑 b。选择特定的测试用例，使得一个测试用例尽可能满足多个参数划分的不同子空间，例如选择测试用例，使得其同时落在 a 划分的一个子空间中，以及 b 划分的一个子空间中。</li>
  <li>独立划分可能导致无法测试相交的部分，可以增加额外的分区来覆盖这一部分。</li>
</ul>

<p>单元测试：测试独立模块的测试，模块要尽可能的独立</p>

<p>编程语言对应的单元测试库：</p>
<ul>
  <li>Java：JUnit</li>
  <li>Python： unittest</li>
  <li>JavaScript：Mocha</li>
</ul>

<p>Mocha 单元测试例子：</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>describe("Math.max", function(){
    it("covers a&lt;b", function(){
        assert.strictEqual(Math.max(1, 2), 2);
    });

    it("covers a = b", function(){
        assert.strictEqual(Math.max(9, 9), 9);
    });

    it("covers a &gt; b", function(){
        assert.strictEqual(Math.max(10, -9), 10);
    });
})
</code></pre></div></div>

<h3 id="5-在文档中写上测试策略">5. 在文档中写上测试策略</h3>

<p>在创建测试用例集时，最好写上测试的策略：</p>
<ul>
  <li>partitions</li>
  <li>subdomains</li>
  <li>每个测试用例想要覆盖哪个子空间</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>describe("max", function(){
    /*
     * Testing strategy
     * 
     * partition:
     *     a &lt; b
     *     a &gt; b
     *     a = b
     */
    
    it(...); // test cases here
    it(...); 
    it(...);
    it("covers a&lt;b", function(){
        assert.strictEqual(Math.max(1, 2), 2);
    })
});
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>describe("multiplication", function(){
    /*
     * Testing strategy
     *
     * cover the cartesian product of these partitions:
     * partition on a: positive, negative, 0
     * partition on b: positive, negative, 0
     * partition on a: 1, !=1
     * partition on b: 1, !=1 
     * partition on a: small (fits in a TypeScript number), or large(doesn't fit)
     * partition on b: small, large
     *
     * cover the subdomains of these partitions:
     *    partition on signs of a and b:
     *        both positive
     *        both negative
     *        different signs
     *        one or both are 0
     */
     it(...);
})
</code></pre></div></div>

<h3 id="6-其余内容">6. 其余内容</h3>

<p><strong>黑盒测试和玻璃盒测试：</strong></p>

<p>黑盒测试：仅仅从 specification 中选择测试案例，不考虑函数的实现</p>

<p>玻璃盒测试：在直到函数如何实现的前提下来测试</p>

<p><strong>覆盖范围：</strong></p>

<p>评价测试套件：使用覆盖范围，即实际运行的代码数目</p>
<ul>
  <li>语句覆盖率：是否每个语句都由某个测试用例运行</li>
  <li>分支覆盖率：对于程序中 if 或 while 语句，是否测试了不同的分支</li>
  <li>路径覆盖率：是否测试了所有分支的不同组合</li>
</ul>

<p>测试的标准方法：逐步添加测试，直到测试套件达到足够的语句覆盖率</p>

<p>JavaScript 中的代码覆盖范围工具：Istanbul/nyc</p>

<p><strong>单元测试与集成测试：</strong></p>

<p>单元测试：测试独立模块的测试，模块应该尽可能的独立</p>

<p>集成测试：测试模块的组合，甚至整个程序</p>

<p><strong>自动化回归测试：</strong></p>

<p>自动测试：自动运行测试并且检查结果</p>

<p>回归测试：在每次改变代码后，运行所有的测试</p>

<p><strong>迭代开发的测试优先编程：</strong></p>

<p>测试步骤：</p>
<ul>
  <li>为函数编写<strong>规范</strong></li>
  <li>编写执行规范的<strong>测试</strong>。当发现问题是，修改规范和测试</li>
  <li>写函数的实现。当发现问题是，修改规划、测试和实现</li>
</ul>

<p>迭代开发：</p>
<ul>
  <li>对于大的规范，开始时仅仅写一部分规范，然后测试和实现，然后迭代更完整的规范</li>
  <li>对于复杂的测试用例集，首先选择几个重要的划分，创建小的测试用例集，然后在更多的划分上进行测试</li>
  <li>对于复杂的实现，可以先写一个蛮力算法的实现，用来测试规范和 test suite，然后继续进行复杂的实现</li>
</ul>

<p>对于现代的软件工程来说，迭代过程是必不可少的。迭代不是试图从头到尾完美的解决一个问题，<strong>迭代意味着尽快的找到一个粗略的解决方案，然后不断完善和改进它。</strong></p>

<h3 id="7-总结">7. 总结</h3>

<p>ideas:</p>

<ul>
  <li>测试优先编程</li>
  <li>使用划分和边界值进行系统测试，并且设计正确、彻底、小型的测试用例集</li>
  <li>白盒测试和语句覆盖率</li>
  <li>单元测试，自动回归测试</li>
  <li>迭代开发</li>
</ul>]]></content><author><name>syh</name><email>songibicf@gmail.com</email></author><category term="软件构造" /><summary type="html"><![CDATA[1. Validation]]></summary></entry></feed>