<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2022-09-21T23:14:46+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">syh 的博客</title><subtitle>记录计算机专业相关内容，Mens et Manus
</subtitle><author><name>syh</name><email>songibicf@gmail.com</email></author><entry><title type="html">二叉树 II</title><link href="http://localhost:4000/%E7%AE%97%E6%B3%95/2022/09/21/%E7%AE%97%E6%B3%95-0006.html" rel="alternate" type="text/html" title="二叉树 II" /><published>2022-09-21T00:00:00+08:00</published><updated>2022-09-21T00:00:00+08:00</updated><id>http://localhost:4000/%E7%AE%97%E6%B3%95/2022/09/21/%E7%AE%97%E6%B3%95-0006</id><content type="html" xml:base="http://localhost:4000/%E7%AE%97%E6%B3%95/2022/09/21/%E7%AE%97%E6%B3%95-0006.html"><![CDATA[<h3 id="1-平衡二叉树">1. 平衡二叉树</h3>

<p>之前提到二叉树目的是对于树高为 h 的树，使得算法的时间复杂度为 O(h), 并且尽可能维持 h = O(logn)，最终 O(h)=O(logn)。那么，如何维持树的高度 h = O(logn) ?</p>

<p><strong>平衡二叉树</strong>：在动态操作时，例如 insert(x), delete(x), 可以维持高度为 O(logn) 的二叉树。有许多平衡的范式 (Red-Black Trees, Splay Trees, 2-3 Trees,…)。最早提出的平衡范式为 AVL 树 (Adelson-Velsky and Landis, 1962)。</p>

<p>树的旋转：</p>
<ul>
  <li>目的：降低树的高度，但是不改变遍历顺序</li>
  <li>旋转操作只是修改了指针，时间复杂度为 O(1)</li>
</ul>

<div align="center">
<img src="/image/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95-0006-1.png" width="500" />
<p></p>
</div>

<p>旋转的特性：O(n) 次旋转可以将二叉树转换为具有相同遍历顺序的任何其他二叉树。</p>

<h3 id="2-avl-树">2. AVL 树</h3>

<ul>
  <li>AVL 树保持了 height-balance
    <ul>
      <li>一个结点叫做 height-balance，如果左子树和右子树的高度最多差 1</li>
      <li>一个结点的偏斜 (skew) 为其右子树的高度减去左子树的高度</li>
      <li>如果 skew 为 -1， 0， 1， 那么该结点是 height-balance</li>
    </ul>
  </li>
  <li>所有结点为 height-balance 的二叉树，其高度 h = O(log n)
    <ul>
      <li>高度为 h 二叉树的结点树 F(h) = 1 + F(h-1) + F(h-2) &gt;= 2F(h-2)</li>
    </ul>
  </li>
  <li>假设增加或者删除叶子结点，导致原先 height-balance 的树不平衡
    <ul>
      <li>那么仅叶子结点的祖先结点在高度或者 skew 上有改变</li>
      <li>高度最多改变 ±1, 所以 skew 的绝对值还是  ≤ 2</li>
      <li>修复的 idea: 从叶子结点开始，一直到根结点，依次修复，使得叶子结点的所有祖先结点 height-balance</li>
    </ul>
  </li>
</ul>

<h4 id="21-avl-树的-rebalance">2.1 AVL 树的 Rebalance</h4>

<p><strong>Local Rebalance</strong>：给定一个二叉树结点 B</p>
<ul>
  <li>假设其 skew 为 2</li>
  <li>B 子树中其他结点为 height-balanced</li>
  <li>那么，B 子树通过一次或者两次旋转操作可以变平衡</li>
</ul>

<hr />

<p><strong>证明</strong>：
因为 B 的 skew 为 2，那么 B 的右孩子结点一定存在，记为 F。</p>

<p><strong>Case 1</strong>: F 的 skew 为 0。</p>

<p><strong>Case 2</strong>: F 的 skew 为 1。</p>

<p>对于这两种情况，都是对 B 执行左旋操作。</p>

<div align="center">
<img src="/image/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95-0006-2.png" width="500" />
<p></p>
</div>

<p>假设 h = height(A), 那么原始状态下 height(G) = h+1, 情况 1 中 height(D) = h+1, 情况 2 中 height(D) = h。
旋转后，B 的 skew 在情况 1 为 1，情况 2 为 0，所以 B 是 height-balanced。旋转后，F 的 skew 为 -1，F height-balanced。</p>

<p><strong>Case 3</strong>：
F 的 skew 为 -1，那么得先对 F 执行右旋，再左旋。证明和上面类似。</p>

<div align="center">
<img src="/image/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95-0006-3.png" width="500" />
<p></p>
</div>

<hr />

<p><strong>Global Rebalance</strong>：对于 height-balanced 树 T，增加或者移除一个叶子结点，得到 T’。之后可以通过最多 O(logn) 次旋转，重新得到平衡二叉树 T’‘。</p>

<p><strong>证明</strong>：</p>
<ul>
  <li>仅叶子结点的祖先，高度受到了影响。且最多有 O(logn) 个祖先。</li>
  <li>把最低的受到影响的祖先记为 X</li>
  <li>如果 T 中是增加了一个叶子结点：
    <ul>
      <li>插入操作增加了 X 的高度，可以对 X 进行 local rebalance 操作</li>
      <li>在旋转后保持了平衡</li>
    </ul>
  </li>
  <li>如果 T 中移除了一个叶子结点
    <ul>
      <li>删除可能减少了 X 的一个孩子结点的高度，但是 X 的高度未受影响</li>
      <li>删除也可能导致 X 的高度减少 1，X 的父结点也可能不平衡</li>
      <li>所以得重新平衡 X 的祖先，但是最多 O(logn) 次</li>
    </ul>
  </li>
  <li>因此，O(logn) 次旋转操作可以变回平衡二叉树</li>
</ul>

<h3 id="3-计算高度">3. 计算高度</h3>

<p>如果判断结点 X 是否 height-balanced? 这需要知道子树的高度，因此要计算子树的高度。</p>

<p>方法：subtree augmentation</p>
<ul>
  <li>在结点处附加上<strong>子树高度</strong>的属性</li>
  <li>
    <p>X 结点的子树高度可以用 O(1) 时间计算出来</p>

    <p>h(X) = max( h(X.left), h(X.right) ) + 1</p>
  </li>
  <li>在动态操作时，也必须维持高度属性</li>
</ul>

<hr />

<p>Steps to Augment a Binary Tree:</p>
<ul>
  <li>为了在二叉树中增添子树属性 p，需要在每个结点处存储属性 p，并且可以用 O(1) 时间，从结点的孩子结点计算出属性值。</li>
  <li>那么，增加属性 p，不会改变动态操作的时间复杂度。</li>
</ul>]]></content><author><name>syh</name><email>songibicf@gmail.com</email></author><category term="算法" /><summary type="html"><![CDATA[1. 平衡二叉树]]></summary></entry><entry><title type="html">二叉树 I</title><link href="http://localhost:4000/%E7%AE%97%E6%B3%95/2022/09/16/%E7%AE%97%E6%B3%95-0005.html" rel="alternate" type="text/html" title="二叉树 I" /><published>2022-09-16T00:00:00+08:00</published><updated>2022-09-16T00:00:00+08:00</updated><id>http://localhost:4000/%E7%AE%97%E6%B3%95/2022/09/16/%E7%AE%97%E6%B3%95-0005</id><content type="html" xml:base="http://localhost:4000/%E7%AE%97%E6%B3%95/2022/09/16/%E7%AE%97%E6%B3%95-0005.html"><![CDATA[<h3 id="1-二叉树">1. 二叉树</h3>

<p>序列结构介绍了数组、链表、动态数组，操作的时间复杂度见上表。集合数据结构介绍了数组、有序数组、直接访问数组、hash 表。但是这些数据结构在某一项或者两项操作的时间复杂度占优势，无法兼顾全部操作的时间复杂度。而通过二叉树可以实现 “Goal” 一栏的时间复杂度。</p>

<p>二叉树是基于指针的数据结构，每个结点包含三个指针，分别为 node.parent, node.left, node.right。</p>

<p><strong>术语</strong>：</p>
<ul>
  <li>根：在树中如果某一结点没有父结点，那么该结点叫做树的根</li>
  <li>叶结点：没有孩子结点</li>
  <li>结点 x 的深度：从根结点到该结点的路径长度</li>
  <li>结点 x 的高度：以 x 为根的子树的最大深度</li>
</ul>

<p>为什么要使用树结构？</p>

<p>树结构也是也指针为基础的，每个结点包含三个指针。但是与链表不同，在链表中每访问一个结点都得从前往后开始遍历，时间复杂度为 O(n)。二叉树通过每个结点的 2 个分支，将树的高度最低可以降到 O(logn)。</p>

<p>因此，二叉树所有算法的基本 idea 为：对于树高为 h 的树，设计算法，使得操作的时间复杂度为 O(h), 并且尽可能维持 h = O(logn)，使得最后算法的时间复杂度为 O(h)=O(logn)</p>

<p>二叉树的遍历，如果按照中序遍历：</p>
<ul>
  <li>结点 x 左子树的结点在 x 之前</li>
  <li>结点 x 右子树的结点在 x 之后</li>
  <li>从根结点开始递归遍历</li>
</ul>

<h3 id="2-树的遍历">2. 树的遍历</h3>

<p>以下全部按中序遍历，介绍了遍历中结点出现的顺序。</p>

<p>以结点 x 为根的子树中<strong>第一个结点</strong>：</p>
<ul>
  <li>如果 x 有左孩子，递归返回左子树的第一个结点</li>
  <li>否则，x 是第一个结点，返回 x</li>
  <li>运行时间为 O(h)</li>
</ul>

<p>以结点 x 为根的子树中<strong>最后一个结点</strong>：</p>
<ul>
  <li>如果 x 有右孩子，递归返回右子树的最后一个结点</li>
  <li>否则，x 是最后一个结点，返回 x</li>
</ul>

<p>结点 x 的<strong>后继结点</strong>：</p>
<ul>
  <li>如果 x 有右子树，返回右子树第一个结点</li>
  <li>否则，返回 x 的最低祖先结点，且 x 要在该祖先结点的左子树中</li>
  <li>运行时间为 O(h)</li>
</ul>

<p>结点 x 的<strong>前驱结点</strong>：</p>
<ul>
  <li>如果 x 有左子树，返回左子树最后一个结点</li>
  <li>否则，返回 x 的最低祖先结点，x 要在该祖先结点的右子树中</li>
</ul>

<h3 id="3-动态操作">3. 动态操作</h3>

<p>在 x 结点之后<strong>插入</strong>新结点 y：</p>
<ul>
  <li>如果 x 没有右子树，把 y 放入 x 的右孩子结点</li>
  <li>否则，把 y 放入 x 后继结点 s 的左孩子结点中。s 一定没有左孩子，因为 s 是 x 右子树第一个结点。y 相当于放在 s 的前面。</li>
</ul>

<p><strong>删除</strong>结点 x：</p>
<ul>
  <li>如果 x 是叶子结点，直接删除</li>
  <li>否则，x 有孩子结点。此时不能直接删除 x，得与其他结点交换，让 x 变到叶子结点。
    <ul>
      <li>如果 x 有左孩子，让 x 与其<strong>前驱结点</strong>交换，递归删除 x 结点</li>
      <li>否则，让 x 与其<strong>后继结点</strong>交换，递归删除 x 结点</li>
    </ul>
  </li>
  <li>运行时间为 O(h)</li>
</ul>

<h3 id="4-应用">4. 应用</h3>

<h4 id="41-set">4.1 Set</h4>

<ul>
  <li>idea：集合中重要的是 <strong>find</strong> 操作，为了用树实现比较，常用的是二叉搜索树 (Binary Search Tree / BST)。
    <ul>
      <li>中序遍历得到的结果是按键排列好的</li>
      <li>等价的 BST 属性：对于每个结点，左子树中的值小于结点的值，右子树中的值大于结点的值。</li>
    </ul>
  </li>
  <li>在树中查找键值 k
    <ul>
      <li>如果 k 小于结点 x 的值，在左子树中递归查找</li>
      <li>如果 k 大于结点 x 的值，在右子树中递归查找</li>
      <li>否则，返回 x</li>
    </ul>
  </li>
</ul>

<h4 id="42-sequence">4.2 Sequence</h4>

<ul>
  <li>idea：使得中序遍历得到的顺序是按序列顺序排列的</li>
  <li>查找 i 结点的操作，调用 subtree_at(i)。但是需要从头开始进行中序遍历，时间复杂度为 O(n)。</li>
  <li>但是，如果可以用 O(1) 的时间复杂度得到子树的大小 (size)，访问 i 结点的操作时间复杂度可以降到 O(h)。子树大小指子树中结点的总个数。
    <ul>
      <li>首先检查左子树的大小 n<sub>L</sub>，并且与 i 比较</li>
      <li>如果 i &lt; n<sub>L</sub>，说明第 i 个结点在左子树，递归查找</li>
      <li>如果 i &gt; n<sub>L</sub>，在右子树上递归查找，且 i’ = i - n<sub>L</sub> - 1</li>
      <li>否则，i = n<sub>L</sub>，则根结点索引值为 i，返回根结点</li>
    </ul>
  </li>
  <li>通过扩增 (augmentation) 来记录每个结点子树的尺寸
    <ul>
      <li>在 node 中加入属性 node.size</li>
      <li>当加入一个新的叶子结点，对于该结点的所有祖先结点，size 都加 1</li>
      <li>当删除一个叶子结点，对于该结点的所有祖先结点，size 减少 1</li>
    </ul>
  </li>
  <li>subtree augmentation：
    <ul>
      <li>每个结点存储 O(1) 额外的属性</li>
      <li>subtree 的属性可以从其左子树和右子树的属性用 O(1) 时间计算出来</li>
      <li>无论对树进行什么修改操作，都得更新结点的属性</li>
      <li>可能的 subtree properties：sum，product，min，max，height</li>
      <li>不能作为 subtree properties：index，depth</li>
    </ul>
  </li>
</ul>

<p>时间复杂度：</p>
<div align="center">
<img src="/image/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95-0005-1.png" width="500" />
<p></p>
</div>]]></content><author><name>syh</name><email>songibicf@gmail.com</email></author><category term="算法" /><summary type="html"><![CDATA[1. 二叉树]]></summary></entry><entry><title type="html">环境配置</title><link href="http://localhost:4000/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0/2022/09/14/%E8%BD%AF%E4%BB%B6-0001.html" rel="alternate" type="text/html" title="环境配置" /><published>2022-09-14T00:00:00+08:00</published><updated>2022-09-14T00:00:00+08:00</updated><id>http://localhost:4000/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0/2022/09/14/%E8%BD%AF%E4%BB%B6-0001</id><content type="html" xml:base="http://localhost:4000/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0/2022/09/14/%E8%BD%AF%E4%BB%B6-0001.html"><![CDATA[<p>课程名称是 Software Construction，网站为：<a href="https://web.mit.edu/6.031/www/sp22/">https://web.mit.edu/6.031/www/sp22/</a>。课程用的是 JavaScript，开始先安装软件。全部在 WSL 下安装。</p>

<h3 id="1-安装-typescript">1. 安装 TypeScript</h3>
<h4 id="11-node">1.1 node</h4>

<p>按照说明安装</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>https://github.com/nodesource/distributions/blob/master/README.md
</code></pre></div></div>

<p>检查：</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>node --version
</code></pre></div></div>

<h4 id="12-install-typescript">1.2 install TypeScript</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo -H npm install -g typescript

# 检查
tsc --version
</code></pre></div></div>

<h3 id="2-git-配置">2. Git 配置</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># 用户名和邮箱
git config --global user.name "Your Name"
git config --global user.email email@email

# 设置 alias，以后输入 git lol 就可代替 log 后面的一串命令
git config --global alias.lol "log --graph --oneline --decorate --color --all"

# 列出目前的 config
git config --list
</code></pre></div></div>

<h4 id="21-git-基础概念">2.1 Git 基础概念</h4>

<p>Git 是一种版本控制系统 (version control system, VCS)。一些基础的概念：</p>
<ul>
  <li>存储库 (repository)：包含与项目相关所有文件的文件夹，以及对这些文件的整个提交历史。</li>
  <li>提交 (commit)：给定时间点时存储库中文件的快照。</li>
  <li>添加/暂存 (add/stage)：在对文件的更改可以提交到存储库之前，必须添加或暂存相关文件。</li>
  <li>克隆 (clone)：开发人员可以从 github 上 “克隆” 远程存储库，得到一份本地存储库。之后可以对本地存储库进行修改。</li>
  <li>push：将本地的 commit 发送到远程存储库中，相当于上传修改。</li>
  <li>pull：检查远程存储库的提交，并将远程存储库中的修改写入本地存储库，相当于得到最新版本。</li>
</ul>]]></content><author><name>syh</name><email>songibicf@gmail.com</email></author><category term="软件构造" /><summary type="html"><![CDATA[课程名称是 Software Construction，网站为：https://web.mit.edu/6.031/www/sp22/。课程用的是 JavaScript，开始先安装软件。全部在 WSL 下安装。]]></summary></entry><entry><title type="html">静态检查</title><link href="http://localhost:4000/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0/2022/09/14/%E8%BD%AF%E4%BB%B6-0002.html" rel="alternate" type="text/html" title="静态检查" /><published>2022-09-14T00:00:00+08:00</published><updated>2022-09-14T00:00:00+08:00</updated><id>http://localhost:4000/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0/2022/09/14/%E8%BD%AF%E4%BB%B6-0002</id><content type="html" xml:base="http://localhost:4000/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0/2022/09/14/%E8%BD%AF%E4%BB%B6-0002.html"><![CDATA[<h3 id="1-types">1. Types</h3>

<p>数据类型：值 + 操作</p>

<p>TypeScript 的几个内建类型：</p>
<ul>
  <li>number，表示整数和浮点数</li>
  <li>boolean</li>
  <li>string，表示字符序列</li>
</ul>

<p>Operation：有输入，并且产生输出的函数，syntax 包括：</p>
<ul>
  <li>operator</li>
  <li>function</li>
  <li>method</li>
  <li>property</li>
</ul>

<p>TypeScript 是静态类型语言，变量会被分配一个类型，在编译时进行类型检查，而且编译器可以推导出表达式的类型。JavaScript 和 Python 是动态类型语言，只有在运行时才可进行类型检查。</p>]]></content><author><name>syh</name><email>songibicf@gmail.com</email></author><category term="软件构造" /><summary type="html"><![CDATA[1. Types]]></summary></entry><entry><title type="html">线性排序</title><link href="http://localhost:4000/%E7%AE%97%E6%B3%95/2022/09/08/%E7%AE%97%E6%B3%95-0004.html" rel="alternate" type="text/html" title="线性排序" /><published>2022-09-08T00:00:00+08:00</published><updated>2022-09-08T00:00:00+08:00</updated><id>http://localhost:4000/%E7%AE%97%E6%B3%95/2022/09/08/%E7%AE%97%E6%B3%95-0004</id><content type="html" xml:base="http://localhost:4000/%E7%AE%97%E6%B3%95/2022/09/08/%E7%AE%97%E6%B3%95-0004.html"><![CDATA[<h3 id="1-比较排序的时间复杂度下界">1. 比较排序的时间复杂度下界</h3>

<p>之前通过 hash，可以用  Θ(n) 的空间，实现时间复杂度为 O(1) 的 find 操作。目前从前往后依次介绍了 Array、Sorted Array、Direct Access Array、Hash Table，那么能够实现快速的排序吗？</p>

<p><strong>决策树模型：</strong></p>

<ul>
  <li>决策树是二叉树，每个结点代表一次比较后的结果，叶子结点代表最终结果</li>
  <li>决策树的叶子节点数 L &gt;= 可能的输出结果数, 由于对长度为 n 的数组排序，输出结果数为 n!，因此 L &gt;= n!</li>
  <li>树高度下界可根据 L 得出，为 Ω(log L)，替换 L 为 n!，log(n!) = Ω(n log n)。因此树高度下界为  Ω(nlogn)，即所需比较次数最少为 Ω(nlogn)。</li>
</ul>

<p>时间复杂度为 O(nlogn) 的<strong>归并排序</strong>在比较模型中已经是最优的排序算法，如果需要更快的排序算法，就不能采用比较的方法。</p>

<h3 id="2-直接访问数组排序">2. 直接访问数组排序</h3>

<ul>
  <li>假设所有的键为独特的非负整数，范围为 {0,…,u-1}，且 n &lt;= u</li>
  <li>把每个项插入到直接访问数组中，时间复杂度为 Θ(n)</li>
  <li>按顺序读取数组中的值，时间复杂度为 Θ(u)</li>
  <li>直接访问数组排序的时间复杂度为 Θ(u)</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def direct_access_sort(A):
    "Sort A assuming items have distinct non-negative keys"
    u = 1 + max([x.key for x in A])
    D = [None] * u
    for x in A:
        D[x.key] = x
    i = 0
    for key in range(u):
        if D[key] is not None:
            A[i] = D[key]
            i += 1
</code></pre></div></div>

<p>直接访问数组排序的时间复杂度与 u 有关。如果 u = Θ(n)，那么排序的时间复杂度为 Θ(n)。如果 u = Ω(n^2)，排序的时间复杂度很高。而且，直接访问数组无法处理存在重复键的情况。</p>

<h4 id="21-u--ωn2-的情况">2.1 u = Ω(n^2) 的情况</h4>

<p>当 u 比 n 大很多时，为了降低排序的时间复杂度，可以采用如下方法：</p>
<ul>
  <li>对于每一个项的键 k 来说，用元组 (a, b) 来表示，k = an + b</li>
  <li>相当于 a = k // n，b = k % n</li>
  <li>接下来对元组进行排序</li>
</ul>

<p><strong>元组排序 (Tuple Sort)</strong></p>
<ul>
  <li>项的键为元组，例如 x.key = (x.k1, x.k2, x.k3, …)，k1 是最高有效位</li>
  <li>排序时对元组中的每个有效位依次排序，先排序最低有效位，最后排序最高有效位</li>
  <li>例如：[32, 03, 44, 42, 22] =&gt; [42, 22, 32, 03, 44] =&gt; [03, 22, 32, 42, 44]</li>
</ul>

<p>按上面的方法，对元组可以有效的排序，但是当存在相同元组项时，如何进行排序呢？</p>

<h4 id="22-计数排序-counting-sort">2.2. 计数排序 (Counting Sort)</h4>

<p>为了存储有重复键的项，可以采取一下方法：</p>

<ul>
  <li>在数组每个索引位置，不仅仅是存储一个元素，而是存储一个 chain，保持具有多个相同索引值的项</li>
  <li>为了排序稳定性，chain 中必须记录项的插入顺序，可以使用序列来维持插入顺序</li>
  <li>排序时，按顺序读出所有的 chains</li>
  <li>算法总的时间复杂度为 O(n+u)，当 u = O(n) 时，时间复杂度为 O(n)</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def counting_sort(A):
    "Sort A assuming items have non-negative keys"
    u = 1 + max([x.key for x in A])
    D = [[] for i in range(u)]
    for x in A:
        D[x.key].append(x)
    i = 0
    for chain in D:
        for x in chain:
            A[i] = x
            i += 1
</code></pre></div></div>

<h3 id="3-基数排序-radix-sort">3. 基数排序 (Radix Sort)</h3>

<p>现在把元组排序和计数排序组合起来，得到基数排序，得到比直接访问数组排序更好的排序方法。</p>

<ul>
  <li>如果 u &lt; n^2，使用计数排序来排序元组 (a, b)</li>
  <li>先对最低有效位 b 进行排序，接着对 a 进行排序</li>
  <li>对元组一个有效位排序时间复杂度为 O(n)，总时间复杂度为 O(2n) = O(n)</li>
</ul>

<p>如果 key &lt; n^c, 每个 key 最多可以分成长度为 c 的元组。接着对元组进行元组排序，时间复杂度为 O(cn) = O(n)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def radix_sort(A):
    "Sort A assuming items have non-negative keys"
    n = len(A)
    u = 1 + max([x.key for x in A])
    c = 1 + (u.bit_length() // n.bit_length())
    class Obj: pass
    D = [Obj() for a in A]
    for i in range(n):
        D[i].digits = []
        D[i].item = A[i]
        high = A[i].key
        for j in range(c):
            high, low  = divmod(high, n)
            D[i].digits.append(low)
    for i in range(c):
        for j in range(n):
            D[j].key = D[j].digits[i]
        counting_sort(D)
    for i in range(n):
        A[i] = D[i].item
</code></pre></div></div>

<p>排序算法的时间复杂度：</p>

<div align="center">
<img src="/image/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95-0004-1.png" width="500" />
<p></p>
</div>]]></content><author><name>syh</name><email>songibicf@gmail.com</email></author><category term="算法" /><summary type="html"><![CDATA[1. 比较排序的时间复杂度下界]]></summary></entry><entry><title type="html">Hashing</title><link href="http://localhost:4000/%E7%AE%97%E6%B3%95/2022/09/02/%E7%AE%97%E6%B3%95-0003.html" rel="alternate" type="text/html" title="Hashing" /><published>2022-09-02T00:00:00+08:00</published><updated>2022-09-02T00:00:00+08:00</updated><id>http://localhost:4000/%E7%AE%97%E6%B3%95/2022/09/02/%E7%AE%97%E6%B3%95-0003</id><content type="html" xml:base="http://localhost:4000/%E7%AE%97%E6%B3%95/2022/09/02/%E7%AE%97%E6%B3%95-0003.html"><![CDATA[<h3 id="1-比较模型">1. 比较模型</h3>

<div align="center">
<img src="/image/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95-0003-1.png" width="500" />
<p></p>
</div>

<p>在序列接口常用的操作中，普通的 Array 实现，时间复杂度都为 O(n)，这些操作都需要遍历整个数组。而 Sorted Array 由于在内部保持元素的有序性，在 find 操作上占优势。那么，可以实现更快的查找和动态操作吗，可以让 <strong>find 操作</strong>时间复杂度小于 O(log n)吗？</p>

<p><strong>比较模型：</strong></p>
<ul>
  <li>在该模型中，算法仅能通过比较来区分不同的元素</li>
  <li>可比较的项相当于一个黑盒，只能支持两个项之间的比较操作</li>
  <li>比较操作有：&lt;, &lt;=, &gt;, &gt;=, ==, !=</li>
  <li><strong>目标</strong>：在 n 个可比较项的集合上，实现 find(k) 操作</li>
  <li>比较的次数决定了运行时间的下界，因此，评估时间复杂度，要数比较操作的次数。</li>
</ul>

<p><strong>决策树：</strong></p>
<ul>
  <li>任何比较模型的 find 算法可以看作执行比较操作的决策树(decision tree)</li>
  <li>内部结点表示两个元素的比较，分支代表结果为 True 或 False</li>
  <li>叶子结点代表算法结束，产生算法的输出</li>
  <li>由根结点到叶子结点的路径表示在特定输出时算法所执行的操作</li>
  <li>对于每个算法的输出，都需要一个叶子结点，因此决策树最少有 n+1 个叶子结点。这 n+1 个叶子结点分别对应数组内的 n 个元素，以及数组内不包含要查找元素这个特殊情况。</li>
</ul>

<p><strong>注意：</strong>这里的目的是实现 find 操作，决策树也是对应的 find 操作，与算法导论第 8 章中的排序决策树有差别。</p>

<p>通过比较操作来查找某一元素的时间复杂度：</p>
<ul>
  <li>可以对比较操作进行计数，来确定时间复杂度的下界</li>
  <li>由于最少有 n+1 个叶子结点，因此，二叉树的最小高度为 Ω(log n)，运行时间的下界为 Ω(log n)</li>
</ul>

<p>如何实现更快的 find 操作？</p>

<h3 id="2-hashing">2. Hashing</h3>

<p>通过比较操作来查找元素，下界为 Ω(log n)，假如要实现更快的 find 操作，可以通过直接访问的方法。这有点类似于内存访问。</p>

<h3 id="21-直接访问数组-direct-access-arrays">2.1 直接访问数组 (Direct Access Arrays)</h3>

<p>假如要存储 n 个项，给每个项分配一个在 [0, u-1] 范围内的独特整数值，那么可以直接把这 n 个项存储在长度为 u 的直接访问数组中。数组中索引为 i 个位置存储的是分配到整数 i 的项。如果要查找该项，只要访问数组中索引 i 位置即可。</p>

<p>简单来说，直接访问数组是根据 x.key，直接放入与这个 key 一样的索引位置。就像在内存访问中，假如程序要访问 stack 中的一条数据，该数据有特定地址，这个地址就是数据的 key。程序访问内存中对应的地址，得到数据内容。</p>

<p>直接访问数组的 order 操作时间复杂度会高，因为项并不是依次分配整数值，在数组中一个位置可能不存在项，但之后的位置可能存在项。要查找下一个元素，必须依次往后面找。</p>

<p>直接访问数组的 find 操作时间复杂度取决于 n 和 u 的关系。当 u » n，不会发生冲突，但是数组中存在空间的浪费。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class DirectAccressArray:
    def __init__(self, u):   self.A  =[None] * u   # 初始化空间为 u 的数组
    def find(self, k):       return self.A[k]      # 查找索引为 k 的项
    def insert(self, x):     self.A[x.key] = x     # 按 key 存入项
    def delete(self, k):     self.A[k] = None      # 删除索引为 k 的项
    def find_next(self, k):
        for i in range(k, len(self.A)):   # 从索引 k 开始依次往后找
            if A[i] is not None:
                return A[i]
    def find_max(self):                   # 从后往前找
        for i in range(len(self.A)-1, -1, -1):
            if A[i] is not None:
                return A[i]
    def delete_max(self):
        for i in range(len(self.A)-1, -1, -1):
            x = A[i]
            if x is not None:
                A[i] = None
                return x
</code></pre></div></div>

<h3 id="22-hashing">2.2 hashing</h3>

<p>直接访问数组可以 O(1) 时间复杂度实现 find，insert，delete操作，但是前提是 u » n。当 n « u 时，如何用 O(n) 空间来实现直接访问数组呢？哈希主要解决的就是直接访问数组的空间占用大问题，hashing 相比于直接访问数据，添加了映射过程。</p>

<p>可以把 n 项存储在一个小空间的数组中，数组的尺寸不为 u，而是 m = O(n)。给项分配整数值后也不能直接存入数组，得通过映射过程，把 [0, u-1] 范围内的值映射到 [0, m-1]。这样的映射函数叫做 hash 函数。</p>

<ul>
  <li>通过 hash 函数，把项映射到数组中特定的位置</li>
  <li>hash 函数：h(k) : {0, . . . , u − 1} → {0, . . . , m − 1}
    <ul>
      <li>u 是所有项可能的取值，m 是数组的尺寸</li>
    </ul>
  </li>
  <li>长度比项所有可能取值 u 更小的直接访问数组，叫做 hash 表，空间为 m。</li>
  <li>如果两个元素a，b，h(a) = h(b)，那么发生了冲突。
    <ul>
      <li>要么通过开放寻址来解决，存储在数组中的其他位置</li>
      <li>要么通过链接来解决，把具有相同的 hash 值元素存储在一块，然后链接到索引位置。</li>
    </ul>
  </li>
</ul>

<h3 id="23-hash-函数">2.3 hash 函数</h3>

<p>最简单的 hash 函数： h(k) = (k mod m)</p>
<ul>
  <li>当所有的 key 是均匀分布时，可以有好的效果</li>
  <li>m 一般选大的质数</li>
</ul>

<p>通用 hash 函数： hab(k) = (((ak + b) mod p) mod m)</p>
<ul>
  <li>a, b ∈ {0, . . . , p − 1} and a 不为 0</li>
  <li>在多个 hash 函数中，随机选择 a，b，确定一个 hash 函数</li>
  <li>可以达到更短的链长度，即冲突少。m = Ω(n) 时，在每个索引位置的链长度期望值为 O(1)</li>
</ul>

<div align="center">
<img src="/image/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95-0003-2.png" width="600" />
<p></p>
</div>

<p>表中 Direct Access Array 的 u 代表 key 的最大取值；Hash Table 中的下标 e 代表是期望值，a 代表摊还分析 (amortized)</p>]]></content><author><name>syh</name><email>songibicf@gmail.com</email></author><category term="算法" /><summary type="html"><![CDATA[1. 比较模型]]></summary></entry><entry><title type="html">操作系统</title><link href="http://localhost:4000/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/2022/08/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90-0004.html" rel="alternate" type="text/html" title="操作系统" /><published>2022-08-17T00:00:00+08:00</published><updated>2022-08-17T00:00:00+08:00</updated><id>http://localhost:4000/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/2022/08/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90-0004</id><content type="html" xml:base="http://localhost:4000/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/2022/08/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90-0004.html"><![CDATA[<h3 id="1-简介">1. 简介</h3>

<div align="center">
<img src="/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90-0004-1.png" width="600" />
<p></p>
</div>

<p>操作系统提供一个易于使用的物理资源的抽象。</p>

<p>context switch:</p>

<p>为了实现多个任务的并行运行，操作系统会控制某一程序使用 CPU 的时间，并且在时间到后切换到另一个程序。程序切换时，程序的运行状态必须保存，该过程通过操作系统来控制。context switch 即指从一个执行的程序切换到另一个程序的过程。该过程如下：</p>

<ol>
  <li>OS 中断当前的进程，控制 CPU</li>
  <li>保存当前进程的状态</li>
  <li>加载下一个进程的状态</li>
  <li>将 CPU 移交给下个进程</li>
</ol>

<p>通过 context switch，不同进程可以在共享的硬件上运行，并且不同进程之间是孤立的。</p>

<p>硬件通常提供两种运行模式，为内核模式和用户模式。在用户模式下，特定的操作被禁止，用户模式下的程序需要通过系统调用来运行一些功能，例如创建删除文件、访问外部设备等。</p>

<h3 id="2-中断和异常">2. 中断和异常</h3>

<p>中断：</p>
<ul>
  <li>由当前运行程序之外的事件引发</li>
  <li>不需要立即处理，但是应该尽快处理</li>
</ul>

<p>异常：</p>
<ul>
  <li>在执行当前程序时遇到的事件引发</li>
  <li>必须立即处理</li>
</ul>

<p>中断和异常通过 trap handler 来处理。陷阱处理程序的流程：</p>

<ol>
  <li>保存当前程序的状态</li>
  <li>决定造成异常或者中断的原因</li>
  <li>处理中断或者异常，处理后要么继续运行程序，要么中断程序</li>
</ol>

<h3 id="3-内核">3. 内核</h3>

<p>内核是操作系统的核心，可以对资源进行管理，例如程序调度、内存管理、I/O 管理。</p>

<p>电脑启动的流程：</p>
<ol>
  <li>BIOS 运行
    <ul>
      <li>执行 POST</li>
      <li>BIOS 找到并且执行 bootloader</li>
    </ul>
  </li>
  <li>bootloader 加载 OS</li>
  <li>OS 初始化服务</li>
  <li>运行进程</li>
</ol>

<h3 id="4-虚拟内存">4. 虚拟内存</h3>

<p>直接使用物理内存所遇到的问题：</p>
<ol>
  <li>没有足够的空间</li>
  <li>可能存在空间的浪费</li>
  <li>无法提供进程之间的隔离</li>
</ol>

<p>这些问题通过虚拟内存来解决，虚拟内存把程序的地址映射到内存地址。</p>

<div align="center">
<img src="/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90-0004-2.png" width="600" />
<p></p>
</div>

<p>如果没有虚拟内存，程序可以直接访问内存地址空间，对程序的内存访问无法进行任何管理。虚拟内存把程序的地址空间和内存地址空间隔离开来，程序地址需要通过映射过程，映射到实际的内存地址，同时有一部分程序地址会映射到磁盘中。</p>

<p>解决的问题：</p>
<ol>
  <li>映射一部分地址到磁盘中，解决空间不够的问题</li>
  <li>由于增加了映射过程，程序看见的地址空间是连续的，但映射到内存中，可以分段放在内存中任意位置。</li>
  <li>程序 a 和程序 b的地址映射到不同的内存地址，程序之间无法访问对方的地址空间。如果需要共享数据，例如库，那么虚拟内存可以把两个程序的地址映射到同一块内存地址，方便实现共享。</li>
</ol>

<p>虚拟内存把地址分成：</p>
<ul>
  <li>虚拟地址 (Virtual Address, VA)，这是程序看见的地址</li>
  <li>物理地址 (Physical Address, PA)，对应的是 RAM 中实际地址</li>
</ul>

<p>地址翻译过程：</p>
<ol>
  <li>程序指定一个虚拟地址，假设执行的是读取指令</li>
  <li>计算机把该虚拟地址转换成对应的物理地址</li>
  <li>如果物理地址不在内存中，OS 从磁盘中加载数据</li>
  <li>计算机读取物理地址中的数据，把数据返回给程序</li>
</ol>

<p>记录 VA 和 PA 对应关系的为页表 (page table)。但是如果页表中保存每一个虚拟地址的映射，那么页表会非常大，因此，页表中是对内存块 (chunks) 进行映射。页表中把虚拟地址中的一块映射到物理地址中的一块。目前，块大小通常是 4KB。</p>

<h3 id="5-io">5. IO</h3>

<p>内存中的一部分专门用于与 I/O 设备通信，该区域中的地址对应不同的 I/O 设备。当 CPU 想要给某个设备发送信息，在对应位置“写入”数据，硬件会中断写入过程，把数据发送到对应的设备。</p>

<p>CPU 会周期性的检查状态寄存器，看是否有任何需要接收的数据，该过程叫做轮询。通常发生在上下文交换的过程中，每几毫秒就会切换进程，每次切换时，OS 会检查 I/O 设备。</p>]]></content><author><name>syh</name><email>songibicf@gmail.com</email></author><category term="计算机组成" /><summary type="html"><![CDATA[1. 简介]]></summary></entry><entry><title type="html">并行</title><link href="http://localhost:4000/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/2022/08/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90-0003.html" rel="alternate" type="text/html" title="并行" /><published>2022-08-16T00:00:00+08:00</published><updated>2022-08-16T00:00:00+08:00</updated><id>http://localhost:4000/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/2022/08/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90-0003</id><content type="html" xml:base="http://localhost:4000/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/2022/08/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90-0003.html"><![CDATA[<h3 id="1-并行的原因">1. 并行的原因</h3>

<p>为什么要并行化？</p>
<ul>
  <li>由于技术和经济原因，CPU 的时钟频率不再增加</li>
  <li>只有通过并行处理，才能达到更快的处理速度</li>
</ul>

<p>并行化的两种基本方法：</p>
<ul>
  <li>Multiprogramming
    <ul>
      <li>并行运行多个独立的程序</li>
    </ul>
  </li>
  <li>Parallel computing
    <ul>
      <li>并行计算，更快的运行一个程序</li>
    </ul>
  </li>
</ul>

<h3 id="2-并行方法">2. 并行方法</h3>

<div align="center">
<img src="/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90-0003-1.png" width="200" />
</div>

<p>Single-Instruction/Multiple-Data Stream (SIMD):
SIMD 使用单条指令流来处理多条数据流，例如 Intel SIMD 指令集扩展或者 Nvidia GPU。</p>

<div align="center">
<img src="/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90-0003-2.png" width="200" />
</div>

<p>Multi-Instruction/Multiple-Data Stream (MIMD):
MIMD 使用多个处理器在不同的数据上执行不同的指令，MIMD 架构包括多个核心。</p>

<p>SIMD 和 MIMD 是目前最常用的并行化方法，例如 SSE 指令是单指令多数据，在 Xeon 中使用了 MIMD。</p>

<p>最常用的并行化编程方法：</p>
<ul>
  <li>单个程序运行在所有的处理器上</li>
  <li>使用同步原语来实现跨处理器的同步</li>
</ul>

<h3 id="3-simd">3. SIMD</h3>

<div align="center">
<img src="/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90-0003-3.png" width="500" />
</div>

<p>SIMD 中的一条指令可以完成多个数据的操作。正如上图所示，一条加法指令可以完成 8 组数据的相加。SIMD 在 x86、ARM、RISC-V 架构中都有实现。</p>

<p>Intel cpu 的 SIMD 功能可以通过 intrinsic functions 来进行调用。这些函数直接对应于特定的汇编指令，但是可以用 c 语言来写。</p>

<p>函数命名规则：https://www.intel.com/content/www/us/en/develop/documentation/cpp-compiler-developer-guide-and-reference/top/compiler-reference/intrinsics/naming-and-usage-syntax.html</p>

<p>长度为 128 位的数据可以指定的类型：</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>__m128    四个 float 类型
__m128d   两个 double 类型
__m128i   整数
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 例子
// 使用 _mm_setr 函数来设置 128 数据的值
__m128i values = _mm_setr_epi32(0x1234, 0x2345, 0x3456, 0x4567);

// 使用 _mm_extract_epi32(values, i)来提取值
int first_value = _mm_extract_epi32(values, 0);
int second_value = _mm_extract_epi32(values, 1);

// 存储值到内存中
int arrayA[4];
_mm_storeu_si128((_m128i*)arrayA, values);

// 从内存中加载值
int arrayB[4] = {10, 20, 30, 40};
values = _mm_loadu_si128((__m128i*) arrayB);
</code></pre></div></div>

<h3 id="4-mimd">4. MIMD</h3>

<p>MIMD 中使用了多个处理器。每个处理器有自己的 PC，并且执行独立的指令流。不同的处理器可以访问相同的内存空间。</p>

<p>使用多个处理器的两种方式：</p>
<ol>
  <li>对于不同的 job，通过 job-level 的并行，实现高吞吐量。</li>
  <li>在多处理器上运行单个程序，把这个程序分割成不同处理器上运行的子任务 (线程)，实现并行处理。</li>
</ol>

<p>线程是指执行某些任务的顺序指令流，每个线程都有自己的PC、寄存器并访问进程的共享内存。每个处理器的 core 提供一个或多个硬件线程来实际执行某一线程的指令。常见的 Intel 芯片每个 core 提供 2 线程。</p>

<p>操作系统将多个线程多路复用到可用的硬件线程。操作系统通过<strong>时分复用</strong>将软件线程分配到硬件线程上，以在特定的处理器上同时执行非常多的任务。时分复用是指把时间分成不同的时间间隔，任一线程只能执行几个时间间隔。当该线程时间耗尽或者阻塞时，操作系统中断该线程，把 context，包括寄存器、PC 存入内存中，并且操作系统会运行另一个线程。</p>

<h4 id="41-openmp-并行编程">4.1 OpenMP 并行编程</h4>

<p>OpenMP 是用于多线程并行编程的语言扩展。其编程模型如下图所示。</p>

<div align="center">
<img src="/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90-0003-4.png" width="400" />
</div>

<p>开始是单个线程，master thread，并且为顺序执行，直到遇到 parallel region。在并行区主线程会创建多个并行线程，每个线程会执行并行区的语句，直到所有线程全部完成，此时会进行 JOIN，只留下主线程。</p>

<p>数据竞争 (data race)：并行编程中常见的问题。如果多个线程尝试访问相同的内存位置，并且至少有一个线程进行写操作，那么有可能形成数据竞争。此时程序运行的结果不确定，需要通过同步指令来明确访问顺序，以产生确定的结果。主要通过锁来控制线程对关键部分的访问，使得一次只能有一个线程进行操作。</p>

<h3 id="5-smp">5. SMP</h3>

<div align="center">
<img src="/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90-0003-5.png" width="400" />
</div>

<p>SMP 指的对称多处理机 (Symmetric Multiprocessor)，满足以下条件：</p>
<ul>
  <li>包含两个或者多个相同的 CPUs/Cores</li>
  <li>单个的共享内存</li>
</ul>

<p>所有的处理器共享同一个物理地址空间。处理器之间通过内存里共享的变量进行通信，共享数据必须通过同步原语来访问。</p>

<h4 id="51-多处理器中的-cache">5.1 多处理器中的 cache</h4>

<div align="center">
<img src="/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90-0003-6.png" width="400" />
</div>

<p>即使只有一个处理器，内存也是性能瓶颈，因此使用 cache 来减少对内存访问的带宽需求。每个 core 有自己的私有 cache，只有当 cache miss 时才需要访问内存。</p>

<p>多处理器中要处理 cache 中数据一致性问题。总线上的两个 CPU 都读取相同的数据； 每个处理器都获得数据的副本并将其存储在他们的 cache 中。假如一个 CPU 执行了一次写操作，该 CPU 的 cache 是最新的，但是其他处理器的 cache 中存有过时的数据。因此要确保一个 CPU 改变了数据，别的 CPU 数据也应该进行更新。</p>

<p>解决方案：追踪 block 的状态。每个 cache 使用 valid bit、dirty bit、shared bit 追踪存储的每个块的状态，状态包含：</p>

<ol>
  <li><strong>Shared</strong>: up-to-date data, other caches may have a copy (Valid Bit set, shared bit set)</li>
  <li><strong>Modified</strong>: up-to-date data, <strong>changed (dirty)</strong>, no other cache has a copy, OK to write, memory out-of-date (Valid and Dirty bit is set)</li>
  <li><strong>Exclusive</strong>: up-to-date data, no other cache has a copy, OK to write, memory up-to-date</li>
  <li><strong>Owner</strong>: up-to-date data, other caches may have a copy (they must be in Shared state), memory is not up-to-date</li>
</ol>

<p>该 cache coherency protocol 叫做 MOESI。</p>]]></content><author><name>syh</name><email>songibicf@gmail.com</email></author><category term="计算机组成" /><summary type="html"><![CDATA[1. 并行的原因]]></summary></entry><entry><title type="html">存储器层次结构</title><link href="http://localhost:4000/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/2022/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90-0002.html" rel="alternate" type="text/html" title="存储器层次结构" /><published>2022-07-26T00:00:00+08:00</published><updated>2022-07-26T00:00:00+08:00</updated><id>http://localhost:4000/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/2022/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90-0002</id><content type="html" xml:base="http://localhost:4000/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/2022/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90-0002.html"><![CDATA[<h3 id="1-为什么采用存储器层次结构">1. 为什么采用存储器层次结构</h3>

<div align="center">
<img src="/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90-0002-1.png" width="400" />
</div>

<p>计算机包含几个部分：</p>
<ul>
  <li>处理器，又分为控制器和数据通路，从内存中读取指令和数据，执行运算，并把结果保存到寄存器或者写回内存中。</li>
  <li>存储器，内存中包含程序的机器码和数据</li>
  <li>输入设备</li>
  <li>输出设备</li>
</ul>

<p>计算机的运行时离不开数据的读取和写入操作。由于存储程序概念，指令和数据均以数字的形式存储与存储器中，处理器的要不停的从存储器中读取指令和数据。</p>

<div align="center">
<img src="/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90-0002-2.png" width="600" />
</div>

<p>处理器的执行速度和内存 (DRAM) 的读写速度比较如上图所示。在 1980 年，处理器执行一条指令的时间和内存访问的速度差不多，存储器的访问速度并不会拖慢计算机的运行。但是处理器性能以每年 55% 的速度飞速增长，而 DRAM 的性能增速却只有 7%，两者的差距越来越大。以至于 DRAM 访问一条指令，处理器可以执行 1000 多条指令。</p>

<p>这巨大的速度差异如何来弥补？总不能让处理器每执行一条指令就停止，等 DRAM 中下一条指令的到来，如果有一个速度更快的存储器就好了。</p>

<p>这就要提到存储器有两个相互矛盾的属性，一个是容量，一个是访问速度。存储器一般容量大，速度就会慢，例如 <strong>DRAM</strong>。存储器速度快，容量就会小，例如 <strong>SRAM</strong>，一般只有几兆，而访问速度最快的<strong>寄存器</strong>在 RISC-V 中只有 32 个。</p>

<p>单纯使用 DRAM 或者 SRAM 都无法达到好的效果，处理器需要的是一个访问速度快，存储容量大的存储器。存储器的层次结构就是为了构建这样一个虚拟的存储器。这个虚拟的存储器的内部结构不需要处理器知道，处理器只需要正常的访问，就好像在访问一个速度快，容量大的存储器。</p>

<h3 id="2-存储器层次结构的原理">2. 存储器层次结构的原理</h3>

<p>为什么把不同性能的存储器结合起来可以抽象出一个速度快，容量大的存储器？原理可以用图书馆例子来形象的说明。假如你需要在图书馆查找些书籍来完成一篇报告，可能有以下过程：</p>

<ol>
  <li>在书架上找到书籍，拿到了图书馆的书桌上。通过翻阅书籍，找到需要的信息。</li>
  <li>如果需要别的书籍，去书架上拿，再次放到书桌上。书桌上一直保存着你查找过的书籍。</li>
</ol>

<p>图书馆相当于内存，容量大，但是查找速度慢。书桌相当于 cache，容量小，但是可以很快的找到你要的书籍。并且在书桌上一直保存查找过的书籍，当再次需要这本书的时候，直接拿起就行。图书馆和书桌构成了一个虚拟的访问速度快，容量大的图书馆。</p>

<p>存储器也是这样，cache 中存放了内存中之前取得的一部分数据以及该数据周围的一些数据，当处理器再次需要这些数据或者周围的数据时，可以直接从 cache 中读取。cache 一般集成在 CPU 内部，保留的数据为内存中一部分数据的复制。大多数的处理器都有单独的指令 cache 和数据 cache。</p>

<div align="center">
<img src="/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90-0002-3.png" width="300" />
</div>

<p>存储器的层次结构由以上 4 部分组成，包含寄存器、cache、内存、磁盘。如果存储器越靠近处理器，那么存储器就会更小、更快、更昂贵。最低等级的存储器，一般是磁盘，包含了所有的数据。存储器的层次结构抽象出一个容量大、访问速度快的存储器。</p>

<p>具体的来说，存储器层次结构利用的是局部性原理，包含：</p>

<ul>
  <li>时间局部性：如果现在使用了某一数据，不久有可能还要使用这一数据
    <ul>
      <li>可以在 cache 中保持最近使用过的数据</li>
    </ul>
  </li>
  <li>空间局部性：如果使用了存储器中的一条数据，不久有可能使用与这条数据相邻的数据
    <ul>
      <li>按 block 移动数据，而不只是移动一条数据</li>
    </ul>
  </li>
</ul>

<p>添加 cache 之后，计算机结构如下图所示：</p>

<div align="center">
<img src="/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90-0002-4.png" width="400" />
</div>
<h3 id="3-访问存储器的流程">3. 访问存储器的流程</h3>

<p>以 <code class="language-plaintext highlighter-rouge">lw t0 0(t1)</code> 指令为例，假设 t1 寄存器中包含的地址为 0x12F0，内存中相应的值为 99。</p>

<p>假如没有 cache，访问流程如下：</p>

<ol>
  <li>处理器将地址 0x12F0 发送给内存</li>
  <li>内存读取地址 0x12F0 中的值 99</li>
  <li>内存发送 99 到处理器</li>
  <li>处理器把 99 放入寄存器 t0 中</li>
</ol>

<p>假如有 cache，访问流程如下：</p>

<ol>
  <li>处理器将地址 0x12F0 发送给 cache</li>
  <li>cache 检查是否包含该地址中的数据
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  (1) 如果包含，cache 读取 99，发送给处理器
  (2) 如果不包含 (Miss)，cache 将地址 0x12F0 发送到内存
      a. 内存读取地址 0x12F0 中的值 99
      b. 内存将 99 发送给 cache
      c. cache 将地址 0x12F0 和 99 存储起来
      d. cache 将 99 发送给处理器
</code></pre></div>    </div>
  </li>
  <li>处理器把 99 放入寄存器 t0 中</li>
</ol>

<p><strong>cache hit</strong>：表示要查找的数据在 cache 中，可以直接在 cache 中读取出数据传入处理器中。</p>

<p><strong>cache miss</strong>：表示要查找的数据不在 cache 中，需要在内存中找到数据，并且把该数据放入 cache 中，然后才可以传入处理器。</p>

<h3 id="4-cache-中的数据存储方式">4. cache 中的数据存储方式</h3>

<p>cache 中存储方式有三种：</p>
<ol>
  <li>全相联 (Fully Associative)</li>
  <li>直接映射 (Direct Mapped)</li>
  <li>组相联 (Set-Associative)</li>
</ol>

<h4 id="41-全相联-cache">4.1 全相联 cache</h4>

<div align="center">
<img src="/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90-0002-5.png" width="400" />
</div>

<p>正如名称中 associate 的含义，全相联中把地址和数据存储在 cache 的一个行中。cache 中包含有效位、标签位、数据位等。</p>

<p><strong>cache line / block：</strong></p>
<ul>
  <li>利用局部性原理，cache 中存储的是 block，即一块数据。在 cache 中这一个块存储在一行中，因此也叫做 cache line。</li>
  <li>典型的 cache line / block 为 64 字节，可以充分利用空间局部性</li>
</ul>

<p><strong>line size / block size:</strong></p>
<ul>
  <li>每个 cache line 中的字节数</li>
</ul>

<p><strong>容量：</strong></p>
<ul>
  <li>cache 中可以存储的总数据量，以 byte 为单位</li>
  <li>最上面的图中 line size 为 4 bytes，有 4 行，因此容量为 16 bytes</li>
</ul>

<p><strong>有效位：</strong></p>
<ul>
  <li>因为在<strong>运行一个新程序</strong>时，cache 中没有任何有效的数据，需要有效位来标识所有的数据都是无效的，此时所有的有效位都是 0</li>
  <li>只有有效位为 1，且 address 与 tag 相符合，才是 cache hit</li>
</ul>

<p><strong>标签位：</strong></p>
<ul>
  <li>用来区分数据，cache 中地址与数据一一对应，因此数据用内存地址来标识。</li>
  <li>标签位不需要存储 Full Address，因为 cache 中存储的是 block，有 4 bytes，用来区分字节中位置的末尾部分不需要，因此只有地址前面部分用作 tag</li>
  <li>byte offset bits = log(line size)</li>
  <li>tag bits = address bits - offset bits</li>
</ul>

<p>当 cache 满了以后，需要替换策略，来把不用的 line 删除，放入新的数据。常用的方法是把最长时间没有使用的数据删除，该策略叫做 LRU (Least-Recently Used)。为了记录每行的访问历史，在每行中又包含了 <strong>LRU 位</strong>。当要删除数据时，会删除 LRU 值最大的行。</p>

<h4 id="42-write-through-vs-write-back-policies">4.2 write-through vs write-back policies</h4>

<p>cache 会加快存储器的访问速度，但是在写数据时也会造成数据不一致的问题。处理器要修改存储器中的一个数据，假如该数据在 cache 中被修改，与内存中的旧数据会不一致，因此必须指定修改数据的方式。</p>

<p><strong>写直达 (write-through):</strong></p>
<ul>
  <li>把要修改的数据同时写入 cache 和内存中</li>
  <li>因为要写入内存，耗费的时间长</li>
</ul>

<p><strong>写回 (write-back):</strong></p>
<ul>
  <li>把修改的数据写入 cache 中，设置 <strong>dirty bit</strong> 为 1</li>
  <li>当该行从 cache 删除时，再把该行写入内存</li>
</ul>

<h4 id="43-直接映射-cache">4.3 直接映射 cache</h4>
<p>直接映射中，内存中特定地址的数据，只能存储在 cache 中特定的位置。存储快的位置为 <code class="language-plaintext highlighter-rouge">(块号) mod (cache 中的块数)</code></p>

<div align="center">
<img src="/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90-0002-6.png" width="400" />
</div>

<p>上图内存中相同颜色的块会放入 cache 中同颜色的位置中，例如 0、4、8、C都会放入 cache 中的 0 位置。如果 cache 中特定位置已经有数据，必须得把该数据替换，才能把新数据放入。直接映射 cache 相较于全相连 cache，会有更多的冲突。</p>

<h4 id="44-组相联">4.4 组相联</h4>
<p>组相联可以看作全相联和直接映射的结合。组相联中，数据只能存储在一个索引位置，但是在一个位置有多个 slot。先用 tag 找到特定的组，再在组内找到特定的 slot。</p>]]></content><author><name>syh</name><email>songibicf@gmail.com</email></author><category term="计算机组成" /><summary type="html"><![CDATA[1. 为什么采用存储器层次结构]]></summary></entry><entry><title type="html">MOSFET 开关</title><link href="http://localhost:4000/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/2022/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90-0001.html" rel="alternate" type="text/html" title="MOSFET 开关" /><published>2022-07-18T00:00:00+08:00</published><updated>2022-07-18T00:00:00+08:00</updated><id>http://localhost:4000/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/2022/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90-0001</id><content type="html" xml:base="http://localhost:4000/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/2022/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90-0001.html"><![CDATA[<h3 id="1-开关">1. 开关</h3>

<p>开关可以看成一个三端装置 (three-terminal device)，这三个端包括一个控制端、一个输入端和一个输出端。开关的 v-i 曲线如下：</p>

<div align="center">
<img src="/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90-0001-1.png" width="300" />
</div>

<p>当控制端为逻辑 0 时，无论电压多大，电流都为 0；当控制端为 1 时，开关闭合，电流可能为任意值，但开关两端的电压为 0 。</p>

<p>一对开关可以通过串联和并联可以实现逻辑函数。左边的电路两个开关只有都闭合灯泡才会点亮，为 AND 函数，右边的两个开关只要有一个闭合灯泡就会点亮，为 OR 函数。用开关实现的数字逻辑叫做控制逻辑 (steering logic)。</p>

<div align="center">
<img src="/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90-0001-2.png" width="500" />
</div>

<p>用机械开关的一个缺点是控制端必须得由压力来控制，这使得用机械开关来构建逻辑电路非常复杂。因为一个电路的输出必须得转换为压力，才能输入到用机械开关实现的逻辑电路中。</p>

<h3 id="2-mosfet">2. MOSFET</h3>

<p>MOSFET 属于晶体管，是三端装置，包含控制端、输入端、输出端。MOSFET 用以下电路符号来表示。</p>

<div align="center">
<img src="/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90-0001-3.png" width="300" />
</div>

<p>控制端叫做栅极 (gate，G)，输入端叫做漏极 (drain，D)，输出端叫做源极 (source，S)。漏极和源极的方向根据实际情况而定，规定电流从漏极流向 源极，漏极的电压高。MOSFET 中涉及的记号如下图：</p>

<div align="center">
<img src="/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90-0001-4.png" width="200" />
</div>

<p>栅极和源极两端的电压差表示为 V<sub>GS</sub>，漏极和源极两端的电压差表示为 V<sub>DS</sub>，栅极端流经的电流叫做 i<sub>G</sub>，漏极端流经的电流叫做 i<sub>DS</sub>。</p>

<p>MOSFET 的特性复杂，有不同的模型可以来表示。用简单的开关来表示叫做 MOSFET’s Switch Model 或者 S Model。</p>
<ul>
  <li>当 V<sub>GS</sub> 超过了阈值电压 V<sub>T</sub> 时，装置为 ON 状态，否则为 OFF 状态。对于 n 通道的 MOSFETs 来说，V<sub>T</sub> 的典型值为 0.7 V。</li>
  <li>当为 ON 状态时，S 模型把漏极和源极之间的连接近似为短路。在实际的情况下，在漏极和源极之间存在非 0 的电阻值，但是在 S 模型中忽略该电阻。</li>
  <li>当为 OFF 状态时，在漏极和源极之间为开路。</li>
  <li>栅极和源极之间，栅极和漏极之间永远保持开路，因此 i<sub>G</sub> 一直为 0</li>
</ul>

<div align="center">
<img src="/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90-0001-5.png" width="300" />
</div>

<h3 id="3-mosfet-实现逻辑门">3. MOSFET 实现逻辑门</h3>

<div align="center">
<img src="/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90-0001-6.png" width="500" />
</div>

<p>左图由 MOSFET、一个负载电阻，一个 5V 电压源组成。电路的输入连接到栅极，源极接地，漏极与电阻、电压源相连。右图是简化图。该电路实现了非门。</p>

<p>假设逻辑高为 5 V，逻辑低为 0 V。当 v<sub>in</sub> 为高时，MOSFET 处于 ON 状态，因此输出电压为低。当 v<sub>in</sub> 为低时，MOSFET 为 OFF，输出由 R<sub>L</sub> 提升到高。</p>

<h3 id="4-sr-模型">4. SR 模型</h3>

<p>S 模型是 MOSFET 的简化，在实际中当 MOSFET 处于 ON 状态时，漏极和源极之间有非 0 电阻。因此，在 ON 状态时，可以在漏极和栅极之间添加 R<sub>ON</sub> 电阻，形成 SR 模型。</p>

<div align="center">
<img src="/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90-0001-7.png" width="400" />
</div>

<h3 id="5-mosfet-物理结构">5. MOSFET 物理结构</h3>

<p>MOSFET 在称为晶片的平面单晶硅表面构建。一般包含多层，包含：</p>
<ul>
  <li>氧化晶片表面产生的二氧化硅构成的绝缘层 (insulating layer)</li>
  <li>金属沉积物或者多晶硅构成的导电层 (conducting layer)</li>
  <li>通过在硅中掺杂其他材料构成的半导体层 (semiconducting layer)</li>
</ul>

<p>掺杂了富含电子的材料的硅称为 n 型半导体，类似地，掺杂了富含空穴的材料的硅被称为 p 型半导体。</p>]]></content><author><name>syh</name><email>songibicf@gmail.com</email></author><category term="计算机组成" /><summary type="html"><![CDATA[1. 开关]]></summary></entry></feed>