<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2022-08-17T21:54:21+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">syh 的博客</title><subtitle>记录计算机专业相关内容，Mens et Manus
</subtitle><author><name>syh</name><email>songibicf@gmail.com</email></author><entry><title type="html">并行</title><link href="http://localhost:4000/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/2022/08/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90-0003.html" rel="alternate" type="text/html" title="并行" /><published>2022-08-16T00:00:00+08:00</published><updated>2022-08-16T00:00:00+08:00</updated><id>http://localhost:4000/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/2022/08/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90-0003</id><content type="html" xml:base="http://localhost:4000/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/2022/08/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90-0003.html"><![CDATA[<h3 id="1-并行的原因">1. 并行的原因</h3>

<p>为什么要并行化？</p>
<ul>
  <li>由于技术和经济原因，CPU 的时钟频率不再增加</li>
  <li>只有通过并行处理，才能达到更快的处理速度</li>
</ul>

<p>并行化的两种基本方法：</p>
<ul>
  <li>Multiprogramming
    <ul>
      <li>并行运行多个独立的程序</li>
    </ul>
  </li>
  <li>Parallel computing
    <ul>
      <li>并行计算，更快的运行一个程序</li>
    </ul>
  </li>
</ul>

<h3 id="2-并行方法">2. 并行方法</h3>

<div align="center">
<img src="/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90-0003-1.png" width="200" />
</div>

<p>Single-Instruction/Multiple-Data Stream (SIMD):
SIMD 使用单条指令流来处理多条数据流，例如 Intel SIMD 指令集扩展或者 Nvidia GPU。</p>

<div align="center">
<img src="/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90-0003-2.png" width="200" />
</div>

<p>Multi-Instruction/Multiple-Data Stream (MIMD):
MIMD 使用多个处理器在不同的数据上执行不同的指令，MIMD 架构包括多个核心。</p>

<p>SIMD 和 MIMD 是目前最常用的并行化方法，例如 SSE 指令是单指令多数据，在 Xeon 中使用了 MIMD。</p>

<p>最常用的并行化编程方法：</p>
<ul>
  <li>单个程序运行在所有的处理器上</li>
  <li>使用同步原语来实现跨处理器的同步</li>
</ul>

<h3 id="3-simd">3. SIMD</h3>

<div align="center">
<img src="/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90-0003-3.png" width="500" />
</div>

<p>SIMD 中的一条指令可以完成多个数据的操作。正如上图所示，一条加法指令可以完成 8 组数据的相加。SIMD 在 x86、ARM、RISC-V 架构中都有实现。</p>

<p>Intel cpu 的 SIMD 功能可以通过 intrinsic functions 来进行调用。这些函数直接对应于特定的汇编指令，但是可以用 c 语言来写。</p>

<p>函数命名规则：https://www.intel.com/content/www/us/en/develop/documentation/cpp-compiler-developer-guide-and-reference/top/compiler-reference/intrinsics/naming-and-usage-syntax.html</p>

<p>长度为 128 位的数据可以指定的类型：</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>__m128    四个 float 类型
__m128d   两个 double 类型
__m128i   整数
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 例子
// 使用 _mm_setr 函数来设置 128 数据的值
__m128i values = _mm_setr_epi32(0x1234, 0x2345, 0x3456, 0x4567);

// 使用 _mm_extract_epi32(values, i)来提取值
int first_value = _mm_extract_epi32(values, 0);
int second_value = _mm_extract_epi32(values, 1);

// 存储值到内存中
int arrayA[4];
_mm_storeu_si128((_m128i*)arrayA, values);

// 从内存中加载值
int arrayB[4] = {10, 20, 30, 40};
values = _mm_loadu_si128((__m128i*) arrayB);
</code></pre></div></div>

<h3 id="4-mimd">4. MIMD</h3>

<p>MIMD 中使用了多个处理器。每个处理器有自己的 PC，并且执行独立的指令流。不同的处理器可以访问相同的内存空间。</p>

<p>使用多个处理器的两种方式：</p>
<ol>
  <li>对于不同的 job，通过 job-level 的并行，实现高吞吐量。</li>
  <li>在多处理器上运行单个程序，把这个程序分割成不同处理器上运行的子任务 (线程)，实现并行处理。</li>
</ol>

<p>线程是指执行某些任务的顺序指令流，每个线程都有自己的PC、寄存器并访问进程的共享内存。每个处理器的 core 提供一个或多个硬件线程来实际执行某一线程的指令。常见的 Intel 芯片每个 core 提供 2 线程。</p>

<p>操作系统将多个线程多路复用到可用的硬件线程。操作系统通过<strong>时分复用</strong>将软件线程分配到硬件线程上，以在特定的处理器上同时执行非常多的任务。时分复用是指把时间分成不同的时间间隔，任一线程只能执行几个时间间隔。当该线程时间耗尽或者阻塞时，操作系统中断该线程，把 context，包括寄存器、PC 存入内存中，并且操作系统会运行另一个线程。</p>

<h3 id="5-openmp-并行编程">5. OpenMP 并行编程</h3>

<p>OpenMP 是用于多线程并行编程的语言扩展。其编程模型如下图所示。</p>

<div align="center">
<img src="/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90-0003-4.png" width="400" />
</div>

<p>开始是单个线程，master thread，并且为顺序执行，直到遇到 parallel region。在并行区主线程会创建多个并行线程，每个线程会执行并行区的语句，直到所有线程全部完成，此时会进行 JOIN，只留下主线程。</p>

<p>数据竞争 (data race)：并行编程中常见的问题。如果多个线程尝试访问相同的内存位置，并且至少有一个线程进行写操作，那么有可能形成数据竞争。此时程序运行的结果不确定，需要通过同步指令来明确访问顺序，以产生确定的结果。主要通过锁来控制线程对关键部分的访问，使得一次只能有一个线程进行操作。</p>]]></content><author><name>syh</name><email>songibicf@gmail.com</email></author><category term="计算机组成" /><summary type="html"><![CDATA[1. 并行的原因]]></summary></entry><entry><title type="html">存储器层次结构</title><link href="http://localhost:4000/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/2022/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90-0002.html" rel="alternate" type="text/html" title="存储器层次结构" /><published>2022-07-26T00:00:00+08:00</published><updated>2022-07-26T00:00:00+08:00</updated><id>http://localhost:4000/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/2022/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90-0002</id><content type="html" xml:base="http://localhost:4000/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/2022/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90-0002.html"><![CDATA[<h3 id="1-为什么采用存储器层次结构">1. 为什么采用存储器层次结构</h3>

<div align="center">
<img src="/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90-0002-1.png" width="400" />
</div>

<p>计算机包含几个部分：</p>
<ul>
  <li>处理器，又分为控制器和数据通路，从内存中读取指令和数据，执行运算，并把结果保存到寄存器或者写回内存中。</li>
  <li>存储器，内存中包含程序的机器码和数据</li>
  <li>输入设备</li>
  <li>输出设备</li>
</ul>

<p>计算机的运行时离不开数据的读取和写入操作。由于存储程序概念，指令和数据均以数字的形式存储与存储器中，处理器的要不停的从存储器中读取指令和数据。</p>

<div align="center">
<img src="/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90-0002-2.png" width="600" />
</div>

<p>处理器的执行速度和内存 (DRAM) 的读写速度比较如上图所示。在 1980 年，处理器执行一条指令的时间和内存访问的速度差不多，存储器的访问速度并不会拖慢计算机的运行。但是处理器性能以每年 55% 的速度飞速增长，而 DRAM 的性能增速却只有 7%，两者的差距越来越大。以至于 DRAM 访问一条指令，处理器可以执行 1000 多条指令。</p>

<p>这巨大的速度差异如何来弥补？总不能让处理器每执行一条指令就停止，等 DRAM 中下一条指令的到来，如果有一个速度更快的存储器就好了。</p>

<p>这就要提到存储器有两个相互矛盾的属性，一个是容量，一个是访问速度。存储器一般容量大，速度就会慢，例如 <strong>DRAM</strong>。存储器速度快，容量就会小，例如 <strong>SRAM</strong>，一般只有几兆，而访问速度最快的<strong>寄存器</strong>在 RISC-V 中只有 32 个。</p>

<p>单纯使用 DRAM 或者 SRAM 都无法达到好的效果，处理器需要的是一个访问速度快，存储容量大的存储器。存储器的层次结构就是为了构建这样一个虚拟的存储器。这个虚拟的存储器的内部结构不需要处理器知道，处理器只需要正常的访问，就好像在访问一个速度快，容量大的存储器。</p>

<h3 id="2-存储器层次结构的原理">2. 存储器层次结构的原理</h3>

<p>为什么把不同性能的存储器结合起来可以抽象出一个速度快，容量大的存储器？原理可以用图书馆例子来形象的说明。假如你需要在图书馆查找些书籍来完成一篇报告，可能有以下过程：</p>

<ol>
  <li>在书架上找到书籍，拿到了图书馆的书桌上。通过翻阅书籍，找到需要的信息。</li>
  <li>如果需要别的书籍，去书架上拿，再次放到书桌上。书桌上一直保存着你查找过的书籍。</li>
</ol>

<p>图书馆相当于内存，容量大，但是查找速度慢。书桌相当于 cache，容量小，但是可以很快的找到你要的书籍。并且在书桌上一直保存查找过的书籍，当再次需要这本书的时候，直接拿起就行。图书馆和书桌构成了一个虚拟的访问速度快，容量大的图书馆。</p>

<p>存储器也是这样，cache 中存放了内存中之前取得的一部分数据以及该数据周围的一些数据，当处理器再次需要这些数据或者周围的数据时，可以直接从 cache 中读取。cache 一般集成在 CPU 内部，保留的数据为内存中一部分数据的复制。大多数的处理器都有单独的指令 cache 和数据 cache。</p>

<div align="center">
<img src="/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90-0002-3.png" width="300" />
</div>

<p>存储器的层次结构由以上 4 部分组成，包含寄存器、cache、内存、磁盘。如果存储器越靠近处理器，那么存储器就会更小、更快、更昂贵。最低等级的存储器，一般是磁盘，包含了所有的数据。存储器的层次结构抽象出一个容量大、访问速度快的存储器。</p>

<p>具体的来说，存储器层次结构利用的是局部性原理，包含：</p>

<ul>
  <li>时间局部性：如果现在使用了某一数据，不久有可能还要使用这一数据
    <ul>
      <li>可以在 cache 中保持最近使用过的数据</li>
    </ul>
  </li>
  <li>空间局部性：如果使用了存储器中的一条数据，不久有可能使用与这条数据相邻的数据
    <ul>
      <li>按 block 移动数据，而不只是移动一条数据</li>
    </ul>
  </li>
</ul>

<p>添加 cache 之后，计算机结构如下图所示：</p>

<div align="center">
<img src="/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90-0002-4.png" width="400" />
</div>
<h3 id="3-访问存储器的流程">3. 访问存储器的流程</h3>

<p>以 <code class="language-plaintext highlighter-rouge">lw t0 0(t1)</code> 指令为例，假设 t1 寄存器中包含的地址为 0x12F0，内存中相应的值为 99。</p>

<p>假如没有 cache，访问流程如下：</p>

<ol>
  <li>处理器将地址 0x12F0 发送给内存</li>
  <li>内存读取地址 0x12F0 中的值 99</li>
  <li>内存发送 99 到处理器</li>
  <li>处理器把 99 放入寄存器 t0 中</li>
</ol>

<p>假如有 cache，访问流程如下：</p>

<ol>
  <li>处理器将地址 0x12F0 发送给 cache</li>
  <li>cache 检查是否包含该地址中的数据
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  (1) 如果包含，cache 读取 99，发送给处理器
  (2) 如果不包含 (Miss)，cache 将地址 0x12F0 发送到内存
      a. 内存读取地址 0x12F0 中的值 99
      b. 内存将 99 发送给 cache
      c. cache 将地址 0x12F0 和 99 存储起来
      d. cache 将 99 发送给处理器
</code></pre></div>    </div>
  </li>
  <li>处理器把 99 放入寄存器 t0 中</li>
</ol>

<p><strong>cache hit</strong>：表示要查找的数据在 cache 中，可以直接在 cache 中读取出数据传入处理器中。</p>

<p><strong>cache miss</strong>：表示要查找的数据不在 cache 中，需要在内存中找到数据，并且把该数据放入 cache 中，然后才可以传入处理器。</p>

<h3 id="4-cache-中的数据存储方式">4. cache 中的数据存储方式</h3>

<p>cache 中存储方式有三种：</p>
<ol>
  <li>全相联 (Fully Associative)</li>
  <li>直接映射 (Direct Mapped)</li>
  <li>组相联 (Set-Associative)</li>
</ol>

<h4 id="41-全相联-cache">4.1 全相联 cache</h4>

<div align="center">
<img src="/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90-0002-5.png" width="400" />
</div>

<p>正如名称中 associate 的含义，全相联中把地址和数据存储在 cache 的一个行中。cache 中包含有效位、标签位、数据位等。</p>

<p><strong>cache line / block：</strong></p>
<ul>
  <li>利用局部性原理，cache 中存储的是 block，即一块数据。在 cache 中这一个块存储在一行中，因此也叫做 cache line。</li>
  <li>典型的 cache line / block 为 64 字节，可以充分利用空间局部性</li>
</ul>

<p><strong>line size / block size:</strong></p>
<ul>
  <li>每个 cache line 中的字节数</li>
</ul>

<p><strong>容量：</strong></p>
<ul>
  <li>cache 中可以存储的总数据量，以 byte 为单位</li>
  <li>最上面的图中 line size 为 4 bytes，有 4 行，因此容量为 16 bytes</li>
</ul>

<p><strong>有效位：</strong></p>
<ul>
  <li>因为在<strong>运行一个新程序</strong>时，cache 中没有任何有效的数据，需要有效位来标识所有的数据都是无效的，此时所有的有效位都是 0</li>
  <li>只有有效位为 1，且 address 与 tag 相符合，才是 cache hit</li>
</ul>

<p><strong>标签位：</strong></p>
<ul>
  <li>用来区分数据，cache 中地址与数据一一对应，因此数据用内存地址来标识。</li>
  <li>标签位不需要存储 Full Address，因为 cache 中存储的是 block，有 4 bytes，用来区分字节中位置的末尾部分不需要，因此只有地址前面部分用作 tag</li>
  <li>byte offset bits = log(line size)</li>
  <li>tag bits = address bits - offset bits</li>
</ul>

<p>当 cache 满了以后，需要替换策略，来把不用的 line 删除，放入新的数据。常用的方法是把最长时间没有使用的数据删除，该策略叫做 LRU (Least-Recently Used)。为了记录每行的访问历史，在每行中又包含了 <strong>LRU 位</strong>。当要删除数据时，会删除 LRU 值最大的行。</p>

<h4 id="42-write-through-vs-write-back-policies">4.2 write-through vs write-back policies</h4>

<p>cache 会加快存储器的访问速度，但是在写数据时也会造成数据不一致的问题。处理器要修改存储器中的一个数据，假如该数据在 cache 中被修改，与内存中的旧数据会不一致，因此必须指定修改数据的方式。</p>

<p><strong>写直达 (write-through):</strong></p>
<ul>
  <li>把要修改的数据同时写入 cache 和内存中</li>
  <li>因为要写入内存，耗费的时间长</li>
</ul>

<p><strong>写回 (write-back):</strong></p>
<ul>
  <li>把修改的数据写入 cache 中，设置 <strong>dirty bit</strong> 为 1</li>
  <li>当该行从 cache 删除时，再把该行写入内存</li>
</ul>

<h4 id="43-直接映射-cache">4.3 直接映射 cache</h4>
<p>直接映射中，内存中特定地址的数据，只能存储在 cache 中特定的位置。存储快的位置为 <code class="language-plaintext highlighter-rouge">(块号) mod (cache 中的块数)</code></p>

<div align="center">
<img src="/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90-0002-6.png" width="400" />
</div>

<p>上图内存中相同颜色的块会放入 cache 中同颜色的位置中，例如 0、4、8、C都会放入 cache 中的 0 位置。如果 cache 中特定位置已经有数据，必须得把该数据替换，才能把新数据放入。直接映射 cache 相较于全相连 cache，会有更多的冲突。</p>

<h4 id="44-组相联">4.4 组相联</h4>
<p>组相联可以看作全相联和直接映射的结合。组相联中，数据只能存储在一个索引位置，但是在一个位置有多个 slot。先用 tag 找到特定的组，再在组内找到特定的 slot。</p>]]></content><author><name>syh</name><email>songibicf@gmail.com</email></author><category term="计算机组成" /><summary type="html"><![CDATA[1. 为什么采用存储器层次结构]]></summary></entry><entry><title type="html">MOSFET 开关</title><link href="http://localhost:4000/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/2022/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90-0001.html" rel="alternate" type="text/html" title="MOSFET 开关" /><published>2022-07-18T00:00:00+08:00</published><updated>2022-07-18T00:00:00+08:00</updated><id>http://localhost:4000/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/2022/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90-0001</id><content type="html" xml:base="http://localhost:4000/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/2022/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90-0001.html"><![CDATA[<h3 id="1-开关">1. 开关</h3>

<p>开关可以看成一个三端装置 (three-terminal device)，这三个端包括一个控制端、一个输入端和一个输出端。开关的 v-i 曲线如下：</p>

<div align="center">
<img src="/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90-0001-1.png" width="300" />
</div>

<p>当控制端为逻辑 0 时，无论电压多大，电流都为 0；当控制端为 1 时，开关闭合，电流可能为任意值，但开关两端的电压为 0 。</p>

<p>一对开关可以通过串联和并联可以实现逻辑函数。左边的电路两个开关只有都闭合灯泡才会点亮，为 AND 函数，右边的两个开关只要有一个闭合灯泡就会点亮，为 OR 函数。用开关实现的数字逻辑叫做控制逻辑 (steering logic)。</p>

<div align="center">
<img src="/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90-0001-2.png" width="500" />
</div>

<p>用机械开关的一个缺点是控制端必须得由压力来控制，这使得用机械开关来构建逻辑电路非常复杂。因为一个电路的输出必须得转换为压力，才能输入到用机械开关实现的逻辑电路中。</p>

<h3 id="2-mosfet">2. MOSFET</h3>

<p>MOSFET 属于晶体管，是三端装置，包含控制端、输入端、输出端。MOSFET 用以下电路符号来表示。</p>

<div align="center">
<img src="/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90-0001-3.png" width="300" />
</div>

<p>控制端叫做栅极 (gate，G)，输入端叫做漏极 (drain，D)，输出端叫做源极 (source，S)。漏极和源极的方向根据实际情况而定，规定电流从漏极流向 源极，漏极的电压高。MOSFET 中涉及的记号如下图：</p>

<div align="center">
<img src="/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90-0001-4.png" width="200" />
</div>

<p>栅极和源极两端的电压差表示为 V<sub>GS</sub>，漏极和源极两端的电压差表示为 V<sub>DS</sub>，栅极端流经的电流叫做 i<sub>G</sub>，漏极端流经的电流叫做 i<sub>DS</sub>。</p>

<p>MOSFET 的特性复杂，有不同的模型可以来表示。用简单的开关来表示叫做 MOSFET’s Switch Model 或者 S Model。</p>
<ul>
  <li>当 V<sub>GS</sub> 超过了阈值电压 V<sub>T</sub> 时，装置为 ON 状态，否则为 OFF 状态。对于 n 通道的 MOSFETs 来说，V<sub>T</sub> 的典型值为 0.7 V。</li>
  <li>当为 ON 状态时，S 模型把漏极和源极之间的连接近似为短路。在实际的情况下，在漏极和源极之间存在非 0 的电阻值，但是在 S 模型中忽略该电阻。</li>
  <li>当为 OFF 状态时，在漏极和源极之间为开路。</li>
  <li>栅极和源极之间，栅极和漏极之间永远保持开路，因此 i<sub>G</sub> 一直为 0</li>
</ul>

<div align="center">
<img src="/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90-0001-5.png" width="300" />
</div>

<h3 id="3-mosfet-实现逻辑门">3. MOSFET 实现逻辑门</h3>

<div align="center">
<img src="/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90-0001-6.png" width="500" />
</div>

<p>左图由 MOSFET、一个负载电阻，一个 5V 电压源组成。电路的输入连接到栅极，源极接地，漏极与电阻、电压源相连。右图是简化图。该电路实现了非门。</p>

<p>假设逻辑高为 5 V，逻辑低为 0 V。当 v<sub>in</sub> 为高时，MOSFET 处于 ON 状态，因此输出电压为低。当 v<sub>in</sub> 为低时，MOSFET 为 OFF，输出由 R<sub>L</sub> 提升到高。</p>

<h3 id="4-sr-模型">4. SR 模型</h3>

<p>S 模型是 MOSFET 的简化，在实际中当 MOSFET 处于 ON 状态时，漏极和源极之间有非 0 电阻。因此，在 ON 状态时，可以在漏极和栅极之间添加 R<sub>ON</sub> 电阻，形成 SR 模型。</p>

<div align="center">
<img src="/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90-0001-7.png" width="400" />
</div>

<h3 id="5-mosfet-物理结构">5. MOSFET 物理结构</h3>

<p>MOSFET 在称为晶片的平面单晶硅表面构建。一般包含多层，包含：</p>
<ul>
  <li>氧化晶片表面产生的二氧化硅构成的绝缘层 (insulating layer)</li>
  <li>金属沉积物或者多晶硅构成的导电层 (conducting layer)</li>
  <li>通过在硅中掺杂其他材料构成的半导体层 (semiconducting layer)</li>
</ul>

<p>掺杂了富含电子的材料的硅称为 n 型半导体，类似地，掺杂了富含空穴的材料的硅被称为 p 型半导体。</p>]]></content><author><name>syh</name><email>songibicf@gmail.com</email></author><category term="计算机组成" /><summary type="html"><![CDATA[1. 开关]]></summary></entry><entry><title type="html">数字化抽象 (Digital Abstraction)</title><link href="http://localhost:4000/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/2022/07/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90-0000.html" rel="alternate" type="text/html" title="数字化抽象 (Digital Abstraction)" /><published>2022-07-08T00:00:00+08:00</published><updated>2022-07-08T00:00:00+08:00</updated><id>http://localhost:4000/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/2022/07/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90-0000</id><content type="html" xml:base="http://localhost:4000/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/2022/07/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90-0000.html"><![CDATA[<h3 id="1-数字化简介">1. 数字化简介</h3>
<p>信号可分为两类，模拟信号和数字信号。模拟信号中值是连续的，可以表示任意精度的值。数字信号中值是离散的，往往是模拟信号经过量化过程，得到的离散值。</p>

<p>数字化系统在现代社会无处不在。数字化在有些应用中是明显的，例如计算机、网络交换机。但是数字化系统绝不仅这些，例如当在手机上讲话时，声音信号也是经过数字化并通过数字通信设备传输；当看电视时，图像以数字化格式传输并被数字电路所处理。</p>

<p>大多数现代的电子产品仅仅在边缘使用模拟电路，例如电路和传感器的接口。在电子产品内部，外部输入的模拟信号会立马转换为数字信号，并且信号处理、存储、传输全部采用数字信号。数字信号什么时候转换成模拟信号呢？只有在输出端才会转换，例如喇叭播放音频时。</p>

<p>数字化的历史并不长，20 世纪 60 年代的电子设备 ( TV, 广播，录音机，电话 ) 还大都使用模拟信号。大规模的转向数字电路，主要得益于集成电路的发展。随着集成电路的复杂化，其能够执行的信号处理任务也越来越广泛。调制、错误校验、压缩这些技术也因数字化变得可行。数字信号还有一个非常大的优势。数字信号可以容忍噪声，消除大部分噪声的影响，不会像模拟信号一样产生噪声的叠加现象。</p>

<div align="center">
<img src="/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90-0000-0.png" width="500" />
</div>

<h3 id="2-数字化抽象">2. 数字化抽象</h3>
<p>Digital Abstraction 在计算机组成课程中经常提到，一般在介绍 CPU 实现前介绍。数字化抽象的基础是值的离散化，即把一个区间内的信号值映射为单个值。</p>

<div align="center">
<img src="/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90-0000-1.png" width="500" />
</div>

<p>虽然数字化看似浪费了信号的动态范围，使得信号从表示无穷多值变为只能表示有限值，但是数字信号在容忍 noise 方面有巨大优势。如下图所示，sender 往 receiver 发送信号，在信号传输过程中添加了 0.2 V 的噪声。模拟信号源发送的是 2.4 V，接收到的是 2.6 V，接受值与发送值不一致。假定 0 由 [0V, 2.5V] 区间内电压表示，数字信号源发送的是 1.25 V，接收端收到的是 1.45 V，依旧落在 [0V, 2.5V] 区间内，仍然表示为 0，传输过程中增加的 0.2 V 噪声没有影响接受信号的正确性。</p>

<div align="center">
<img src="/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90-0000-2.png" width="400" />
</div>

<p>数字化也并不是没有缺点。模拟信号可以表示任何电压值，如 1.1 V，2.9 V，0.9999999 V。但是在数字信号中，信号只有两个值：0 和 1。假如要用这两个值表示其余精度的值，就得使用多位二进制数，这与 CPU 内的数字表示类似。利用多位二进制可以表示任意的整数 ( 例如 python 中的 int 类型)。浮点数可依据 IEEE-754 来表示，但只能表示有限精度，python 中浮点数表示精度可通过 <code class="language-plaintext highlighter-rouge">sys.float_info</code> 查看。</p>

<h3 id="3-电压等级与静态约束-voltage-levels-and-the-static-discipline">3 电压等级与静态约束 (voltage levels and the static discipline)</h3>

<p>静态约束是数字设备的规范 (specification)，目的是规定发送方和接收方把什么区间内的电压解释为逻辑 0 和逻辑 1。假如数字设备符合 static discipline，不同厂商生产的设备之间就能正常的通信。</p>

<div align="center">
<img src="/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90-0000-3.png" />
</div>

<ol>
  <li>左边的图是最简单的情况，指定逻辑 0 用区间 [0.0 V, 2.5 V] 表示，逻辑 1 用区间 [2.5 V, 5.0 V] 表示。
    <ul>
      <li>缺点：在 2.5 V 附近的电压只要有小的噪声，就会产生<strong>错误</strong>的结果。</li>
    </ul>
  </li>
  <li>中间的图加入了禁止区 ( forbidden region )。禁止区把两个区间分隔开来，禁止区内接收方的行为未定义。V<sub>L</sub> 叫做低电压阈值，V<sub>H</sub> 叫做高电压阈值。发送方即使发送 V<sub>L</sub>、V<sub>H</sub> 附近的电压叠加了噪声，也不会产生错误结果，只会产生 “Undefined” 的结果。
    <ul>
      <li>逻辑 0 由区间 [0, V<sub>L</sub>] 表示</li>
      <li>逻辑 1 用区间 [V<sub>H</sub>, 5] 表示</li>
      <li>如果接收方接收到禁止区间内的电压，不规定接收方的行为。</li>
      <li>缺点：发送方可以发送 V<sub>L</sub>，V<sub>H</sub> 附近的电压，阈值边缘的电压非常容易落入禁止区。对发送方的行为没有做出限制，即没有噪声容限 (noise margin)。</li>
    </ul>
  </li>
  <li>右边的图对发送方做出限制，发送方的区间范围要窄于接收方的区间范围，有一定的噪声容限。发送方是输出信号，电压阈值用 V<sub>OL</sub>、V<sub>OH</sub> 表示。接收方的电压阈值用 V<sub>IL</sub>、V<sub>IH</sub> 表示。</li>
</ol>

<table>
  <thead>
    <tr>
      <th style="text-align: center">-</th>
      <th style="text-align: center">表示逻辑 0 的区间</th>
      <th style="text-align: center">表示逻辑 1 的区间</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">发送方</td>
      <td style="text-align: center">[0, V<sub>OL</sub>]</td>
      <td style="text-align: center">[V<sub>OH</sub>, 5]</td>
    </tr>
    <tr>
      <td style="text-align: center">接收方</td>
      <td style="text-align: center">[0, V<sub>IL</sub>]</td>
      <td style="text-align: center">[V<sub>IH</sub>, 5]</td>
    </tr>
    <tr>
      <td style="text-align: center">噪声容限</td>
      <td style="text-align: center">V<sub>IL</sub> - V<sub>OL</sub></td>
      <td style="text-align: center">V<sub>OH</sub> - V<sub>IH</sub></td>
    </tr>
  </tbody>
</table>

<h3 id="4-布尔逻辑-boolean-logic">4 布尔逻辑 (Boolean Logic)</h3>

<p>布尔逻辑的表示方法：</p>
<ol>
  <li>布尔表达式 ( boolean equation )
    <ul>
      <li>AND, OR, NOT</li>
      <li>·， +， ~</li>
    </ul>
  </li>
  <li>逻辑门的组合 (combinational gates)
    <ul>
      <li>逻辑门电路遵循<strong>静态约束</strong>，输入合适范围内的电压值，电路会产生合适的输出电压</li>
      <li>门：电路的一种抽象，满足两个属性
        <ol>
          <li>输出只是输入的函数，没有状态</li>
          <li>满足静态约束</li>
        </ol>
      </li>
    </ul>
  </li>
</ol>

<h4 id="41-乘积和形式">4.1 乘积和形式</h4>

<p>乘积和形式：</p>
<ul>
  <li>逻辑表达式的标准形式 ( standard or canonic form )</li>
  <li>表达式由多个乘积项 ( product terms ) 组成</li>
  <li>每个乘积项由多个变量相乘得到</li>
  <li>乘积项通过 OR 函数组合</li>
</ul>

<p>真值表 ==&gt; 乘积和表达式：</p>
<ul>
  <li>对每一个输出为 1 的行，写乘积项，然后对所有得到的乘积项相加。</li>
  <li>每个乘积项由所有输入变量通过 AND 得到，如果输入变量是 0，写成 true form，如果输入变量是 1，写成 complement form</li>
</ul>

<div align="center">
<img src="/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90-0000-4.png" width="500" />
</div>

<h4 id="42-逻辑表达式的简化-simplifying-logic-expressions">4.2 逻辑表达式的简化 (simplifying logic expressions)</h4>

<p>逻辑表达式简化的目的：最小化硬件实现代价</p>

<p>主要的规则：</p>

<div align="center">
<img src="/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90-0000-5.png" width="300" />
</div>]]></content><author><name>syh</name><email>songibicf@gmail.com</email></author><category term="计算机组成" /><summary type="html"><![CDATA[1. 数字化简介 信号可分为两类，模拟信号和数字信号。模拟信号中值是连续的，可以表示任意精度的值。数字信号中值是离散的，往往是模拟信号经过量化过程，得到的离散值。]]></summary></entry><entry><title type="html">数据结构与序列接口</title><link href="http://localhost:4000/%E7%AE%97%E6%B3%95/2022/07/07/%E7%AE%97%E6%B3%95-0001.html" rel="alternate" type="text/html" title="数据结构与序列接口" /><published>2022-07-07T00:00:00+08:00</published><updated>2022-07-07T00:00:00+08:00</updated><id>http://localhost:4000/%E7%AE%97%E6%B3%95/2022/07/07/%E7%AE%97%E6%B3%95-0001</id><content type="html" xml:base="http://localhost:4000/%E7%AE%97%E6%B3%95/2022/07/07/%E7%AE%97%E6%B3%95-0001.html"><![CDATA[<h3 id="1-数据结构">1. 数据结构</h3>
<ul>
  <li><strong>数据结构</strong>是存储数据的一种方式，通过实现特定算法来支持特定的数据操作。</li>
  <li>
    <p>数据结构所支持的所有操作的集合叫做<strong>接口</strong> (interface/API/ADT)</p>
  </li>
  <li>接口相当于<strong>规范</strong> (specification)，指定了支持的操作。</li>
  <li>数据结构是<strong>表现</strong> (representation)，指定了操作的具体实现。</li>
</ul>

<h3 id="2-序列接口-sequence-interface">2. 序列接口 (Sequence Interface)</h3>
<p>序列由多个有特定顺序的项组成，例如长度为 n 的序列可以表示为 (x0, x1, x2, …, xn-1)。序列接口指定的操作有：</p>

<p><img src="/image/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95-0001-1.png" alt="序列操作" /></p>

<h3 id="3-序列的三种实现方式">3. 序列的三种实现方式</h3>
<p>序列接口指定了序列所要支持的创建操作、静态操作、动态操作。序列数据结构有三种实现方式：数组序列 ( Array Sequence )、链表序列 ( Linked List Sequence )、动态数组序列 ( Dynamic Array Sequence )。这三种数据结构有一致的序列接口，但是内部的实现方式不同，导致的结果是操作的时间复杂度不同。</p>

<h4 id="31-数组序列">3.1 数组序列</h4>
<ul>
  <li>数组序列维持内存中固定尺寸的存储空间，并把序列中的每个项依次放入内存中。例如创建有 10 个项的 int 数组，那么就需要调用 (int *)malloc(sizeof(int) * 10) 来分配固定尺寸的空间。</li>
  <li>由于第 i 项的地址可以直接计算出来，静态操作中的访问和设置花费 O(1) 时间。</li>
  <li>动态操作比较特殊。由于内存中分配的存储空间尺寸是固定的，因此对数组的任何动态修改，都需要重新分配存储空间，然后执行复制操作，时间复杂度为 O(n)。</li>
</ul>

<p><img src="/image/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95-0001-2.png" alt="数组序列的的时间复杂度" /></p>

<h4 id="32-链表序列">3.2 链表序列</h4>
<p>存储：</p>
<ul>
  <li>通过指针来实现。</li>
  <li>每个项存储在结点 ( node ) 中，每个结点包含项 ( node.item )，同时包含指向下一个结点的指针 ( node.next )。</li>
  <li>链表序列保持了指向第一个结点的指针，一般叫做 head</li>
</ul>

<p>静态操作：</p>
<ul>
  <li>无法直接计算出项的地址，只能从 head 结点依次往后遍历，时间复杂度为 O(n)</li>
</ul>

<p>动态操作：</p>
<ul>
  <li>在链表头插入和删除结点只需要 O(1) 时间复杂度，修改指针即可完成。</li>
  <li>由于项的顺序是通过指针来链接起来的，通过修改指针，就可以实现重排结点。不需要像数组序列一样移动大量的项。</li>
  <li>但是 insert_last，delete_last，insert_at，delete_at 都得首先找到结点，然后再修改指针，时间复杂度还是为 O(n)。</li>
</ul>

<p>链表序列相比于数组序列，在静态操作上不占优势。在动态操作上，优势也只在 insert_first, delete_first 操作上。</p>

<p><img src="/image/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95-0001-3.png" alt="链表序列的时间复杂度" /></p>

<h4 id="33-动态数组序列">3.3 动态数组序列</h4>
<p>主要目的：保持访问操作为 O(1) 的前提下，实现 insert_last, delete_last 时间复杂度为 O(1)。python 中的 list 类型为动态数组。</p>

<p>存储：</p>
<ul>
  <li>主要方法：既然数组序列中动态操作的时间花费在往新分配的存储空间复制元素上，那么就一次分配相对大的存储空间。只要存储空间不占满，对末尾元素的修改就不需要执行耗时的分配空间和复制操作。序列长度与存储空间长度的比值 r 要维持在一定的比例。</li>
</ul>

<p>静态操作：</p>
<ul>
  <li>由于在数组的基础上实现，可以实现随机访问。</li>
</ul>

<p>动态操作：</p>
<ul>
  <li>和数组差别在于每次操作都得检查 r, 判断是否需要重新分配存储空间。</li>
  <li>末尾插入
    <ul>
      <li>如果 r &lt; 1, 直接在末尾插入</li>
      <li>如果 r == 1， 在末尾要分配 Θ(n) 额外的空间来维持 r</li>
      <li>由于提前分配了多余的存储空间，在下次分配前，可以插入 Θ(n) 次。摊还分析后，在末尾插入元素的平均时间复杂度只有 O(1)</li>
    </ul>
  </li>
  <li>末尾删除
    <ul>
      <li>可以直接删除，但是为了节省空间，当 r 小于阈值 rd 时，重新分配一个小的空间。例如 rd 可以取 1/4，分配的空间可以取为原先空间的一半，当删除元素到只有存储空间的 1/4 时，就会把存储空间重新分配为一半，r 维持在 [1/4, 1]。</li>
      <li>平均后，末尾删除操作的时间复杂度为 O(1)</li>
    </ul>
  </li>
</ul>

<p>三种序列实现所涉及操作的时间复杂度：</p>

<p><img src="/image/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95-0001-4.png" alt="动态数组序列的时间复杂度" /></p>

<p>三种序列数据结构各有特点，以上介绍的只是基本实现，这些数据结构有非常多种的变形，以达到不同的应用目的。例如，除了上面介绍的单链表，还有双链表、循环链表，除了在末尾动态分配空间的动态数组，还可以在序列开头也进行动态分配。要根据实际的操作选择合适的数据结构。</p>]]></content><author><name>syh</name><email>songibicf@gmail.com</email></author><category term="算法" /><summary type="html"><![CDATA[1. 数据结构 数据结构是存储数据的一种方式，通过实现特定算法来支持特定的数据操作。 数据结构所支持的所有操作的集合叫做接口 (interface/API/ADT)]]></summary></entry><entry><title type="html">集合接口与排序</title><link href="http://localhost:4000/%E7%AE%97%E6%B3%95/2022/07/07/%E7%AE%97%E6%B3%95-0002.html" rel="alternate" type="text/html" title="集合接口与排序" /><published>2022-07-07T00:00:00+08:00</published><updated>2022-07-07T00:00:00+08:00</updated><id>http://localhost:4000/%E7%AE%97%E6%B3%95/2022/07/07/%E7%AE%97%E6%B3%95-0002</id><content type="html" xml:base="http://localhost:4000/%E7%AE%97%E6%B3%95/2022/07/07/%E7%AE%97%E6%B3%95-0002.html"><![CDATA[<h3 id="1-集合接口-set-interface">1. 集合接口 (Set Interface)</h3>
<p>集合是由具有唯一性的对象所组成的无序多项集，常用的用途包括成员检测、从序列中去除重复项以及数学中的集合类计算。集合接口定义的操作包括：</p>

<p><img src="/image/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95-0002-1.png" alt="集合接口定义的操作" /></p>

<p>集合数据类型非常依赖于 find 操作，例如静态操作的 find(k)，动态操作也要先验证集合中的元素，排序操作需要找到特定键的元素。涉及到查找元素的操作，就离不开<strong>排序</strong>。对项进行排序后，才能用二分查找快速定位到项，才能快速找到最小项、最大项、前一个项、后一个项。</p>

<p><img src="/image/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95-0002-2.png" alt="集合操作的时间复杂度" /></p>

<h3 id="2-排序-sorting">2. 排序 (Sorting)</h3>
<p>排序是数据结构中的基本算法，有多种不同时间复杂度的算法。</p>

<ul>
  <li>输入：长度为 n 的数组 A</li>
  <li>输出：有序的数组 B，项依据 key 从小到大排列</li>
</ul>

<p>概念：</p>
<ul>
  <li>原位排序：在排序时只使用 O(1) 的额外空间</li>
  <li>稳定性：输入数组中有相同值的项，在输出数组中排列的先后关系不变</li>
</ul>

<h4 id="21-permutation-sort">2.1 Permutation Sort</h4>
<p>简单、暴力的排序方法。尝试每一种 A 的排列，直到找到有序的排列，返回时间复杂度为 Ω(n! · n)</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def permutation_sort(A):
    ''' sort A ''' 
    for B in permutations(A):
        if is_sorted(B):
            return B
</code></pre></div></div>
<h4 id="22-选择排序-selection-sort">2.2 选择排序 (Selection Sort)</h4>
<p>找到 A[:i+1] 中的最大值，把最大值交换到 A[i]，然后递归排序 A[:i]</p>

<ul>
  <li>时间复杂度为 O(n^2)</li>
  <li>原位排序</li>
  <li>不是稳定排序</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># 递归实现
def selection_sort(A, i=None):
    ''' Sort A[:i+1] '''
    if i is None: i = len(A)-1
    if i &gt; 0:
        j = prefix_max(A, i)
        A[i], A[j] = A[j], A[i]  # swap
        selection_sort(A, i-1)   # recursion
def prefix_max(A, i):
    ''' 找到 A[:i+1] 中返回最大值的索引，递归实现 '''
    if i&gt;0:
        j = prefix_max(A, i-1)
        if A[i] &lt; A[j]:
            return j
    return i

# 迭代实现
def selection_sort(A):
    for i in range(len(A)-1, 0, -1):
        m = i
        for j in range(i):
            if A[m] &lt; A[j]:
                m = j
        A[m], A[i] = A[i], A[m]
</code></pre></div></div>

<h4 id="23-插入排序-insertion-sort">2.3 插入排序 (Insertion Sort)</h4>
<p>递归排序 A[:i]，i 从 1 到 n。每次排序时，前面的项已经排好序，只需要把最后项插入到合适的位置。</p>

<ul>
  <li>时间复杂度为 O(n^2)</li>
  <li>原位排序</li>
  <li>稳定排序</li>
</ul>

<p>插入排序和选择排序比较类似，都是维持一个排好序的项的子集，然后不断往子集里增加项，直到所有元素都拍好序。不同点在于：</p>
<ul>
  <li>选择排序先排序最大的 i 项</li>
  <li>插入排序先排序数组头 i 项</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># 递归实现
def insertion_sort(A, i=None):
    if i is None:
        i = len(A) - 1
    if i &gt; 0:
        insertion_sort(A, i-1)
        insert_last(A, i)
def insert_last(A, i):
    '''把第i个元素插入到合适的位置'''
    if i&gt;0 and A[i-1]&gt;A[i]:
        A[i-1], A[i] = A[i], A[i-1]
        insert_last(A, i-1)

# 迭代实现
def insertion_sort(A):
    for i in range(1, len(A)):
        j = i
        while j&gt;0 and A[j]&lt;A[j-1]:
            A[j-1], A[j] = A[j], A[j-1]
            j = j - 1
</code></pre></div></div>

<h4 id="24-归并排序-merge-sort">2.4 归并排序 (Merge Sort)</h4>
<p>分治法，把整个数据分成两半，对两个子数组递归排序，然后经过 O(n) 的合并步骤，得到最后的排序结果。</p>

<ul>
  <li>递归表达式为 T(n) = 2T(n/2) + Θ(n)，时间复杂度为 Θ(nlogn)</li>
  <li>不是原位排序</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def merge_sort(A, a=0, b=None):
    if b is None:  b = len(A)
    if b-a &gt; 1:
        c = (a+b+1)//2
        merge_sort(A, a, c)
        merge_sort(A, c, b)
        L, R = A[a:c], A[c:b]
        merge(L, R, A, len(L), len(R), a, b)

def merge(L, R, A, i, j, a, b):
    ''' 
    Merge sorted L[:i], and R[:j] into A[a:b] 
    递归实现，每次从 L 和 R 中选出最大值，放入到 A[b-1] 处，然后递归
    '''
    if a &lt; b:
        if (j&lt;=0) or (i&gt;0 and L[i-1]&gt;R[j-1]): # R 没有元素或最大值在 L 中
            A[b-1] = L[i-1]
            i -= 1
        else:  # L 没有元素或最大值在 R 中
            A[b-1] = R[j-1]
            j -= 1
        merge(L, R, A, i, j, a, b-1)
</code></pre></div></div>

<h3 id="3-递归表达式的求解">3. 递归表达式的求解</h3>
<p>递归在算法中非常重要，一方面算法的正确性证明要用到递归，另一方面算法本身要用到递归。通过递归把问题分解成子问题，可以降低问题的求解难度，写出非常易于理解的代码。</p>

<p>利用递归法求解问题要经历三个步骤：</p>
<ol>
  <li>分解：把问题分解成子问题。最基础的情况称为基本情况，写在函数开头。</li>
  <li>解决：递归调用方法，解决子问题</li>
  <li>合并：通过子问题求解得到的结果，合并出问题的解</li>
</ol>

<p>分析递归算法的时间复杂度，需要求解得到的递归表达式。递归表达式是规模为 n 的问题的时间复杂度 T(n) 与较小规模子问题的时间复杂度(根据子问题的规模而定，常见的有 T(n-1), T(n/2))的关系。通过递归表达式，可以得到 T(n) 的值。</p>

<p>递归表达式的求解方法：</p>
<ul>
  <li>代入法 (Substitution): 猜测一个解，带入到表达式中，证明表达式成立</li>
  <li>递归树法 (Recurrence Tree): 画出表示递归调用的树，累加结点的值</li>
  <li>主方法 (Master Theorem): 代入公式求解</li>
</ul>

<p>一些递归表达式求解结果：</p>

<table>
  <thead>
    <tr>
      <th>递归表达式</th>
      <th>T(n)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>T(n) = T(n/2) + O(1)</td>
      <td>O(logn)</td>
    </tr>
    <tr>
      <td>T(n) = T(n-1) + O(1)</td>
      <td>O(n)</td>
    </tr>
    <tr>
      <td>T(n) = T(n-1) + O(n)</td>
      <td>O(n^2)</td>
    </tr>
    <tr>
      <td>T(n) =2T(n-1) + O(1)</td>
      <td>O(2^n)</td>
    </tr>
    <tr>
      <td>T(n) = T(2n/3)+ O(1)</td>
      <td>O(logn)</td>
    </tr>
    <tr>
      <td>T(n) =2T(n/2) + O(1)</td>
      <td>O(n)</td>
    </tr>
    <tr>
      <td>T(n) = T(n/2) + O(n)</td>
      <td>O(n)</td>
    </tr>
    <tr>
      <td>T(n) =4T(n/2) + O(n)</td>
      <td>O(n^2)</td>
    </tr>
  </tbody>
</table>]]></content><author><name>syh</name><email>songibicf@gmail.com</email></author><category term="算法" /><summary type="html"><![CDATA[1. 集合接口 (Set Interface) 集合是由具有唯一性的对象所组成的无序多项集，常用的用途包括成员检测、从序列中去除重复项以及数学中的集合类计算。集合接口定义的操作包括：]]></summary></entry><entry><title type="html">算法基础概念</title><link href="http://localhost:4000/%E7%AE%97%E6%B3%95/2022/07/06/%E7%AE%97%E6%B3%95-0000.html" rel="alternate" type="text/html" title="算法基础概念" /><published>2022-07-06T00:00:00+08:00</published><updated>2022-07-06T00:00:00+08:00</updated><id>http://localhost:4000/%E7%AE%97%E6%B3%95/2022/07/06/%E7%AE%97%E6%B3%95-0000</id><content type="html" xml:base="http://localhost:4000/%E7%AE%97%E6%B3%95/2022/07/06/%E7%AE%97%E6%B3%95-0000.html"><![CDATA[<h3 id="1-什么是算法">1. 什么是算法</h3>
<p>算法可以看作一个过程，把每个输入映射到唯一的一个输出。</p>

<p>如果算法对问题所有可能的输入都得到了正确的输出，那么就说算法<strong>解决</strong>了该问题。</p>

<h3 id="2-评价算法">2. 评价算法</h3>
<p>给定一个算法，如何评价算法？首先要验证算法是否正确，然后要评价算法的效率。</p>

<h4 id="21-验证算法的正确性">2.1 验证算法的正确性。</h4>
<p>如果算法的输入空间小，可以逐案例分析，但是这毕竟是少数的情况。更常见的情况是算法有任意多种情况的输入，输入空间无限大，例如对数组进行排序，数组的长度和项有无穷多种可能。那么如何对这类算法进行正确性验证呢？这时候就要采用数学证明上常用的<strong>数学归纳法</strong>，或者用计算机的语言说叫做递归证明。步骤如下：</p>
<ul>
  <li>首先证明基本情况成立。</li>
  <li>假定子问题下算法成立，通过子问题推导出当前问题下算法成立。</li>
</ul>

<h4 id="22-评价算法的效率">2.2 评价算法的效率</h4>
<p>算法效率方面要评价算法的<strong>时间复杂度</strong>和<strong>空间复杂度</strong>。在特定的输入规模下，空间复杂度评价算法的存储空间消耗，时间复杂度评价算法的快慢。</p>

<p>在评价算法的复杂度时，有几点需要注意：</p>
<ul>
  <li>评价时希望时间复杂度独立于机器，因此是把算法中基本操作看作一个单位，对算法所涉及的基本操作进行计数，以所有的基本操作数目来评价算法的时间复杂度。例如，把加法、乘法、赋值等都看成执行时间相等的基本操作，算法所耗的时间就是这些基本操作的总数目。基本操作涉及到计算模型，详见下方。</li>
  <li>假定输入规模为 n，得到的基本操作总数目的表达式可能非常复杂，难以直接比较，需要方法来简化。<strong>在输入规模 n 非常大的情况下</strong>，复杂度表达式会被高阶项所主导，低阶项就不那么重要，因此，我们在评价复杂度时，采用渐进复杂度，即<strong>忽略表达式中的常数因子和低阶项</strong>。常见的渐进复杂度记号有上界(O)，下界(Ω)，紧确界(Θ)。</li>
</ul>

<h3 id="3-计算模型">3. 计算模型</h3>
<p>指定机器上执行什么操作消耗 O(1) 时间，用于时间复杂度评价。处理器可以在常数项时间内完成的操作有：</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1. 整数算术：+, -, *, //, %
2. 逻辑操作：&amp;&amp;, \|\|, !, ==, &lt;, &gt;, &lt;=, &gt;=
3. 位操作：&amp;, \|, &lt;&lt;, &gt;&gt;
4. machine word 大小的内存读取和写入操作
</code></pre></div></div>
<p>这些操作就是汇编语言中的基础指令，在时间复杂度分析时，通过对这些基本操作进行计数，再通过渐进记号忽略掉不重要的常数因子和低阶项，最后得到的就是算法的时间复杂度。</p>]]></content><author><name>syh</name><email>songibicf@gmail.com</email></author><category term="算法" /><summary type="html"><![CDATA[1. 什么是算法 算法可以看作一个过程，把每个输入映射到唯一的一个输出。]]></summary></entry></feed>