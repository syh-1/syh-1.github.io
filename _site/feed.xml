<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2022-10-01T11:30:43+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">syh 的博客</title><subtitle>记录计算机专业相关内容，Mens et Manus
</subtitle><author><name>syh</name><email>songibicf@gmail.com</email></author><entry><title type="html">Binary Heaps</title><link href="http://localhost:4000/%E7%AE%97%E6%B3%95/2022/09/28/%E7%AE%97%E6%B3%95-0007.html" rel="alternate" type="text/html" title="Binary Heaps" /><published>2022-09-28T00:00:00+08:00</published><updated>2022-09-28T00:00:00+08:00</updated><id>http://localhost:4000/%E7%AE%97%E6%B3%95/2022/09/28/%E7%AE%97%E6%B3%95-0007</id><content type="html" xml:base="http://localhost:4000/%E7%AE%97%E6%B3%95/2022/09/28/%E7%AE%97%E6%B3%95-0007.html"><![CDATA[<h3 id="1-优先队列接口">1. 优先队列接口</h3>

<ul>
  <li>存储多个项，可以快速的访问、移除最重要的项，实际例子有：
    <ul>
      <li>有限带宽的路由器必须优先处理重要的信息</li>
      <li>操作系统内核中的进程调度</li>
      <li>离散事件模拟</li>
      <li>图算法</li>
    </ul>
  </li>
  <li>优先队列是按照优先级对项进行了排序，所以也可以看作 Set 接口</li>
  <li>对于特定集合操作进行了优化：
    <ul>
      <li>build(X)</li>
      <li>insert(x)</li>
      <li>delete_max()</li>
      <li>find_max()</li>
    </ul>
  </li>
  <li>关注 insert 和 delete_max 操作</li>
  <li>优先队列有多种实现方法，例如 array， sorted array， set AVL tree。</li>
</ul>

<h3 id="2-优先队列排序">2. 优先队列排序</h3>

<ul>
  <li>在任何的优先队列中，都可以按以下方法对 A 进行排序
    <ul>
      <li>build(A)，例如依次 insert 每一项</li>
      <li>然后重复 delete_max()</li>
    </ul>
  </li>
  <li>时间复杂度：T<sub>build</sub> + n * T<sub>delete_max</sub> = n * T<sub>insert</sub> + n * T<sub>delete_max</sub></li>
  <li>在以下的优先队列实现中，应用优先队列排序的时间复杂度如下图。并且在特定实现中，优先队列排序和一些排序算法很相似。</li>
</ul>

<div align="center">
<img src="/image/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95-0007-1.png" width="600" />
<p></p>
</div>

<h4 id="21-优先队列set-avl-tree">2.1 优先队列：Set AVL Tree</h4>

<ul>
  <li>Set AVL 树支持 insert(x), find_min(), find_max(), delete_min() 和 delete_max() 操作，并且时间复杂度全部为 O(logn)</li>
  <li>按照优先队列排序，时间复杂度为 O(nlogn)</li>
  <li>但是这个数据结构复杂，并且排序不是原位的</li>
</ul>

<h4 id="22-优先队列array">2.2 优先队列：Array</h4>

<ul>
  <li>在动态数组中以无序的方式存储元素</li>
  <li>insert(x)：O(1)</li>
  <li>delete_max(): 找到最大值，交换到末尾，并且移除</li>
  <li>insert 很快，但是 delete_max() 慢</li>
  <li>在 array 实现中进行优先队列排序，基本上和选择排序一样</li>
</ul>

<h4 id="23-优先队列sorted-array">2.3 优先队列：Sorted Array</h4>

<ul>
  <li>在有序的动态数组中存储元素</li>
  <li>insert(x)：把 x 放入末尾，并将 x 交换到合适的位置</li>
  <li>delete_max(x)：直接从末尾删除</li>
  <li>delete_max 快，但是 insert 慢</li>
  <li>在 sorted array 上进行优先队列排序，基本上就是插入排序</li>
</ul>

<h3 id="3-heap">3. heap</h3>

<p>那么，可以在以上的优先队列实现中找到一个平衡吗？既保持排序算法的<strong>低时间复杂度</strong>，又是<strong>原位排序</strong>算法。</p>

<p>idea：<strong>把数组看作一个完全二叉树</strong>，除了最后一层，完全二叉树在深度为 i 的层上都有 2^i 个结点。在最后一层上所有的结点都是左对齐的。</p>

<p>完全二叉树填充数组时，是按照<strong>层次遍历</strong>的顺序放入，从根到叶子结点，一层一层从左往右依次放入。这样，完全二叉树和数组建立了对应关系，完全二叉树不是由指针来确定结点关系，而是由数组中的位置来确定结点关系。</p>

<p>根结点在索引 0 处。结点 i 的左孩子在索引 2i+1 处，右孩子在索引 2i+2 处，父结点在 math.floor((i-1)/2) 处。</p>

<h4 id="31-binary-heaps">3.1 Binary Heaps</h4>

<p>idea：元素越大，在树中放置的高度越高。</p>

<p>最大堆属性：在结点 i 处，Q[i] &gt;= Q[j] for j ∈ {left(i), right(i)}</p>

<p><strong>最大堆</strong>：在所有结点上都满足最大堆属性的<strong>数组</strong></p>

<p>在最大堆中，可以证明对于结点 i，Q[i] &gt;= Q[j]，j 可以是子树中任一结点。</p>

<h4 id="32-heap-insert">3.2 Heap Insert</h4>

<ul>
  <li>把要插入的元素 x 放入数组的末尾，相当于插入到树的叶子结点中</li>
  <li>max_heapify_up(i): 为了维持最大堆属性，依次与父结点交换
    <ul>
      <li>检查是否 Q[parent(i)] &gt;= Q[i]</li>
      <li>如果不是，交换结点，递归执行 max_heapify_up(parent(i))</li>
    </ul>
  </li>
  <li>运行时间：树的高度 O(logn)</li>
</ul>

<h4 id="33-heap-delete-max">3.3 Heap Delete Max</h4>

<ul>
  <li>在数组中只能容易的移除最后的元素，但是最大项却在索引 0 的位置</li>
  <li>所以，把索引 0 的项和最后一项进行交换，并删除交换后的最后一项</li>
  <li>然后执行 max_heapify_down(i)：从上往下维持最大堆属性
    <ul>
      <li>检查是否 Q[i] &gt;= Q[j] for j ∈ {left(i), right(i)}</li>
      <li>如果不是，把 Q[i] 和 最大的孩子结点交换，并递归执行 max_heapify_down</li>
    </ul>
  </li>
  <li>运行时间：树的高度 O(logn)</li>
</ul>

<h4 id="34-heap-sort">3.4 Heap Sort</h4>

<p>堆排序时间复杂度为 O(nlogn)</p>

<p>线性时间内建堆：</p>
<ul>
  <li>假如是依次插入 n 个元素到堆中，那么得调用 max_heapify_up(i) n 次，每次都得经过整个树高，时间复杂度为 Ω(n lg n)</li>
  <li>idea: 把数组看作完全二叉树，从 n-1 到 0 依次调用 max_heapify_down(i)，调用时只用确保子树，时间复杂度为 O(n)</li>
</ul>]]></content><author><name>syh</name><email>songibicf@gmail.com</email></author><category term="算法" /><summary type="html"><![CDATA[1. 优先队列接口]]></summary></entry><entry><title type="html">BFS</title><link href="http://localhost:4000/%E7%AE%97%E6%B3%95/2022/09/28/%E7%AE%97%E6%B3%95-0008.html" rel="alternate" type="text/html" title="BFS" /><published>2022-09-28T00:00:00+08:00</published><updated>2022-09-28T00:00:00+08:00</updated><id>http://localhost:4000/%E7%AE%97%E6%B3%95/2022/09/28/%E7%AE%97%E6%B3%95-0008</id><content type="html" xml:base="http://localhost:4000/%E7%AE%97%E6%B3%95/2022/09/28/%E7%AE%97%E6%B3%95-0008.html"><![CDATA[<h3 id="1-graph">1. Graph</h3>

<p>图的应用例子：</p>
<ul>
  <li>任何网络系统，例如道路交通、计算机网络、社交网络</li>
  <li>任何离散系统的状态空间可以表示为图，例如 Chess、Teris、Rubik’s cube</li>
</ul>

<p><strong>图定义：</strong></p>
<ul>
  <li>G = (V, E)</li>
  <li>有向边由有序对表示，例如 (u, v)，无向边由无序对表示，例如 {u, v}</li>
  <li>简单图：
    <ul>
      <li>edges are distinct</li>
      <li>边连接不同的顶点</li>
      <li>|E| = O(|V|^2)</li>
    </ul>
  </li>
  <li>出边集：Adj<sup>+</sup>(u) = {v ∈ V | (u, v) ∈ E}</li>
  <li>入边集: Adj<sup>-</sup>(u) = {v ∈ V | (v, u) ∈ E}</li>
  <li>出度: deg<sup>+</sup>(u) = |Adj<sup>+</sup>(u)|</li>
  <li>入度: deg<sup>-</sup>(u) = |Adj<sup>-</sup>(u)|</li>
  <li>对于无向图 Adj<sup>-</sup>(u) = Adj<sup>+</sup>(u)， deg<sup>-</sup>(u) = deg<sup>+</sup>(u)</li>
</ul>

<p><strong>图的表示：</strong></p>
<ul>
  <li>对于图 G = (V, E)，存储 u 的所有出边 Adj(u)。</li>
  <li>使用 Set 来存储所有的顶点，可以使用直接访问数组或哈希表，size 为 Θ(|V|)</li>
  <li>对于每个顶点，为了存储邻接的顶点，使用数组或者链表。每个顶点邻接列表 size 为 Θ(deg(u))</li>
  <li>图存储需要 Θ(|V| + |E|) 空间</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># 图的直接访问数组表示
A1 = [
      [1, 4, 3],
      [0],
      [3],
      [0, 2],
      [0]
    ]

# 图的哈希表表示
A1 = {
      0: {1, 3, 4},
      1: {0},
      2: {3},
      3: {0, 2},
      4: {0}
    }
</code></pre></div></div>

<p><strong>路径：</strong></p>
<ul>
  <li>路径：顶点序列 p = (v1, v2, . . . , vk)，(vi, vi+1) ∈ E</li>
  <li>简单路径：没有重复顶点，或者说没有环的路径</li>
  <li>路径的长度：路径中的边数</li>
  <li>u 和 v 之间的距离：从 u 到 v 的最短路径的长度</li>
</ul>

<p><strong>图路径问题：</strong></p>
<ul>
  <li>single_pair_reachability(G, s, t): 从 s 到 t 有路径吗</li>
  <li>single_pair_shortest_path(G, s, t): 找到 s 到 t 的最短路径</li>
  <li>single_source_shortest_paths(G, s): 返回 s 到其它所有顶点的最短路径树</li>
</ul>

<p><strong>Shortest Paths Tree：</strong></p>
<ul>
  <li>得到从 s 到其他所有顶点的最短路径</li>
  <li>用 P(v) 代表从 s 到 v 顶点最短路径上的 v 的上一个顶点</li>
</ul>

<h3 id="2-bfs">2. BFS</h3>
<p><strong>BFS：</strong></p>
<ul>
  <li>对于 v ∈ V，如何计算 δ(s, v) 和 P(v)</li>
  <li>在一个集合数据类型中存储 δ(s, v) 和 P(v)，把 v 映射到距离和 P(v)</li>
  <li><strong>Idea:</strong> 按距离递增的顺序探索图结点</li>
  <li>Goal：计算所有的 Level sets L<sub>i</sub> = {v | v ∈ V and d(s, v) = i}</li>
  <li>Claim: L<sub>i</sub> 中每个顶点 v 一定与 L<sub>i-1</sub> 中的某个顶点 u 邻接，v ∈ Adj(u)</li>
  <li><strong>Invariant:</strong> δ(s, v) and P(v) have been computed correctly for all v in any L<sub>j</sub> for j &lt; i。对于当前层的顶点，上一层的顶点已经全部得到了最短的路径。</li>
</ul>

<p>BFS 按照层次顺序得到顶点 L<sub>i</sub>，且 L<sub>i</sub> 中的顶点是最短路径为 i 可以到达的顶点。</p>

<p><strong>BFS 步骤：</strong></p>
<ul>
  <li>base case (i=1): L0 = {s}, δ(s, s) = 0, P(s) = None</li>
  <li>Inductive Step: 为了计算 L<sub>i</sub>:
    <ul>
      <li>对于 L<sub>i-1</sub> 中每个顶点 u
        <ul>
          <li>对于每个顶点 v ∈ Adj(u)，并且 v 不出现在之前的层中，把 v 添加到 L<sub>i</sub>，设置 δ(s, v) = i，P(v) = u</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>重复计算 L<sub>i</sub>，直到 L<sub>i</sub> 不能再添加顶点</li>
  <li>对于剩余的顶点，设置 δ(s, v) = ∞</li>
</ul>

<p>BFS 的运行时间为 O(|V| + |E|)</p>]]></content><author><name>syh</name><email>songibicf@gmail.com</email></author><category term="算法" /><summary type="html"><![CDATA[1. Graph]]></summary></entry><entry><title type="html">测试</title><link href="http://localhost:4000/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0/2022/09/26/%E8%BD%AF%E4%BB%B6-0004.html" rel="alternate" type="text/html" title="测试" /><published>2022-09-26T00:00:00+08:00</published><updated>2022-09-26T00:00:00+08:00</updated><id>http://localhost:4000/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0/2022/09/26/%E8%BD%AF%E4%BB%B6-0004</id><content type="html" xml:base="http://localhost:4000/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0/2022/09/26/%E8%BD%AF%E4%BB%B6-0004.html"><![CDATA[<h3 id="1-validation">1. Validation</h3>

<p>测试是 Validation 的重要一步。验证的目的是发现程序中存在的问题。Validation 包括：</p>
<ul>
  <li>形式推理 (Formal reasoning)：通过推导，证明程序的正确性。</li>
  <li>代码审查 (Code review)：让其他人仔细阅读你的代码。</li>
  <li>测试 (Testing)：在精心选择的输入上验证程序的输出。</li>
</ul>

<p>即使进行了最好的验证，在软件上也很难实现最好的质量。典型的 residual defect rates:</p>
<ul>
  <li>1 - 10 defects/kloc: 典型的工业软件</li>
  <li>0.1 - 1 defects/kloc: 高质量验证的软件，例如成熟浏览器的 JavaScript 库</li>
  <li>0.01 - 0.1 defects/kloc: 最好的、安全关键的验证。例如航空领域软件</li>
</ul>

<p>软件测试中的有些方法是不可行的：</p>
<ul>
  <li>详尽测试</li>
  <li>Haphazard testing</li>
  <li>随机或者统计测试</li>
</ul>

<h3 id="2-test-first-编程">2. Test-first 编程</h3>

<ul>
  <li>module：软件系统的一部分，可以被设计、实现、测试、推理，并且该部分与系统的其他部分独立。该节主要关注的模块为函数，之后会关注 class</li>
  <li>specification：描述模块的行为。</li>
  <li>一个模块通过实现 (implementation) 来提供功能，并且 clients 可以使用该模块。</li>
  <li>test case：测试用例，特定选择的输入，同时在 specification 中包含期望输出。</li>
  <li>test suite：一个模块的测试用例的集合</li>
</ul>

<p>test-first programming: 在写代码前先写 spec 和 tests。例如写函数的步骤如下：</p>
<ol>
  <li>Spec：为函数写一个 specification</li>
  <li>Test：写与 specification 对应的测试</li>
  <li>Implement：具体实现</li>
</ol>

<h3 id="3-系统测试">3. 系统测试</h3>

<p>系统测试：按照特定的方式选择测试例子，按以下三个属性设计 test suite：</p>
<ul>
  <li>Correct：correct test suite 是 specification 合法的 client，接受所有合法的实现。</li>
  <li>Thorough：一个彻底的 test suite 可以发现实现中实际的 bug</li>
  <li>Small：test suite 要尽可能的小</li>
</ul>

<h3 id="4-通过划分来选择测试用例">4. 通过划分来选择测试用例</h3>]]></content><author><name>syh</name><email>songibicf@gmail.com</email></author><category term="软件构造" /><summary type="html"><![CDATA[1. Validation]]></summary></entry><entry><title type="html">TypeScript 基础</title><link href="http://localhost:4000/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0/2022/09/23/%E8%BD%AF%E4%BB%B6-0003.html" rel="alternate" type="text/html" title="TypeScript 基础" /><published>2022-09-23T00:00:00+08:00</published><updated>2022-09-23T00:00:00+08:00</updated><id>http://localhost:4000/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0/2022/09/23/%E8%BD%AF%E4%BB%B6-0003</id><content type="html" xml:base="http://localhost:4000/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0/2022/09/23/%E8%BD%AF%E4%BB%B6-0003.html"><![CDATA[<h3 id="1-snapshot-图">1. Snapshot 图</h3>
<p>snapshot 图：表示程序运行时的内部状态，包括 stack (运行中的方法和局部变量) 和 heap (当前存在的对象)。</p>

<p>改变一个变量或字段：改变了变量的箭头指向
改变一个可修改对象的内容：改变值内部的引用</p>

<p>string 是不可修改的类型，当创建之后，<strong>值</strong>不能被改变。可修改对象则是可以改变对象的值。</p>

<p><strong>不可重新分配的引用</strong>：变量只能赋值一次，并且永远不能被重新赋值，用 const 来声明。</p>

<p>不可重新分配的引用可以指向可修改的值，例如</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const arr:Array&lt;string&gt; = ["a"];
arr.push("b")
</code></pre></div></div>

<p>可重新分配的引用可以指向不可修改的值，此时变量的值可以改变。例如：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let s:string = "a";
s = "ab";
</code></pre></div></div>

<p>函数调用中参数传递为值传递，即参数接受一个初始值，在函数内部参数可以任意的重新分配，不会影响到 caller。大多数的编程语言都是值传递，例如 Python, Java, C。少数语言，如 C++，C# 提供引用传递。</p>

<h3 id="2-typescript-基础">2. TypeScript 基础</h3>

<p>TypeScript 中的 Array 与 Python 中的 list 类似。</p>

<table>
  <tbody>
    <tr>
      <td>TypeScript</td>
      <td>Python</td>
    </tr>
    <tr>
      <td>lst.length</td>
      <td>len(lst)</td>
    </tr>
    <tr>
      <td>lst.push(e)</td>
      <td>lst.append(e)</td>
    </tr>
    <tr>
      <td>if (lst.length === 0)</td>
      <td>if not list: …</td>
    </tr>
    <tr>
      <td>lst.includes(e)</td>
      <td>e in lst</td>
    </tr>
    <tr>
      <td>lst.splice(i, 1)</td>
      <td>del lst[i]</td>
    </tr>
  </tbody>
</table>

<p>Map 与 Python 中字典相似。在 Python 中，键必须是可哈希的。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Python 中的可哈希：一个对象的哈希值如果在其生命周期内绝不改变，并可以同其他对象进行比较 (具有 __eq__ 方法)，就被称为可哈希的 (它需要具有 __hash__ 方法)。

可哈希行使得对象能够作为字典键或集合成员使用，这些数据结构在内部使用哈希值。
</code></pre></div></div>

<table>
  <tbody>
    <tr>
      <td>TypeScript</td>
      <td>Python</td>
    </tr>
    <tr>
      <td>map.set(key, val)</td>
      <td>map[key] = val</td>
    </tr>
    <tr>
      <td>map.get(key)</td>
      <td>map[key]</td>
    </tr>
    <tr>
      <td>map.has(key)</td>
      <td>key in map</td>
    </tr>
    <tr>
      <td>map.delete(key)</td>
      <td>del map[key]</td>
    </tr>
    <tr>
      <td>map.size</td>
      <td>len(map)</td>
    </tr>
  </tbody>
</table>

<p>Set 类型
| TypeScript | Python |
| s.has(e) | e in s|
| s.add(e) | s.add(e) |
| s.delete(e) | s.remove(e) |
| s.size | len(s) |</p>

<h4 id="21-generics">2.1 Generics</h4>
<p>不像 Python 中的容器类型。 TypeScript 中的容器可以严格限定容器中对象的类型。当向容器中添加项时，TypeScript 会对项进行静态检查。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># 容器例子
let cities: Array&lt;string&gt;;
let cities: string[]
let number: Set&lt;number&gt;;
let turtles: Map&lt;string, Turtle&gt;
</code></pre></div></div>

<h4 id="22-iteration">2.2 Iteration</h4>

<p>Python 中：</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for city in cities:
    print(city)

for num in numbers:
    print(num)

for key in turtles:
    print("%s: %s" %(key, turtles[key]))
</code></pre></div></div>

<p>TypeScript:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for (const city of cities) {
    console.log(city);
}

for (const num of numbers) {
    console.log(num);
}

for (const key of turtles.keys()) {
    console.log(key + ":" + turtles.get(key));
}
</code></pre></div></div>

<p>在 array 和 map 中使用 <code class="language-plaintext highlighter-rouge">get()</code> 去访问一个 key，如果 key 不存在，会返回特殊的值 <code class="language-plaintext highlighter-rouge">undefined</code></p>

<p>JavaScript 中数组实际上是 sparse 的，可以在任意的索引位置放置一个新元素。</p>

<h4 id="23-变量声明">2.3 变量声明</h4>

<p>JavaScript 中可以使用 let、const、var 来声明一个变量。let 声明的变量可重新赋值，const 声明的为不可重新分配的变量。var 为旧的风格，因为声明变量的 scope 为整个 functions，而 let 声明的变量 scope 为闭合花括号内。</p>

<h4 id="24-对象字面量和对象类型">2.4 对象字面量和对象类型</h4>

<p>record type: 一个对象，只有 named fields，没有方法。在 C/C++ 里面叫做 struct。</p>

<p>TypeScript 可以使用 {field1:value1, field2:value2, …}，快速创建具有特定值的 record type 对象。</p>

<p>解构赋值：通过解构赋值，可以将属性/值从对象/数组中取出，赋值给其他变量。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let a, b, rest;
[a, b] = [10, 20]

[a, b, ...rest] = [10, 20, 30, 40, 50];

({a, b} = {a:10, b:20});
</code></pre></div></div>

<h3 id="3-api-文档与工具">3. API 文档与工具</h3>

<ul>
  <li>MDN： JavaScript 的通用功能，包含浏览器指定的 API</li>
  <li>Node.js: outside-the-browser API</li>
  <li>TypeScript Handbook：与 TypeScript 有关的 API</li>
</ul>

<p>MDN 文档的结构：</p>

<ol>
  <li>Description
    <ul>
      <li>类的简短描述</li>
    </ul>
  </li>
  <li>Constructor</li>
  <li>Instance properties</li>
  <li>Instance methods
    <ul>
      <li>method signature</li>
      <li>full description</li>
      <li>parameters</li>
      <li>returns</li>
    </ul>
  </li>
</ol>

<p>Node.js：JavaScript 的解释器
npm：”Node Package Manager”，有两个功能。首先，它管理用于程序的外部包库。其次，npm 是其他编程工具的通用运行环境。</p>

<p>使用 TypeScript prompt:</p>
<ol>
  <li>npm install ts-node</li>
  <li>npx ts-node</li>
</ol>]]></content><author><name>syh</name><email>songibicf@gmail.com</email></author><category term="软件构造" /><summary type="html"><![CDATA[1. Snapshot 图 snapshot 图：表示程序运行时的内部状态，包括 stack (运行中的方法和局部变量) 和 heap (当前存在的对象)。]]></summary></entry><entry><title type="html">二叉树 II</title><link href="http://localhost:4000/%E7%AE%97%E6%B3%95/2022/09/21/%E7%AE%97%E6%B3%95-0006.html" rel="alternate" type="text/html" title="二叉树 II" /><published>2022-09-21T00:00:00+08:00</published><updated>2022-09-21T00:00:00+08:00</updated><id>http://localhost:4000/%E7%AE%97%E6%B3%95/2022/09/21/%E7%AE%97%E6%B3%95-0006</id><content type="html" xml:base="http://localhost:4000/%E7%AE%97%E6%B3%95/2022/09/21/%E7%AE%97%E6%B3%95-0006.html"><![CDATA[<h3 id="1-平衡二叉树">1. 平衡二叉树</h3>

<p>之前提到二叉树目的是对于树高为 h 的树，使得算法的时间复杂度为 O(h), 并且尽可能维持 h = O(logn)，最终 O(h)=O(logn)。那么，如何维持树的高度 h = O(logn) ?</p>

<p><strong>平衡二叉树</strong>：在动态操作时，例如 insert(x), delete(x), 可以维持高度为 O(logn) 的二叉树。有许多平衡的范式 (Red-Black Trees, Splay Trees, 2-3 Trees,…)。最早提出的平衡范式为 AVL 树 (Adelson-Velsky and Landis, 1962)。</p>

<p>树的旋转：</p>
<ul>
  <li>目的：降低树的高度，但是不改变遍历顺序</li>
  <li>旋转操作只是修改了指针，时间复杂度为 O(1)</li>
</ul>

<div align="center">
<img src="/image/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95-0006-1.png" width="500" />
<p></p>
</div>

<p>旋转的特性：O(n) 次旋转可以将二叉树转换为具有相同遍历顺序的任何其他二叉树。</p>

<h3 id="2-avl-树">2. AVL 树</h3>

<ul>
  <li>AVL 树保持了 height-balance
    <ul>
      <li>一个结点叫做 height-balance，如果左子树和右子树的高度最多差 1</li>
      <li>一个结点的偏斜 (skew) 为其右子树的高度减去左子树的高度</li>
      <li>如果 skew 为 -1， 0， 1， 那么该结点是 height-balance</li>
    </ul>
  </li>
  <li>所有结点为 height-balance 的二叉树，其高度 h = O(log n)
    <ul>
      <li>高度为 h 二叉树的结点树 F(h) = 1 + F(h-1) + F(h-2) &gt;= 2F(h-2)</li>
    </ul>
  </li>
  <li>假设增加或者删除叶子结点，导致原先 height-balance 的树不平衡
    <ul>
      <li>那么仅叶子结点的祖先结点在高度或者 skew 上有改变</li>
      <li>高度最多改变 ±1, 所以 skew 的绝对值还是  ≤ 2</li>
      <li>修复的 idea: 从叶子结点开始，一直到根结点，依次修复，使得叶子结点的所有祖先结点 height-balance</li>
    </ul>
  </li>
</ul>

<h4 id="21-avl-树的-rebalance">2.1 AVL 树的 Rebalance</h4>

<p><strong>Local Rebalance</strong>：给定一个二叉树结点 B</p>
<ul>
  <li>假设其 skew 为 2</li>
  <li>B 子树中其他结点为 height-balanced</li>
  <li>那么，B 子树通过一次或者两次旋转操作可以变平衡</li>
</ul>

<hr />

<p><strong>证明</strong>：
因为 B 的 skew 为 2，那么 B 的右孩子结点一定存在，记为 F。</p>

<p><strong>Case 1</strong>: F 的 skew 为 0。</p>

<p><strong>Case 2</strong>: F 的 skew 为 1。</p>

<p>对于这两种情况，都是对 B 执行左旋操作。</p>

<div align="center">
<img src="/image/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95-0006-2.png" width="500" />
<p></p>
</div>

<p>假设 h = height(A), 那么原始状态下 height(G) = h+1, 情况 1 中 height(D) = h+1, 情况 2 中 height(D) = h。
旋转后，B 的 skew 在情况 1 为 1，情况 2 为 0，所以 B 是 height-balanced。旋转后，F 的 skew 为 -1，F height-balanced。</p>

<p><strong>Case 3</strong>：
F 的 skew 为 -1，那么得先对 F 执行右旋，再左旋。证明和上面类似。</p>

<div align="center">
<img src="/image/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95-0006-3.png" width="500" />
<p></p>
</div>

<hr />

<p><strong>Global Rebalance</strong>：对于 height-balanced 树 T，增加或者移除一个叶子结点，得到 T’。之后可以通过最多 O(logn) 次旋转，重新得到平衡二叉树 T’‘。</p>

<p><strong>证明</strong>：</p>
<ul>
  <li>仅叶子结点的祖先，高度受到了影响。且最多有 O(logn) 个祖先。</li>
  <li>把最低的受到影响的祖先记为 X</li>
  <li>如果 T 中是增加了一个叶子结点：
    <ul>
      <li>插入操作增加了 X 的高度，可以对 X 进行 local rebalance 操作</li>
      <li>在旋转后保持了平衡</li>
    </ul>
  </li>
  <li>如果 T 中移除了一个叶子结点
    <ul>
      <li>删除可能减少了 X 的一个孩子结点的高度，但是 X 的高度未受影响</li>
      <li>删除也可能导致 X 的高度减少 1，X 的父结点也可能不平衡</li>
      <li>所以得重新平衡 X 的祖先，但是最多 O(logn) 次</li>
    </ul>
  </li>
  <li>因此，O(logn) 次旋转操作可以变回平衡二叉树</li>
</ul>

<h3 id="3-计算高度">3. 计算高度</h3>

<p>如果判断结点 X 是否 height-balanced? 这需要知道子树的高度，因此要计算子树的高度。</p>

<p>方法：subtree augmentation</p>
<ul>
  <li>在结点处附加上<strong>子树高度</strong>的属性</li>
  <li>
    <p>X 结点的子树高度可以用 O(1) 时间计算出来</p>

    <p>h(X) = max( h(X.left), h(X.right) ) + 1</p>
  </li>
  <li>在动态操作时，也必须维持高度属性</li>
</ul>

<hr />

<p>Steps to Augment a Binary Tree:</p>
<ul>
  <li>为了在二叉树中增添子树属性 p，需要在每个结点处存储属性 p，并且可以用 O(1) 时间，从结点的孩子结点计算出属性值。</li>
  <li>那么，增加属性 p，不会改变动态操作的时间复杂度。</li>
</ul>]]></content><author><name>syh</name><email>songibicf@gmail.com</email></author><category term="算法" /><summary type="html"><![CDATA[1. 平衡二叉树]]></summary></entry><entry><title type="html">二叉树 I</title><link href="http://localhost:4000/%E7%AE%97%E6%B3%95/2022/09/16/%E7%AE%97%E6%B3%95-0005.html" rel="alternate" type="text/html" title="二叉树 I" /><published>2022-09-16T00:00:00+08:00</published><updated>2022-09-16T00:00:00+08:00</updated><id>http://localhost:4000/%E7%AE%97%E6%B3%95/2022/09/16/%E7%AE%97%E6%B3%95-0005</id><content type="html" xml:base="http://localhost:4000/%E7%AE%97%E6%B3%95/2022/09/16/%E7%AE%97%E6%B3%95-0005.html"><![CDATA[<h3 id="1-二叉树">1. 二叉树</h3>

<p>序列结构介绍了数组、链表、动态数组，操作的时间复杂度见上表。集合数据结构介绍了数组、有序数组、直接访问数组、hash 表。但是这些数据结构在某一项或者两项操作的时间复杂度占优势，无法兼顾全部操作的时间复杂度。而通过二叉树可以实现 “Goal” 一栏的时间复杂度。</p>

<p>二叉树是基于指针的数据结构，每个结点包含三个指针，分别为 node.parent, node.left, node.right。</p>

<p><strong>术语</strong>：</p>
<ul>
  <li>根：在树中如果某一结点没有父结点，那么该结点叫做树的根</li>
  <li>叶结点：没有孩子结点</li>
  <li>结点 x 的深度：从根结点到该结点的路径长度</li>
  <li>结点 x 的高度：以 x 为根的子树的最大深度</li>
</ul>

<p>为什么要使用树结构？</p>

<p>树结构也是也指针为基础的，每个结点包含三个指针。但是与链表不同，在链表中每访问一个结点都得从前往后开始遍历，时间复杂度为 O(n)。二叉树通过每个结点的 2 个分支，将树的高度最低可以降到 O(logn)。</p>

<p>因此，二叉树所有算法的基本 idea 为：对于树高为 h 的树，设计算法，使得操作的时间复杂度为 O(h), 并且尽可能维持 h = O(logn)，使得最后算法的时间复杂度为 O(h)=O(logn)</p>

<p>二叉树的遍历，如果按照中序遍历：</p>
<ul>
  <li>结点 x 左子树的结点在 x 之前</li>
  <li>结点 x 右子树的结点在 x 之后</li>
  <li>从根结点开始递归遍历</li>
</ul>

<h3 id="2-树的遍历">2. 树的遍历</h3>

<p>以下全部按中序遍历，介绍了遍历中结点出现的顺序。</p>

<p>以结点 x 为根的子树中<strong>第一个结点</strong>：</p>
<ul>
  <li>如果 x 有左孩子，递归返回左子树的第一个结点</li>
  <li>否则，x 是第一个结点，返回 x</li>
  <li>运行时间为 O(h)</li>
</ul>

<p>以结点 x 为根的子树中<strong>最后一个结点</strong>：</p>
<ul>
  <li>如果 x 有右孩子，递归返回右子树的最后一个结点</li>
  <li>否则，x 是最后一个结点，返回 x</li>
</ul>

<p>结点 x 的<strong>后继结点</strong>：</p>
<ul>
  <li>如果 x 有右子树，返回右子树第一个结点</li>
  <li>否则，返回 x 的最低祖先结点，且 x 要在该祖先结点的左子树中</li>
  <li>运行时间为 O(h)</li>
</ul>

<p>结点 x 的<strong>前驱结点</strong>：</p>
<ul>
  <li>如果 x 有左子树，返回左子树最后一个结点</li>
  <li>否则，返回 x 的最低祖先结点，x 要在该祖先结点的右子树中</li>
</ul>

<h3 id="3-动态操作">3. 动态操作</h3>

<p>在 x 结点之后<strong>插入</strong>新结点 y：</p>
<ul>
  <li>如果 x 没有右子树，把 y 放入 x 的右孩子结点</li>
  <li>否则，把 y 放入 x 后继结点 s 的左孩子结点中。s 一定没有左孩子，因为 s 是 x 右子树第一个结点。y 相当于放在 s 的前面。</li>
</ul>

<p><strong>删除</strong>结点 x：</p>
<ul>
  <li>如果 x 是叶子结点，直接删除</li>
  <li>否则，x 有孩子结点。此时不能直接删除 x，得与其他结点交换，让 x 变到叶子结点。
    <ul>
      <li>如果 x 有左孩子，让 x 与其<strong>前驱结点</strong>交换，递归删除 x 结点</li>
      <li>否则，让 x 与其<strong>后继结点</strong>交换，递归删除 x 结点</li>
    </ul>
  </li>
  <li>运行时间为 O(h)</li>
</ul>

<h3 id="4-应用">4. 应用</h3>

<h4 id="41-set">4.1 Set</h4>

<ul>
  <li>idea：集合中重要的是 <strong>find</strong> 操作，为了用树实现比较，常用的是二叉搜索树 (Binary Search Tree / BST)。
    <ul>
      <li>中序遍历得到的结果是按键排列好的</li>
      <li>等价的 BST 属性：对于每个结点，左子树中的值小于结点的值，右子树中的值大于结点的值。</li>
    </ul>
  </li>
  <li>在树中查找键值 k
    <ul>
      <li>如果 k 小于结点 x 的值，在左子树中递归查找</li>
      <li>如果 k 大于结点 x 的值，在右子树中递归查找</li>
      <li>否则，返回 x</li>
    </ul>
  </li>
</ul>

<h4 id="42-sequence">4.2 Sequence</h4>

<ul>
  <li>idea：使得中序遍历得到的顺序是按序列顺序排列的</li>
  <li>查找 i 结点的操作，调用 subtree_at(i)。但是需要从头开始进行中序遍历，时间复杂度为 O(n)。</li>
  <li>但是，如果可以用 O(1) 的时间复杂度得到<strong>子树的大小</strong> (size)，访问 i 结点的操作时间复杂度可以降到 O(h)。子树大小指子树中结点的总个数。
    <ul>
      <li>首先检查<strong>左子树</strong>的大小 n<sub>L</sub>，并且与 i 比较</li>
      <li>如果 i &lt; n<sub>L</sub>，说明第 i 个结点在左子树，递归查找</li>
      <li>如果 i &gt; n<sub>L</sub>，在右子树上递归查找，且 i’ = i - n<sub>L</sub> - 1</li>
      <li>否则，i = n<sub>L</sub>，则根结点索引值为 i，返回根结点</li>
    </ul>
  </li>
  <li>通过扩增 (augmentation) 来记录每个结点子树的尺寸
    <ul>
      <li>在 node 中加入属性 node.size</li>
      <li>当加入一个新的叶子结点，对于该结点的所有祖先结点，size 都加 1</li>
      <li>当删除一个叶子结点，对于该结点的所有祖先结点，size 减少 1</li>
    </ul>
  </li>
  <li>subtree augmentation：
    <ul>
      <li>每个结点存储 O(1) 额外的属性</li>
      <li>subtree 的属性可以从其左子树和右子树的属性用 O(1) 时间计算出来</li>
      <li>无论对树进行什么修改操作，都得更新结点的属性</li>
      <li>可能的 subtree properties：sum，product，min，max，height</li>
      <li>不能作为 subtree properties：index，depth</li>
    </ul>
  </li>
</ul>

<p>时间复杂度：</p>
<div align="center">
<img src="/image/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95-0005-1.png" width="500" />
<p></p>
</div>]]></content><author><name>syh</name><email>songibicf@gmail.com</email></author><category term="算法" /><summary type="html"><![CDATA[1. 二叉树]]></summary></entry><entry><title type="html">环境配置</title><link href="http://localhost:4000/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0/2022/09/14/%E8%BD%AF%E4%BB%B6-0001.html" rel="alternate" type="text/html" title="环境配置" /><published>2022-09-14T00:00:00+08:00</published><updated>2022-09-14T00:00:00+08:00</updated><id>http://localhost:4000/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0/2022/09/14/%E8%BD%AF%E4%BB%B6-0001</id><content type="html" xml:base="http://localhost:4000/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0/2022/09/14/%E8%BD%AF%E4%BB%B6-0001.html"><![CDATA[<p>课程名称是 Software Construction，网站为：<a href="https://web.mit.edu/6.031/www/sp22/">https://web.mit.edu/6.031/www/sp22/</a>。课程用的是 JavaScript，开始先安装软件。全部在 WSL 下安装。</p>

<h3 id="1-安装-typescript">1. 安装 TypeScript</h3>
<h4 id="11-node">1.1 node</h4>

<p>按照说明安装</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>https://github.com/nodesource/distributions/blob/master/README.md
</code></pre></div></div>

<p>检查：</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>node --version
</code></pre></div></div>

<h4 id="12-install-typescript">1.2 install TypeScript</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo -H npm install -g typescript

# 检查
tsc --version
</code></pre></div></div>

<h3 id="2-git-配置">2. Git 配置</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># 用户名和邮箱
git config --global user.name "Your Name"
git config --global user.email email@email

# 设置 alias，以后输入 git lol 就可代替 log 后面的一串命令
git config --global alias.lol "log --graph --oneline --decorate --color --all"

# 列出目前的 config
git config --list
</code></pre></div></div>

<h4 id="21-git-基础概念">2.1 Git 基础概念</h4>

<p>Git 是一种版本控制系统 (version control system, VCS)。一些基础的概念：</p>
<ul>
  <li>存储库 (repository)：包含与项目相关所有文件的文件夹，以及对这些文件的整个提交历史。</li>
  <li>提交 (commit)：给定时间点时存储库中文件的快照。</li>
  <li>添加/暂存 (add/stage)：在对文件的更改可以提交到存储库之前，必须添加或暂存相关文件。</li>
  <li>克隆 (clone)：开发人员可以从 github 上 “克隆” 远程存储库，得到一份本地存储库。之后可以对本地存储库进行修改。</li>
  <li>push：将本地的 commit 发送到远程存储库中，相当于上传修改。</li>
  <li>pull：检查远程存储库的提交，并将远程存储库中的修改写入本地存储库，相当于得到最新版本。</li>
</ul>]]></content><author><name>syh</name><email>songibicf@gmail.com</email></author><category term="软件构造" /><summary type="html"><![CDATA[课程名称是 Software Construction，网站为：https://web.mit.edu/6.031/www/sp22/。课程用的是 JavaScript，开始先安装软件。全部在 WSL 下安装。]]></summary></entry><entry><title type="html">静态检查</title><link href="http://localhost:4000/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0/2022/09/14/%E8%BD%AF%E4%BB%B6-0002.html" rel="alternate" type="text/html" title="静态检查" /><published>2022-09-14T00:00:00+08:00</published><updated>2022-09-14T00:00:00+08:00</updated><id>http://localhost:4000/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0/2022/09/14/%E8%BD%AF%E4%BB%B6-0002</id><content type="html" xml:base="http://localhost:4000/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0/2022/09/14/%E8%BD%AF%E4%BB%B6-0002.html"><![CDATA[<h3 id="1-types">1. Types</h3>

<p>数据类型：值 + 操作</p>

<p>TypeScript 的几个内建类型：</p>
<ul>
  <li>number，表示整数和浮点数</li>
  <li>boolean</li>
  <li>string，表示字符序列</li>
</ul>

<p>Operation：有输入，并且产生输出的<strong>函数</strong>，syntax 包括：</p>
<ul>
  <li>operator</li>
  <li>function</li>
  <li>method</li>
  <li>property</li>
</ul>

<p>TypeScript 是静态类型语言，变量可以被指定一个类型，在编译时会进行类型检查，并且编译器可以推导出表达式的类型。JavaScript 和 Python 是动态类型语言，只有在运行时才可进行类型检查。</p>

<p>TypeScript 相比于 JavaScript 增加了静态类型检查，反映了软件工程领域一条规则，即对于创建和维护大型的软件来说，使用静态类型是不可或缺的。</p>

<h3 id="2-静态检查动态检查不检查">2. 静态检查，动态检查，不检查</h3>

<p>语言可以提供的三类自动检查：</p>
<ul>
  <li>静态检查：在编译时就可以发现程序中的类型错误</li>
  <li>动态检查：在代码实际运行时发现错误</li>
  <li>不检查：语言不提供任何检查功能</li>
</ul>

<p>提供静态检查比提供动态检查要好，提供动态检查比不检查要好。</p>

<p>静态检查能发现的错误：</p>
<ul>
  <li>句式错误：例如多余的标点符号或者可疑的词。</li>
  <li>错误拼写的名称：例如 Math.sine(2)</li>
  <li>错误的参数数目：例如 Math.sin(30, 20)</li>
  <li>错误的参数类型：例如 Math.sin(“30”)</li>
  <li>错误的返回值：  例如一个函数声明返回 number，却 return “30”，</li>
</ul>

<p>动态检查可以发现的错误：</p>
<ul>
  <li>特定的不合法的参数值：例如表达式 x/y，当 y 是 0 时，引发错误。</li>
  <li>不合法的类型转换：例如 int(“hello”)</li>
  <li>索引越界：数组中的 IndexError</li>
  <li>在错误的对象引用上调用方法：例如 underfined 或者 null 上调用方法</li>
</ul>

<p>静态类型可以检测与变量类型有关的错误，但是通常不能发现与合法类型中特定值有关的错误。</p>

<p>在 TypeScript 中，TypeScript 提供静态检查，但是运行时的行为完全由 JavaScript 提供。但是 JavaScript 在设计时，对于大多数的动态检查都不支持。例如，当 string 或者 array 越界，JavaScript 返回一个特殊的值 undefined，而不是像 Python 一样 throw IndexError；当除以 0 时，JavaScript 返回代表 infinity 的特殊值，同样不是引发错误。不提供检查使得 bug 更难被发现，因为特殊的值可能会继续进行接下来的计算，直到发生错误。</p>

<h4 id="21-surprisenumber-is-not-a-true-number">2.1 Surprise：<code class="language-plaintext highlighter-rouge">number</code> is not a true number</h4>

<p>TypeScript 的另一个陷阱是，数字类型有几个例子，与常见的实数运算不同。</p>

<ul>
  <li>整数的有限精度：在 TypeScript 中，所有的数字都是浮点数，这意味着大的整数只能近似表示。从 -2^53 到 2^53 的整数可以准确表示，但是当超过这个范围，只能保留最高有效二进制位。</li>
  <li>特殊的值：<code class="language-plaintext highlighter-rouge">number</code> 有几个特殊的值，这些值不是实数，例如 <code class="language-plaintext highlighter-rouge">Number.NaN</code>， <code class="language-plaintext highlighter-rouge">Number.POSITIVE_INFINITY</code>, <code class="language-plaintext highlighter-rouge">Number.NEGATIVE_INFINITY</code></li>
  <li>overflow 和 underflow：不能表示非常大的数与非常小的数。当表示超过 Number.MAX_VALUE 的数，结果是 POSITIVE_INFINITY。</li>
</ul>

<h3 id="3-javascript">3. JavaScript</h3>

<h4 id="31-array">3.1 Array</h4>

<p>Array：可变长度的序列，可以保持任何的类型，与 Python 中的 list 相似。</p>

<p>创建空数组：</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let array: Arary&lt;number&gt; = [];
</code></pre></div></div>

<h4 id="32-functions">3.2 Functions</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/**
 * Compute a hailstone sequence.
 * @param n starting number for sequence. Assumes n &gt; 0
 * @returns hailstone sequence starting with n and ending with 1
 */
function hailstoneSequence(n:number): Array&lt;number&gt; {
    let array: Array&lt;number&gt; = [];
    while (n != 1) {
        array.push(n);
        if (n % 2 === 0) {
            n = n / 2;
        } else {
            n = 3 * n + 1;
        }
    }
    array.push(n);
    return array;
}
</code></pre></div></div>

<h4 id="33-可修改的值-vs-重新分配变量">3.3 可修改的值 vs. 重新分配变量</h4>

<p>不可变类型：一旦创建，值不能改变的类型。string 类型在 Python 和 JavaScript 中都不可变。</p>

<p>TypeScript 允许声明不可变引用。变量一旦被赋值，永远不能重新分配。使用 const 来声明不可变引用。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const n: number = 5;
</code></pre></div></div>

<h3 id="4-文档假设">4. 文档假设</h3>

<p>写变量的类型其实对变量做出了假设，变量有自己的取值范围。 程序员必须有以下两个目标：</p>
<ul>
  <li>与计算机交流。首先得让编译器知道程序是正确的，例如句式是正确的，类型也正确。</li>
  <li>与其他人交流。程序得益于理解，其他人可以修改程序。</li>
</ul>

<h4 id="41-hacking-vs-engineering">4.1 hacking vs. engineering</h4>

<p>haching：</p>
<ul>
  <li>不进行代码测试</li>
  <li>把所有的细节都记在脑子里，假设你会永远记住它们，而不是把它们写在你的代码中。</li>
  <li>假设 bug 不存在或者很容易修复</li>
</ul>

<p>工程：</p>
<ul>
  <li>一次写一点，逐步测试</li>
  <li>在代码内附带上你的假设</li>
  <li>远离愚蠢的错误，静态检查有许多帮助</li>
</ul>

<p>6.031 目标：</p>
<ul>
  <li>Safe from bugs</li>
  <li>Easy to understand</li>
  <li>Ready for change</li>
</ul>

<p>为什么使用 TypeScript：</p>

<ul>
  <li>安全：TypeScript 有静态检查</li>
  <li>无处不在：TypeScript 直接编译成 JavaScript，广泛用在各领域中。相比于 Java，TypeScript 有更为丰富的类型系统，更适合创建现代用户接口和网页应用。</li>
</ul>]]></content><author><name>syh</name><email>songibicf@gmail.com</email></author><category term="软件构造" /><summary type="html"><![CDATA[1. Types]]></summary></entry><entry><title type="html">线性排序</title><link href="http://localhost:4000/%E7%AE%97%E6%B3%95/2022/09/08/%E7%AE%97%E6%B3%95-0004.html" rel="alternate" type="text/html" title="线性排序" /><published>2022-09-08T00:00:00+08:00</published><updated>2022-09-08T00:00:00+08:00</updated><id>http://localhost:4000/%E7%AE%97%E6%B3%95/2022/09/08/%E7%AE%97%E6%B3%95-0004</id><content type="html" xml:base="http://localhost:4000/%E7%AE%97%E6%B3%95/2022/09/08/%E7%AE%97%E6%B3%95-0004.html"><![CDATA[<h3 id="1-比较排序的时间复杂度下界">1. 比较排序的时间复杂度下界</h3>

<p>之前通过 hash，可以用  Θ(n) 的空间，实现时间复杂度为 O(1) 的 find 操作。目前从前往后依次介绍了 Array、Sorted Array、Direct Access Array、Hash Table，那么能够实现快速的排序吗？</p>

<p><strong>决策树模型：</strong></p>

<ul>
  <li>决策树是二叉树，每个结点代表一次比较后的结果，叶子结点代表最终结果</li>
  <li>决策树的叶子节点数 L &gt;= 可能的输出结果数, 由于对长度为 n 的数组排序，输出结果数为 n!，因此 L &gt;= n!</li>
  <li>树高度下界可根据 L 得出，为 Ω(log L)，替换 L 为 n!，log(n!) = Ω(n log n)。因此树高度下界为  Ω(nlogn)，即所需比较次数最少为 Ω(nlogn)。</li>
</ul>

<p>时间复杂度为 O(nlogn) 的<strong>归并排序</strong>在比较模型中已经是最优的排序算法，如果需要更快的排序算法，就不能采用比较的方法。</p>

<h3 id="2-直接访问数组排序">2. 直接访问数组排序</h3>

<ul>
  <li>假设所有的键为独特的非负整数，范围为 {0,…,u-1}，且 n &lt;= u</li>
  <li>把每个项插入到直接访问数组中，时间复杂度为 Θ(n)</li>
  <li>按顺序读取数组中的值，时间复杂度为 Θ(u)</li>
  <li>直接访问数组排序的时间复杂度为 Θ(u)</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def direct_access_sort(A):
    "Sort A assuming items have distinct non-negative keys"
    u = 1 + max([x.key for x in A])
    D = [None] * u
    for x in A:
        D[x.key] = x
    i = 0
    for key in range(u):
        if D[key] is not None:
            A[i] = D[key]
            i += 1
</code></pre></div></div>

<p>直接访问数组排序的时间复杂度与 u 有关。如果 u = Θ(n)，那么排序的时间复杂度为 Θ(n)。如果 u = Ω(n^2)，排序的时间复杂度很高。而且，直接访问数组无法处理存在重复键的情况。</p>

<h4 id="21-u--ωn2-的情况">2.1 u = Ω(n^2) 的情况</h4>

<p>当 u 比 n 大很多时，为了降低排序的时间复杂度，可以采用如下方法：</p>
<ul>
  <li>对于每一个项的键 k 来说，用元组 (a, b) 来表示，k = an + b</li>
  <li>相当于 a = k // n，b = k % n</li>
  <li>接下来对元组进行排序</li>
</ul>

<p><strong>元组排序 (Tuple Sort)</strong></p>
<ul>
  <li>项的键为元组，例如 x.key = (x.k1, x.k2, x.k3, …)，k1 是最高有效位</li>
  <li>排序时对元组中的每个有效位依次排序，先排序最低有效位，最后排序最高有效位</li>
  <li>例如：[32, 03, 44, 42, 22] =&gt; [42, 22, 32, 03, 44] =&gt; [03, 22, 32, 42, 44]</li>
</ul>

<p>按上面的方法，对元组可以有效的排序，但是当存在相同元组项时，如何进行排序呢？</p>

<h4 id="22-计数排序-counting-sort">2.2. 计数排序 (Counting Sort)</h4>

<p>为了存储有重复键的项，可以采取一下方法：</p>

<ul>
  <li>在数组每个索引位置，不仅仅是存储一个元素，而是存储一个 chain，保持具有多个相同索引值的项</li>
  <li>为了排序稳定性，chain 中必须记录项的插入顺序，可以使用序列来维持插入顺序</li>
  <li>排序时，按顺序读出所有的 chains</li>
  <li>算法总的时间复杂度为 O(n+u)，当 u = O(n) 时，时间复杂度为 O(n)</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def counting_sort(A):
    "Sort A assuming items have non-negative keys"
    u = 1 + max([x.key for x in A])
    D = [[] for i in range(u)]
    for x in A:
        D[x.key].append(x)
    i = 0
    for chain in D:
        for x in chain:
            A[i] = x
            i += 1
</code></pre></div></div>

<h3 id="3-基数排序-radix-sort">3. 基数排序 (Radix Sort)</h3>

<p>现在把元组排序和计数排序组合起来，得到基数排序，得到比直接访问数组排序更好的排序方法。</p>

<ul>
  <li>如果 u &lt; n^2，使用计数排序来排序元组 (a, b)</li>
  <li>先对最低有效位 b 进行排序，接着对 a 进行排序</li>
  <li>对元组一个有效位排序时间复杂度为 O(n)，总时间复杂度为 O(2n) = O(n)</li>
</ul>

<p>如果 key &lt; n^c, 每个 key 最多可以分成长度为 c 的元组。接着对元组进行元组排序，时间复杂度为 O(cn) = O(n)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def radix_sort(A):
    "Sort A assuming items have non-negative keys"
    n = len(A)
    u = 1 + max([x.key for x in A])
    c = 1 + (u.bit_length() // n.bit_length())
    class Obj: pass
    D = [Obj() for a in A]
    for i in range(n):
        D[i].digits = []
        D[i].item = A[i]
        high = A[i].key
        for j in range(c):
            high, low  = divmod(high, n)
            D[i].digits.append(low)
    for i in range(c):
        for j in range(n):
            D[j].key = D[j].digits[i]
        counting_sort(D)
    for i in range(n):
        A[i] = D[i].item
</code></pre></div></div>

<p>排序算法的时间复杂度：</p>

<div align="center">
<img src="/image/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95-0004-1.png" width="500" />
<p></p>
</div>]]></content><author><name>syh</name><email>songibicf@gmail.com</email></author><category term="算法" /><summary type="html"><![CDATA[1. 比较排序的时间复杂度下界]]></summary></entry><entry><title type="html">Hashing</title><link href="http://localhost:4000/%E7%AE%97%E6%B3%95/2022/09/02/%E7%AE%97%E6%B3%95-0003.html" rel="alternate" type="text/html" title="Hashing" /><published>2022-09-02T00:00:00+08:00</published><updated>2022-09-02T00:00:00+08:00</updated><id>http://localhost:4000/%E7%AE%97%E6%B3%95/2022/09/02/%E7%AE%97%E6%B3%95-0003</id><content type="html" xml:base="http://localhost:4000/%E7%AE%97%E6%B3%95/2022/09/02/%E7%AE%97%E6%B3%95-0003.html"><![CDATA[<h3 id="1-比较模型">1. 比较模型</h3>

<div align="center">
<img src="/image/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95-0003-1.png" width="500" />
<p></p>
</div>

<p>在序列接口常用的操作中，普通的 Array 实现，时间复杂度都为 O(n)，这些操作都需要遍历整个数组。而 Sorted Array 由于在内部保持元素的有序性，在 find 操作上占优势。那么，可以实现更快的查找和动态操作吗，可以让 <strong>find 操作</strong>时间复杂度小于 O(log n)吗？</p>

<p><strong>比较模型：</strong></p>
<ul>
  <li>在该模型中，算法仅能通过比较来区分不同的元素</li>
  <li>可比较的项相当于一个黑盒，只能支持两个项之间的比较操作</li>
  <li>比较操作有：&lt;, &lt;=, &gt;, &gt;=, ==, !=</li>
  <li><strong>目标</strong>：在 n 个可比较项的集合上，实现 find(k) 操作</li>
  <li>比较的次数决定了运行时间的下界，因此，评估时间复杂度，要数比较操作的次数。</li>
</ul>

<p><strong>决策树：</strong></p>
<ul>
  <li>任何比较模型的 find 算法可以看作执行比较操作的决策树(decision tree)</li>
  <li>内部结点表示两个元素的比较，分支代表结果为 True 或 False</li>
  <li>叶子结点代表算法结束，产生算法的输出</li>
  <li>由根结点到叶子结点的路径表示在特定输出时算法所执行的操作</li>
  <li>对于每个算法的输出，都需要一个叶子结点，因此决策树最少有 n+1 个叶子结点。这 n+1 个叶子结点分别对应数组内的 n 个元素，以及数组内不包含要查找元素这个特殊情况。</li>
</ul>

<p><strong>注意：</strong>这里的目的是实现 find 操作，决策树也是对应的 find 操作，与算法导论第 8 章中的排序决策树有差别。</p>

<p>通过比较操作来查找某一元素的时间复杂度：</p>
<ul>
  <li>可以对比较操作进行计数，来确定时间复杂度的下界</li>
  <li>由于最少有 n+1 个叶子结点，因此，二叉树的最小高度为 Ω(log n)，运行时间的下界为 Ω(log n)</li>
</ul>

<p>如何实现更快的 find 操作？</p>

<h3 id="2-hashing">2. Hashing</h3>

<p>通过比较操作来查找元素，下界为 Ω(log n)，假如要实现更快的 find 操作，可以通过直接访问的方法。这有点类似于内存访问。</p>

<h3 id="21-直接访问数组-direct-access-arrays">2.1 直接访问数组 (Direct Access Arrays)</h3>

<p>假如要存储 n 个项，给每个项分配一个在 [0, u-1] 范围内的独特整数值，那么可以直接把这 n 个项存储在长度为 u 的直接访问数组中。数组中索引为 i 个位置存储的是分配到整数 i 的项。如果要查找该项，只要访问数组中索引 i 位置即可。</p>

<p>简单来说，直接访问数组是根据 x.key，直接放入与这个 key 一样的索引位置。就像在内存访问中，假如程序要访问 stack 中的一条数据，该数据有特定地址，这个地址就是数据的 key。程序访问内存中对应的地址，得到数据内容。</p>

<p>直接访问数组的 order 操作时间复杂度会高，因为项并不是依次分配整数值，在数组中一个位置可能不存在项，但之后的位置可能存在项。要查找下一个元素，必须依次往后面找。</p>

<p>直接访问数组的 find 操作时间复杂度取决于 n 和 u 的关系。当 u » n，不会发生冲突，但是数组中存在空间的浪费。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class DirectAccressArray:
    def __init__(self, u):   self.A  =[None] * u   # 初始化空间为 u 的数组
    def find(self, k):       return self.A[k]      # 查找索引为 k 的项
    def insert(self, x):     self.A[x.key] = x     # 按 key 存入项
    def delete(self, k):     self.A[k] = None      # 删除索引为 k 的项
    def find_next(self, k):
        for i in range(k, len(self.A)):   # 从索引 k 开始依次往后找
            if A[i] is not None:
                return A[i]
    def find_max(self):                   # 从后往前找
        for i in range(len(self.A)-1, -1, -1):
            if A[i] is not None:
                return A[i]
    def delete_max(self):
        for i in range(len(self.A)-1, -1, -1):
            x = A[i]
            if x is not None:
                A[i] = None
                return x
</code></pre></div></div>

<h3 id="22-hashing">2.2 hashing</h3>

<p>直接访问数组可以 O(1) 时间复杂度实现 find，insert，delete操作，但是前提是 u » n。当 n « u 时，如何用 O(n) 空间来实现直接访问数组呢？哈希主要解决的就是直接访问数组的空间占用大问题，hashing 相比于直接访问数据，添加了映射过程。</p>

<p>可以把 n 项存储在一个小空间的数组中，数组的尺寸不为 u，而是 m = O(n)。给项分配整数值后也不能直接存入数组，得通过映射过程，把 [0, u-1] 范围内的值映射到 [0, m-1]。这样的映射函数叫做 hash 函数。</p>

<ul>
  <li>通过 hash 函数，把项映射到数组中特定的位置</li>
  <li>hash 函数：h(k) : {0, . . . , u − 1} → {0, . . . , m − 1}
    <ul>
      <li>u 是所有项可能的取值，m 是数组的尺寸</li>
    </ul>
  </li>
  <li>长度比项所有可能取值 u 更小的直接访问数组，叫做 hash 表，空间为 m。</li>
  <li>如果两个元素a，b，h(a) = h(b)，那么发生了冲突。
    <ul>
      <li>要么通过开放寻址来解决，存储在数组中的其他位置</li>
      <li>要么通过链接来解决，把具有相同的 hash 值元素存储在一块，然后链接到索引位置。</li>
    </ul>
  </li>
</ul>

<h3 id="23-hash-函数">2.3 hash 函数</h3>

<p>最简单的 hash 函数： h(k) = (k mod m)</p>
<ul>
  <li>当所有的 key 是均匀分布时，可以有好的效果</li>
  <li>m 一般选大的质数</li>
</ul>

<p>通用 hash 函数： hab(k) = (((ak + b) mod p) mod m)</p>
<ul>
  <li>a, b ∈ {0, . . . , p − 1} and a 不为 0</li>
  <li>在多个 hash 函数中，随机选择 a，b，确定一个 hash 函数</li>
  <li>可以达到更短的链长度，即冲突少。m = Ω(n) 时，在每个索引位置的链长度期望值为 O(1)</li>
</ul>

<div align="center">
<img src="/image/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95-0003-2.png" width="600" />
<p></p>
</div>

<p>表中 Direct Access Array 的 u 代表 key 的最大取值；Hash Table 中的下标 e 代表是期望值，a 代表摊还分析 (amortized)</p>]]></content><author><name>syh</name><email>songibicf@gmail.com</email></author><category term="算法" /><summary type="html"><![CDATA[1. 比较模型]]></summary></entry></feed>