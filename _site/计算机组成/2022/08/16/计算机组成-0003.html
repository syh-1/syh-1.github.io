<!DOCTYPE html>
<html lang="zh-cn"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>并行 | syh 的博客</title>
<meta name="generator" content="Jekyll v4.2.2" />
<meta property="og:title" content="并行" />
<meta name="author" content="syh" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="1. 并行的原因" />
<meta property="og:description" content="1. 并行的原因" />
<link rel="canonical" href="http://localhost:4000/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/2022/08/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90-0003.html" />
<meta property="og:url" content="http://localhost:4000/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/2022/08/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90-0003.html" />
<meta property="og:site_name" content="syh 的博客" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2022-08-16T00:00:00+08:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="并行" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"syh"},"dateModified":"2022-08-16T00:00:00+08:00","datePublished":"2022-08-16T00:00:00+08:00","description":"1. 并行的原因","headline":"并行","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/2022/08/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90-0003.html"},"url":"http://localhost:4000/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/2022/08/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90-0003.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/css/style.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="syh 的博客" />

<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/site.webmanifest">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
<meta name="msapplication-TileColor" content="#da532c">
<meta name="theme-color" content="#ffffff"></head>
<body><header class="site-header">

  <div class="wrapper"><a class="site-title" rel="author" href="/">syh 的博客</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/%E7%AE%97%E6%B3%95.html">算法</a><a class="page-link" href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90.html">计算机组成</a><a class="page-link" href="/about/">关于我</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">并行</h1>
    <p class="post-meta"><time class="dt-published" datetime="2022-08-16T00:00:00+08:00" itemprop="datePublished">
        Aug 16, 2022
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <h3 id="1-并行的原因">1. 并行的原因</h3>

<p>为什么要并行化？</p>
<ul>
  <li>由于技术和经济原因，CPU 的时钟频率不再增加</li>
  <li>只有通过并行处理，才能达到更快的处理速度</li>
</ul>

<p>并行化的两种基本方法：</p>
<ul>
  <li>Multiprogramming
    <ul>
      <li>并行运行多个独立的程序</li>
    </ul>
  </li>
  <li>Parallel computing
    <ul>
      <li>并行计算，更快的运行一个程序</li>
    </ul>
  </li>
</ul>

<h3 id="2-并行方法">2. 并行方法</h3>

<div align="center">
<img src="/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90-0003-1.png" width="200" />
</div>

<p>Single-Instruction/Multiple-Data Stream (SIMD):
SIMD 使用单条指令流来处理多条数据流，例如 Intel SIMD 指令集扩展或者 Nvidia GPU。</p>

<div align="center">
<img src="/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90-0003-2.png" width="200" />
</div>

<p>Multi-Instruction/Multiple-Data Stream (MIMD):
MIMD 使用多个处理器在不同的数据上执行不同的指令，MIMD 架构包括多个核心。</p>

<p>SIMD 和 MIMD 是目前最常用的并行化方法，例如 SSE 指令是单指令多数据，在 Xeon 中使用了 MIMD。</p>

<p>最常用的并行化编程方法：</p>
<ul>
  <li>单个程序运行在所有的处理器上</li>
  <li>使用同步原语来实现跨处理器的同步</li>
</ul>

<h3 id="3-simd">3. SIMD</h3>

<div align="center">
<img src="/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90-0003-3.png" width="500" />
</div>

<p>SIMD 中的一条指令可以完成多个数据的操作。正如上图所示，一条加法指令可以完成 8 组数据的相加。SIMD 在 x86、ARM、RISC-V 架构中都有实现。</p>

<p>Intel cpu 的 SIMD 功能可以通过 intrinsic functions 来进行调用。这些函数直接对应于特定的汇编指令，但是可以用 c 语言来写。</p>

<p>函数命名规则：https://www.intel.com/content/www/us/en/develop/documentation/cpp-compiler-developer-guide-and-reference/top/compiler-reference/intrinsics/naming-and-usage-syntax.html</p>

<p>长度为 128 位的数据可以指定的类型：</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>__m128    四个 float 类型
__m128d   两个 double 类型
__m128i   整数
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 例子
// 使用 _mm_setr 函数来设置 128 数据的值
__m128i values = _mm_setr_epi32(0x1234, 0x2345, 0x3456, 0x4567);

// 使用 _mm_extract_epi32(values, i)来提取值
int first_value = _mm_extract_epi32(values, 0);
int second_value = _mm_extract_epi32(values, 1);

// 存储值到内存中
int arrayA[4];
_mm_storeu_si128((_m128i*)arrayA, values);

// 从内存中加载值
int arrayB[4] = {10, 20, 30, 40};
values = _mm_loadu_si128((__m128i*) arrayB);
</code></pre></div></div>

<h3 id="4-mimd">4. MIMD</h3>

<p>MIMD 中使用了多个处理器。每个处理器有自己的 PC，并且执行独立的指令流。不同的处理器可以访问相同的内存空间。</p>

<p>使用多个处理器的两种方式：</p>
<ol>
  <li>对于不同的 job，通过 job-level 的并行，实现高吞吐量。</li>
  <li>在多处理器上运行单个程序，把这个程序分割成不同处理器上运行的子任务 (线程)，实现并行处理。</li>
</ol>

<p>线程是指执行某些任务的顺序指令流，每个线程都有自己的PC、寄存器并访问进程的共享内存。每个处理器的 core 提供一个或多个硬件线程来实际执行某一线程的指令。常见的 Intel 芯片每个 core 提供 2 线程。</p>

<p>操作系统将多个线程多路复用到可用的硬件线程。操作系统通过<strong>时分复用</strong>将软件线程分配到硬件线程上，以在特定的处理器上同时执行非常多的任务。时分复用是指把时间分成不同的时间间隔，任一线程只能执行几个时间间隔。当该线程时间耗尽或者阻塞时，操作系统中断该线程，把 context，包括寄存器、PC 存入内存中，并且操作系统会运行另一个线程。</p>

<h4 id="41-openmp-并行编程">4.1 OpenMP 并行编程</h4>

<p>OpenMP 是用于多线程并行编程的语言扩展。其编程模型如下图所示。</p>

<div align="center">
<img src="/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90-0003-4.png" width="400" />
</div>

<p>开始是单个线程，master thread，并且为顺序执行，直到遇到 parallel region。在并行区主线程会创建多个并行线程，每个线程会执行并行区的语句，直到所有线程全部完成，此时会进行 JOIN，只留下主线程。</p>

<p>数据竞争 (data race)：并行编程中常见的问题。如果多个线程尝试访问相同的内存位置，并且至少有一个线程进行写操作，那么有可能形成数据竞争。此时程序运行的结果不确定，需要通过同步指令来明确访问顺序，以产生确定的结果。主要通过锁来控制线程对关键部分的访问，使得一次只能有一个线程进行操作。</p>

<h3 id="5-smp">5. SMP</h3>

<div align="center">
<img src="/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90-0003-5.png" width="400" />
</div>

<p>SMP 指的对称多处理机 (Symmetric Multiprocessor)，满足以下条件：</p>
<ul>
  <li>包含两个或者多个相同的 CPUs/Cores</li>
  <li>单个的共享内存</li>
</ul>

<p>所有的处理器共享同一个物理地址空间。处理器之间通过内存里共享的变量进行通信，共享数据必须通过同步原语来访问。</p>

<h4 id="51-多处理器中的-cache">5.1 多处理器中的 cache</h4>

<div align="center">
<img src="/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90-0003-6.png" width="400" />
</div>

<p>即使只有一个处理器，内存也是性能瓶颈，因此使用 cache 来减少对内存访问的带宽需求。每个 core 有自己的私有 cache，只有当 cache miss 时才需要访问内存。</p>

<p>多处理器中要处理 cache 中数据一致性问题。总线上的两个 CPU 都读取相同的数据； 每个处理器都获得数据的副本并将其存储在他们的 cache 中。假如一个 CPU 执行了一次写操作，该 CPU 的 cache 是最新的，但是其他处理器的 cache 中存有过时的数据。因此要确保一个 CPU 改变了数据，别的 CPU 数据也应该进行更新。</p>

<p>解决方案：追踪 block 的状态。每个 cache 使用 valid bit、dirty bit、shared bit 追踪存储的每个块的状态，状态包含：</p>

<ol>
  <li><strong>Shared</strong>: up-to-date data, other caches may have a copy (Valid Bit set, shared bit set)</li>
  <li><strong>Modified</strong>: up-to-date data, <strong>changed (dirty)</strong>, no other cache has a copy, OK to write, memory out-of-date (Valid and Dirty bit is set)</li>
  <li><strong>Exclusive</strong>: up-to-date data, no other cache has a copy, OK to write, memory up-to-date</li>
  <li><strong>Owner</strong>: up-to-date data, other caches may have a copy (they must be in Shared state), memory is not up-to-date</li>
</ol>

<p>该 cache coherency protocol 叫做 MOESI。</p>

  </div><a class="u-url" href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/2022/08/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90-0003.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col">
        <ul class="contact-list">
          <li class="p-name">syh</li>
          <li><a class="u-email" href="mailto:songibicf@gmail.com">songibicf@gmail.com</a></li>
        </ul>
      </div>
      <div class="footer-col">
        <p>记录计算机专业相关内容，Mens et Manus
</p>
      </div>
    </div>

    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span id="busuanzi_container_site_pv">总访问量 <span id="busuanzi_value_site_pv"></span> 次</span>

    <div class="social-links"><ul class="social-media-list"><li><a rel="me" href="https://github.com/syh-1" target="_blank" title="syh-1"><svg class="svg-icon grey"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg></a></li></ul>
</div>

    

  </div>

</footer>
</body>

</html>
